/*!
 * Copyright (c) Aaron Delasy
 * Licensed under the MIT License
 */

export type Type =
  ArrayType |
  EmptyType |
  FunctionType |
  IdentifierType |
  MapType |
  MemberType |
  OptionalType |
  ParenthesizedType |
  ReferenceType |
  UnionType

export type Expression =
  Identifier |

  BooleanLiteral |
  CharacterLiteral |
  FloatingPointLiteral |
  IntegerLiteral |
  NilLiteral |
  StringLiteral |

  ArrayExpression |
  AsExpression |
  AssignmentExpression |
  AwaitExpression |
  BinaryExpression |
  CallExpression |
  ClosureExpression |
  ConditionalExpression |
  ElementAccessExpression |
  EmptyExpression |
  IsExpression |
  MapExpression |
  MemberAccessExpression |
  ObjectExpression |
  ParenthesizedExpression |
  PropertyAccessExpression |
  ReferenceExpression |
  UnaryExpression

export type Statement =
  BlockStatement |
  BreakStatement |
  ContinueStatement |
  EmptyStatement |
  EnumDeclaration |
  EofStatement |
  ExportDeclaration | // todo
  ExportNamedDeclaration | // todo
  ExpressionStatement |
  FunctionDeclaration | // todo
  IfStatement |
  ImportDeclaration | // todo
  LoopStatement | // todo
  MainDeclaration |
  ObjectDeclaration | // todo
  ReturnStatement | // todo
  ThrowStatement | // todo
  TryStatement | // todo
  TypeAliasDeclaration | // todo
  VariableDeclaration

export obj Identifier {
  start: int
  end: int
  name: str
}

export obj FunctionParameter {
  name: Identifier
  t: Type?
  initializer: Expression?
  mutable: bool
  variadic: bool
}

export obj ArrayType {
  start: int
  end: int
  elementType: Type
}

export obj EmptyType {
  start: int
  end: int
}

export obj FunctionTypeParameter {
  name: Identifier?
  t: Type
  mutable: bool
  variadic: bool
}

export obj FunctionType {
  start: int
  end: int
  parameters: FunctionTypeParameter[]
  returnType: Type
  asynchronous: bool
}

export obj IdentifierType {
  start: int
  end: int
  name: Identifier
}

export obj MapType {
  start: int
  end: int
  keyType: Type
  valueType: Type
}

export obj MemberType {
  start: int
  end: int
  t: Type
  name: Identifier
}

export obj OptionalType {
  start: int
  end: int
  t: Type
}

export obj ParenthesizedType {
  start: int
  end: int
  t: Type
}

export obj ReferenceType {
  start: int
  end: int
  t: Type
}

export obj UnionType {
  start: int
  end: int
  types: Type[]
}

export obj BooleanLiteral {
  start: int
  end: int
  value: str
}

export obj CharacterLiteral {
  start: int
  end: int
  raw: str
  value: str
}

export obj FloatingPointLiteral {
  start: int
  end: int
  value: str
}

export enum IntegerLiteralType {
  Binary,
  Decimal,
  Hexadecimal,
  Octal
}

export obj IntegerLiteral {
  start: int
  end: int
  t: IntegerLiteralType
  value: str
}

export obj NilLiteral {
  start: int
  end: int
}

export obj StringLiteral {
  start: int
  end: int
  raw: str
  value: str
}

export obj ArrayExpression {
  start: int
  end: int
  elements: Expression[]
}

export obj AsExpression {
  start: int
  end: int
  expression: Expression
  t: Type
}

export obj AssignmentExpression {
  start: int
  end: int
  left: Expression
  operator: str
  right: Expression
}

export obj AwaitExpression {
  start: int
  end: int
  expression: Expression
}

export obj BinaryExpression {
  start: int
  end: int
  left: Expression
  operator: str
  right: Expression
}

export obj CallExpressionArgument {
  name: Identifier?
  expression: Expression
}

export obj CallExpression {
  start: int
  end: int
  callee: Expression
  arguments: CallExpressionArgument[]
}

export obj ClosureExpression {
  start: int
  end: int
  parameters: FunctionParameter[]
  returnType: Type
  body: Statement
  asynchronous: bool
}

export obj ConditionalExpression {
  start: int
  end: int
  condition: Expression
  consequent: Expression
  alternate: Expression
}

export obj ElementAccessExpression {
  start: int
  end: int
  expression: Expression
  argument: Expression
}

export obj EmptyExpression {
  start: int
  end: int
}

export obj IsExpression {
  start: int
  end: int
  expression: Expression
  t: Type
}

export obj MapExpressionElement {
  key: Expression
  value: Expression
}

export obj MapExpression {
  start: int
  end: int
  elements: MapExpressionElement[]
}

export obj MemberAccessExpression {
  start: int
  end: int
  name: Identifier
}

export obj ObjectExpressionProperty {
  name: Identifier
  value: Expression
}

export obj ObjectExpression {
  start: int
  end: int
  id: Expression
  properties: ObjectExpressionProperty[]
}

export obj ParenthesizedExpression {
  start: int
  end: int
  expression: Expression
}

export obj PropertyAccessExpression {
  start: int
  end: int
  expression: Expression
  name: Identifier
}

export obj ReferenceExpression {
  start: int
  end: int
  expression: Expression
}

export obj UnaryExpression {
  start: int
  end: int
  operand: Expression
  operator: str
  prefix: bool
}

export obj BlockStatement {
  start: int
  end: int
  body: Statement[]
}

export obj BreakStatement {
  start: int
  end: int
}

export obj ContinueStatement {
  start: int
  end: int
}

export obj EmptyStatement {
  start: int
  end: int
}

export obj EnumDeclarationMember {
  name: Identifier
  initializer: Expression?
}

export obj EnumDeclaration {
  start: int
  end: int
  name: Identifier
  members: EnumDeclarationMember[]
}

export obj EofStatement {
  start: int
  end: int
}

export obj ExportDeclaration {
  start: int
  end: int
  statement: Statement
}

export obj ExportNamedDeclaration {
  start: int
  end: int
  expression: Expression
}

export obj ExpressionStatement {
  start: int
  end: int
  expression: Expression
}

export obj FunctionDeclaration {
  start: int
  end: int
  name: Identifier
  params: FunctionParameter[]
  returnType: Type
  body: Statement
  asynchronous: bool
}

export obj IfStatement {
  start: int
  end: int
  condition: Expression
  consequent: Statement
  alternate: Statement?
}

export obj ImportSpecifier {
  start: int
  end: int
  imported: Identifier
  local: Identifier
}

export obj ImportNamespaceSpecifier {
  start: int
  end: int
  name: Identifier
}

export type ImportDeclarationSpecifier = ImportSpecifier | ImportNamespaceSpecifier

export obj ImportDeclaration {
  start: int
  end: int
  specifiers: ImportDeclarationSpecifier[]
  source: Expression
}

export obj LoopStatement {
  start: int
  end: int
  initializer: Statement?
  condition: Expression?
  update: Expression?
  body: Statement
  parenthesized: bool
}

export obj MainDeclaration {
  start: int
  end: int
  body: Statement
}

export obj ObjectDeclaration {
  start: int
  end: int
  name: Identifier
  body: Statement
}

export obj ReturnStatement {
  start: int
  end: int
  expression: Expression?
}

export obj ThrowStatement {
  start: int
  end: int
  expression: Expression
}

export obj TryStatementHandler {
  param: Statement
  body: Statement
}

export obj TryStatement {
  start: int
  end: int
  body: Statement
  handlers: TryStatementHandler[]
}

export obj TypeAliasDeclaration {
  start: int
  end: int
  name: Identifier
  t: Type
}

export obj VariableDeclaration {
  start: int
  end: int
  name: Identifier
  t: Type?
  initializer: Expression?
  mutable: bool
  constant: bool
}

export obj File {
  path: str
  errors: str[]
  hasErrors: bool
  mut program: Program
}

export obj Location {
  mut line: int
  mut col: int
}

export obj Program {
  body: Statement[]
}

export enum TokenAssociativity {
  None,
  Left,
  Right,
}

export enum TokenType {
  Unknown,
  Eof,
  Id,
  Whitespace,

  CommentBlock,
  CommentLine,

  LitChar,
  LitFloat,
  LitIntBin,
  LitIntDec,
  LitIntHex,
  LitIntOct,
  LitStr,

  KwAs,
  KwAsync,
  KwAwait,
  KwBreak,
  KwCatch,
  KwConst,
  KwContinue,
  KwElif,
  KwElse,
  KwEnum,
  KwExport,
  KwFalse,
  KwFn,
  KwFrom,
  KwIf,
  KwImport,
  KwIs,
  KwLoop,
  KwMain,
  KwMut,
  KwNil,
  KwObj,
  KwRef,
  KwReturn,
  KwThrow,
  KwTrue,
  KwTry,
  KwType,

  OpAmp,
  OpAmpEq,
  OpAmpAmp,
  OpAmpAmpEq,
  OpArrow,
  OpAt,
  OpBacktick,
  OpBackslash,
  OpCaret,
  OpCaretEq,
  OpColon,
  OpColonEq,
  OpComma,
  OpDot,
  OpDollar,
  OpEllipsis,
  OpEq,
  OpEqEq,
  OpExcl,
  OpExclEq,
  OpGt,
  OpGtEq,
  OpHash,
  OpLBrace,
  OpLBrack,
  OpLPar,
  OpLShift,
  OpLShiftEq,
  OpLt,
  OpLtEq,
  OpMinus,
  OpMinusEq,
  OpMinusMinus,
  OpPipe,
  OpPipeEq,
  OpPipePipe,
  OpPipePipeEq,
  OpPercent,
  OpPercentEq,
  OpPlus,
  OpPlusEq,
  OpPlusPlus,
  OpQn,
  OpRBrace,
  OpRBrack,
  OpRPar,
  OpRShift,
  OpRShiftEq,
  OpSemi,
  OpSlash,
  OpSlashEq,
  OpStar,
  OpStarEq,
  OpTilde,
}

export obj TokenizerState {
  mut idx: int
  mut pos: int
  mut ch: char
  mut handled: bool
}
