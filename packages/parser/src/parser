/*!
 * Copyright (c) Aaron Delasy
 * Licensed under the MIT License
 */

import Statement_toText from "./text"
import * as Expression from "./expression"
import * as Reader from "./reader"
import * as Statement from "./statement"
import * as Token from "./token"
import * as Tokenizer from "./tokenizer"
import * as Type from "./type"
import * as errors from "./errors"
import * as t from "./types"

export enum ParserExpressionWrapper {
  As,
  Assignment,
  Binary,
  Call,
  Conditional,
  ElementAccess,
  Is,
  Object,
  PropertyAccess,
  Unary,
}

export obj ParserWrapOutput {
  mut expression: t.Expression
  mut shouldWrap: bool
}

export obj Parser {
  mut tokenizer: ref Tokenizer.Tokenizer

  fn comments (mut self: ref Self) t.Token[] {
    mut result: t.Token[]

    loop (
      self.tokenizer.lookahead(.CommentBlock, true, allowComments: true) ||
      self.tokenizer.lookahead(.CommentLine, true, allowComments: true)
    ) {
      result.push(self.tokenizer.next(allowComments: true))
    }

    return result
  }

  fn next (mut self: ref Self) t.Statement {
    mut statement := self.nextStatement()

    if statement == nil {
      tk := self.tokenizer.next()
      self._raise(errors.E0104(tk.val), tk.start, tk.end)
      statement = Statement.dummy()
    }

    return statement as t.Statement
  }

  fn nextExpression (mut self: ref Self, shouldWrap := true) t.Expression? {
    comments := self.comments()
    startPos := self.tokenizer.pos()
    mut e: t.Expression?

    if (
      (e = self._maybeArrayExpression()) != nil ||
      (e = self._maybeAwaitExpression()) != nil ||
      (e = self._maybeClosureExpression()) != nil ||
      (e = self._maybeMapExpression()) != nil ||
      (e = self._maybeMemberAccessExpression()) != nil ||
      (e = self._maybeParenthesizedExpression()) != nil ||
      (e = self._maybeReferenceExpression()) != nil ||
      (e = self._maybeUnaryExpression()) != nil ||
      (e = self._maybeLiteral()) != nil ||
      (e = self._maybeIdentifier()) != nil
    ) {
      e.leadingComments = comments
      e.trailingComments = self.comments()
      return shouldWrap ? self._wrapExpression(e) : e
    }

    return nil
  }

  fn nextIdentifier (mut self: ref Self, allowKeywords := false) t.Identifier? {
    startPos := self.tokenizer.pos()
    tk := self.tokenizer.next()

    if tk.t == .Id || (allowKeywords && tk.t.rawValue.slice(0, 2) == "Kw") {
      return t.Identifier{name: tk.val, start: tk.start, end: tk.end}
    }

    self.tokenizer.seek(startPos)
    return nil
  }

  fn nextStatement (
    mut self: ref Self,
    insideObjectDeclaration := false,
    shouldWrap := true,
    withBlockStatement := false,
    withElifStatement := false
  ) t.Statement? {
    comments := self.comments()

    if self.tokenizer.lookahead(.Eof) {
      return Statement.create(
        t.EofStatement{},
        self.tokenizer.readerStartPos(),
        self.tokenizer.readerEndPos(),
        leadingComments: comments
      )
    }

    mut statement: t.Statement?

    if (
      (withBlockStatement && (statement = self._maybeBlockStatement()) != nil) ||
      (!insideObjectDeclaration && (statement = self._maybeBreakStatement()) != nil) ||
      (!insideObjectDeclaration && (statement = self._maybeContinueStatement()) != nil) ||
      (!insideObjectDeclaration && (statement = self._maybeEnumDeclaration()) != nil) ||
      (!insideObjectDeclaration && (statement = self._maybeExportDeclaration()) != nil) ||
      (statement = self._maybeFunctionDeclaration(insideObjectDeclaration: insideObjectDeclaration)) != nil ||
      (!insideObjectDeclaration && (statement = self._maybeIfStatement(withElifStatement: withElifStatement)) != nil) ||
      (!insideObjectDeclaration && (statement = self._maybeImportDeclaration()) != nil) ||
      (!insideObjectDeclaration && (statement = self._maybeLoopStatement()) != nil) ||
      (!insideObjectDeclaration && (statement = self._maybeMainDeclaration()) != nil) ||
      (!insideObjectDeclaration && (statement = self._maybeObjectDeclaration()) != nil) ||
      (!insideObjectDeclaration && (statement = self._maybeReturnStatement()) != nil) ||
      (!insideObjectDeclaration && (statement = self._maybeThrowStatement()) != nil) ||
      (!insideObjectDeclaration && (statement = self._maybeTryStatement()) != nil) ||
      (!insideObjectDeclaration && (statement = self._maybeTypeAliasDeclaration()) != nil) ||
      (statement = self._maybeVariableDeclaration(insideObjectDeclaration: insideObjectDeclaration)) != nil ||
      (!insideObjectDeclaration && (statement = self._maybeExpressionStatement()) != nil)
    ) {
      statement.leadingComments = comments
      statement.trailingComments = self.comments()
      return shouldWrap ? self._wrapStatement(statement) : statement
    } elif !insideObjectDeclaration && self.tokenizer.lookahead(.OpSemi) {
      return Statement.create(
        t.EmptyStatement{},
        self.tokenizer.readerStartPos(),
        self.tokenizer.readerEndPos(),
        leadingComments: comments,
        trailingComments: self.comments()
      )
    }

    return nil
  }

  fn nextType (mut self: ref Self, withoutUnion := false) t.Type? {
    comments := self.comments()
    mut possibleType: t.Type?

    if (
      (possibleType = self._maybeFunctionOrParenthesizedType()) != nil ||
      (possibleType = self._maybeReferenceType()) != nil ||
      (possibleType = self._maybeIdentifierType()) != nil
    ) {
      possibleType.leadingComments = comments
      possibleType.trailingComments = self.comments()
      return self._wrapType(possibleType, withoutUnion: withoutUnion)
    }

    return nil
  }

  fn _maybeArrayExpression (mut self: ref Self) t.Expression? {
    if !self.tokenizer.lookahead(.OpLBrack) {
      return nil
    }

    readerStartPos := self.tokenizer.readerStartPos()
    mut elements: t.Expression[]
    mut elementStartPos := -1

    loop !self.tokenizer.lookahead(.OpRBrack) {
      if self.tokenizer.lookahead(.Eof, true) || elementStartPos == self.tokenizer.pos() {
        self._raise(errors.E0116("array expression"))
        break
      }

      elementStartPos = self.tokenizer.pos()
      expression := self.nextExpression()

      if expression == nil {
        self._raise(errors.E0108("array expression"))
      } else {
        elements.push(expression)
      }

      if !self.tokenizer.lookahead(.OpComma) && !self.tokenizer.lookahead(.OpRBrack, true) {
        self._raise(errors.E0106("array expression element"))
      }
    }

    return Expression.create(
      t.ArrayExpression{elements: elements},
      readerStartPos,
      self.tokenizer.readerEndPos()
    )
  }

  fn _maybeAwaitExpression (mut self: ref Self) t.Expression? {
    if !self.tokenizer.lookahead(.KwAwait) {
      return nil
    }

    readerStartPos := self.tokenizer.readerStartPos()
    mut expression := self.nextExpression()

    if expression == nil {
      self._raise(errors.E0109("await"))
      expression = Expression.dummy()
    }

    return Expression.create(
      t.AwaitExpression{expression: expression as t.Expression},
      readerStartPos,
      self.tokenizer.readerEndPos()
    )
  }

  fn _maybeBlockStatement (mut self: ref Self) t.Statement? {
    if !self.tokenizer.lookahead(.OpLBrace) {
      return nil
    }

    readerStartPos := self.tokenizer.readerStartPos()
    mut body: t.Statement[]

    loop !self.tokenizer.lookahead(.OpRBrace) {
      if self.tokenizer.lookahead(.Eof, true) {
        self._raise(errors.E0101())
        break
      }

      statement := self.next()
      body.push(statement)
    }

    return Statement.create(
      t.BlockStatement{body: body},
      readerStartPos,
      self.tokenizer.readerEndPos()
    )
  }

  fn _maybeBreakStatement (mut self: ref Self) t.Statement? {
    if !self.tokenizer.lookahead(.KwBreak) {
      return nil
    }

    return Statement.create(
      t.BreakStatement{},
      self.tokenizer.readerStartPos(),
      self.tokenizer.readerEndPos()
    )
  }

  fn _maybeClosureExpression (mut self: ref Self) t.Expression? {
    if !self.tokenizer.lookahead(.KwAsync, true) && !self.tokenizer.lookahead(.OpLPar, true) {
      return nil
    }

    readerStartPos := self.tokenizer.readerStartPos(offset: 1)
    startPos := self.tokenizer.pos()
    asynchronous := self.tokenizer.lookahead(.KwAsync)

    if !self.tokenizer.lookahead(.OpLPar) {
      self.tokenizer.seek(startPos)
      return nil
    }

    mut parameters: t.FunctionParameter[]
    mut parameterStartPos := -1

    loop !self.tokenizer.lookahead(.OpRPar) {
      if self.tokenizer.lookahead(.Eof, true) || parameterStartPos == self.tokenizer.pos() {
        if !asynchronous && parameters.empty {
          self.tokenizer.seek(startPos)
          return nil
        }

        self._raise(errors.E0103("closure expression parameters"))
        break
      }

      parameterStartPos = self.tokenizer.pos()
      parameterMutable := self.tokenizer.lookahead(.KwMut)
      canGoBack := !asynchronous && parameters.empty && !parameterMutable
      parameterName := self.nextIdentifier(allowKeywords: true)

      if parameterName == nil {
        if canGoBack {
          self.tokenizer.seek(startPos)
          return nil
        }

        self._raise(errors.E0125())
      } else {
        mut parameterType: t.Type?
        mut parameterInitializer: t.Expression?
        mut parameterVariadic := false

        if self.tokenizer.lookahead(.OpColon) {
          parameterType = self.nextType()

          if parameterType == nil {
            self._raise(errors.E0127())
            parameterType = Type.dummy()
          }

          parameterVariadic = self.tokenizer.lookahead(.OpEllipsis)

          if self.tokenizer.lookahead(.OpEq) {
            parameterInitializer = self.nextExpression()

            if parameterInitializer == nil {
              self._raise(errors.E0128("equals sign"))
              parameterInitializer = Expression.dummy()
            }
          }
        } elif self.tokenizer.lookahead(.OpColonEq) {
          parameterInitializer = self.nextExpression()

          if parameterInitializer == nil {
            self._raise(errors.E0128("colon equals sign"))
            parameterInitializer = Expression.dummy()
          }
        } else {
          if canGoBack {
            self.tokenizer.seek(startPos)
            return nil
          }

          self._raise(errors.E0126())
          parameterType = Type.dummy()
        }

        parameters.push(t.FunctionParameter{
          name: parameterName,
          t: parameterType,
          initializer: parameterInitializer,
          mutable: parameterMutable,
          variadic: parameterVariadic
        })
      }

      if !self.tokenizer.lookahead(.OpComma) && !self.tokenizer.lookahead(.OpRPar, true) {
        self._raise(errors.E0106("closure expression parameter"))
      }
    }

    if !self.tokenizer.lookahead(.OpArrow) {
      self._raise(errors.E0129())
    }

    mut returnType := self.nextType()

    if returnType == nil {
      self._raise(errors.E0130())
      returnType = Type.dummy()
    }

    mut body := Statement.dummy()

    if self.tokenizer.lookahead(.OpLBrace, true) {
      statement := self.nextStatement(shouldWrap: false, withBlockStatement: true)

      if statement == nil {
        self._raise(errors.E0150())
      } else {
        body = statement
      }
    } else {
      self._raise(errors.E0102("expression closure return type"))
    }

    return Expression.create(
      t.ClosureExpression{
        parameters: parameters,
        returnType: returnType as t.Type,
        body: body,
        asynchronous: asynchronous
      },
      readerStartPos,
      self.tokenizer.readerEndPos()
    )
  }

  fn _maybeContinueStatement (mut self: ref Self) t.Statement? {
    if !self.tokenizer.lookahead(.KwContinue) {
      return nil
    }

    return Statement.create(
      t.ContinueStatement{},
      self.tokenizer.readerStartPos(),
      self.tokenizer.readerEndPos()
    )
  }

  fn _maybeEnumDeclaration (mut self: ref Self) t.Statement? {
    if !self.tokenizer.lookahead(.KwEnum) {
      return nil
    }

    readerStartPos := self.tokenizer.readerStartPos()
    mut name := self.nextIdentifier()

    if name == nil {
      self._raise(errors.E0145())
      name = Expression.dummyIdentifier()
    }

    if !self.tokenizer.lookahead(.OpLBrace) {
      self._raise(errors.E0102("enumeration declaration name"))
    }

    mut members: t.EnumDeclarationMember[]
    mut memberStartPos := -1

    loop !self.tokenizer.lookahead(.OpRBrace) {
      if self.tokenizer.lookahead(.Eof, true) || memberStartPos == self.tokenizer.pos() {
        self._raise(errors.E0146("enumeration declaration members"))
        break
      }

      memberStartPos = self.tokenizer.pos()
      mut name := self.nextIdentifier(allowKeywords: true)

      if name == nil {
        self._raise(errors.E0147())
        name = Expression.dummyIdentifier()
      }

      mut initializer: t.Expression?

      if self.tokenizer.lookahead(.OpEq) {
        initializer = self.nextExpression()

        if initializer == nil {
          self._raise(errors.E0148())
          initializer = Expression.dummy()
        }
      }

      members.push(t.EnumDeclarationMember{name: name as t.Identifier, initializer: initializer})

      if !self.tokenizer.lookahead(.OpComma) && !self.tokenizer.lookahead(.OpRBrace, true) {
        self._raise(errors.E0106("enumeration declaration member"))
      }
    }

    return Statement.create(
      t.EnumDeclaration{name: name as t.Identifier, members: members},
      readerStartPos,
      self.tokenizer.readerEndPos()
    )
  }

  fn _maybeExportDeclaration (mut self: ref Self) t.Statement? {
    if !self.tokenizer.lookahead(.KwExport) {
      return nil
    }

    readerStartPos := self.tokenizer.readerStartPos()
    mut statement := self.nextStatement()

    if statement == nil {
      self._raise(errors.E0172())
      statement = Statement.dummy()
    } elif statement.isExpression() {
      expression := statement.asExpression()

      return Statement.create(
        t.ExportNamedDeclaration{expression: expression.expression},
        readerStartPos,
        self.tokenizer.readerEndPos()
      )
    }

    return Statement.create(
      t.ExportDeclaration{statement: statement as t.Statement},
      readerStartPos,
      self.tokenizer.readerEndPos()
    )
  }

  fn _maybeExpressionStatement (mut self: ref Self) t.Statement? {
    expression := self.nextExpression()

    if expression != nil {
      return Statement.create(
        t.ExpressionStatement{expression: expression},
        expression.start,
        expression.end
      )
    }

    return nil
  }

  fn _maybeFunctionDeclaration (mut self: ref Self, insideObjectDeclaration := false) t.Statement? {
    startPos := self.tokenizer.pos()

    if !self.tokenizer.lookahead(.KwAsync, true) && !self.tokenizer.lookahead(.KwFn, true) {
      self.tokenizer.seek(startPos)
      return nil
    }

    readerStartPos := self.tokenizer.readerStartPos(offset: 1)
    asynchronous := self.tokenizer.lookahead(.KwAsync)

    if !self.tokenizer.lookahead(.KwFn) {
      self.tokenizer.seek(startPos)
      return nil
    }

    name := self.nextIdentifier()

    if name == nil {
      self.tokenizer.seek(startPos)
      return nil
    }

    if !self.tokenizer.lookahead(.OpLPar) {
      self._raise(errors.E0163("function declaration name"))
    }

    mut parameters: t.FunctionParameter[]
    mut parameterStartPos := -1

    loop !self.tokenizer.lookahead(.OpRPar) {
      if self.tokenizer.lookahead(.Eof, true) || parameterStartPos == self.tokenizer.pos() {
        self._raise(errors.E0103("function declaration parameters"))
        break
      }

      parameterStartPos = self.tokenizer.pos()
      parameterMutable := self.tokenizer.lookahead(.KwMut)
      parameterName := self.nextIdentifier(allowKeywords: true)

      if parameterName == nil {
        self._raise(errors.E0164())
      } else {
        mut parameterType: t.Type?
        mut parameterInitializer: t.Expression?
        mut parameterVariadic := false

        if self.tokenizer.lookahead(.OpColon) {
          parameterType = self.nextType()

          if parameterType == nil {
            self._raise(errors.E0166())
            parameterType = Type.dummy()
          }

          parameterVariadic = self.tokenizer.lookahead(.OpEllipsis)

          if self.tokenizer.lookahead(.OpEq) {
            parameterInitializer = self.nextExpression()

            if parameterInitializer == nil {
              self._raise(errors.E0167("equals sign"))
              parameterInitializer = Expression.dummy()
            }
          }
        } elif self.tokenizer.lookahead(.OpColonEq) {
          parameterInitializer = self.nextExpression()

          if parameterInitializer == nil {
            self._raise(errors.E0167("colon equals sign"))
            parameterInitializer = Expression.dummy()
          }
        } else {
          self._raise(errors.E0165())
          parameterType = Type.dummy()
        }

        parameters.push(t.FunctionParameter{
          name: parameterName,
          t: parameterType,
          initializer: parameterInitializer,
          mutable: parameterMutable,
          variadic: parameterVariadic
        })
      }

      if !self.tokenizer.lookahead(.OpComma) && !self.tokenizer.lookahead(.OpRPar, true) {
        self._raise(errors.E0106("function declaration parameter"))
      }
    }

    returnType := self.nextType()
    mut body: t.Statement?

    if self.tokenizer.lookahead(.OpLBrace, true) {
      statement := self.nextStatement(withBlockStatement: true)

      if statement == nil {
        self._raise(errors.E0150())
      } else {
        body = statement
      }
    } elif returnType == nil {
      self._raise(errors.E0169())
      returnType = Type.dummy()
    }

    if insideObjectDeclaration {
      return Statement.create(
        t.ObjectDeclarationMethod{
          name: name as t.Identifier,
          parameters: parameters,
          returnType: returnType,
          body: body,
          asynchronous: asynchronous
        },
        readerStartPos,
        self.tokenizer.readerEndPos()
      )
    } else {
      return Statement.create(
        t.FunctionDeclaration{
          name: name as t.Identifier,
          parameters: parameters,
          returnType: returnType,
          body: body,
          asynchronous: asynchronous
        },
        readerStartPos,
        self.tokenizer.readerEndPos()
      )
    }
  }

  fn _maybeFunctionOrParenthesizedType (mut self: ref Self) t.Type? {
    if !self.tokenizer.lookahead(.KwAsync, true) && !self.tokenizer.lookahead(.OpLPar, true) {
      return nil
    }

    readerStartPos := self.tokenizer.readerStartPos(offset: 1)
    startPos := self.tokenizer.pos()
    asynchronous := self.tokenizer.lookahead(.KwAsync)

    if !self.tokenizer.lookahead(.OpLPar) {
      self.tokenizer.seek(startPos)
      return nil
    }

    mut parameters: t.FunctionTypeParameter[]
    mut parameterStartPos := -1

    loop !self.tokenizer.lookahead(.OpRPar) {
      if self.tokenizer.lookahead(.Eof, true) || parameterStartPos == self.tokenizer.pos() {
        if !asynchronous && parameters.empty {
          self.tokenizer.seek(startPos)
          return nil
        }

        self._raise(errors.E0103("function type parameters"))
        break
      }

      parameterStartPos = self.tokenizer.pos()
      parameterMutable := self.tokenizer.lookahead(.KwMut)
      canGoBack := !asynchronous && parameters.empty && !parameterMutable
      beforeNamePos := self.tokenizer.pos()
      mut parameterName := self.nextIdentifier(allowKeywords: true)
      parameterName2 := parameterName
      mut parameterType: t.Type?

      if parameterName2 == nil {
        parameterType = self.nextType()

        if parameterType == nil {
          if canGoBack {
            self.tokenizer.seek(startPos)
            return nil
          }

          self._raise(errors.E0140())
          parameterType = Type.dummy()
        }
      } else {
        if self.tokenizer.lookahead(.OpColon) {
          parameterType = self.nextType()

          if parameterType == nil {
            self._raise(errors.E0142())
            parameterType = Type.dummy()
          }
        } else {
          self.tokenizer.seek(beforeNamePos)
          parameterName = nil
          parameterType = self.nextType()

          if parameterType == nil {
            if canGoBack {
              self.tokenizer.seek(startPos)
              return nil
            }

            self._raise(errors.E0141())
            parameterType = Type.dummy()
          }
        }
      }

      parameterVariadic := self.tokenizer.lookahead(.OpEllipsis)

      parameters.push(t.FunctionTypeParameter{
        name: parameterName,
        t: parameterType as t.Type,
        mutable: parameterMutable,
        variadic: parameterVariadic
      })

      if !self.tokenizer.lookahead(.OpComma) && !self.tokenizer.lookahead(.OpRPar, true) {
        self._raise(errors.E0106("function type parameter"))
      }
    }

    if !self.tokenizer.lookahead(.OpArrow) {
      if !asynchronous && parameters.len == 1 {
        parameter := parameters[0]

        if parameter.name == nil && !parameter.mutable && !parameter.variadic {
          return Type.create(
            t.ParenthesizedType{t: parameter.t},
            readerStartPos,
            self.tokenizer.readerEndPos()
          )
        }
      }

      self._raise(errors.E0143())
    }

    mut returnType := self.nextType()

    if returnType == nil {
      self._raise(errors.E0144())
      returnType = Type.dummy()
    }

    return Type.create(
      t.FunctionType{parameters: parameters, returnType: returnType as t.Type, asynchronous: asynchronous},
      readerStartPos,
      self.tokenizer.readerEndPos()
    )
  }

  fn _maybeIdentifier (mut self: ref Self) t.Expression? {
    id := self.nextIdentifier()

    if id != nil {
      return Expression.create(id, id.start, id.end)
    }

    return nil
  }

  fn _maybeIdentifierType (mut self: ref Self) t.Type? {
    name := self.nextIdentifier()

    if name != nil {
      return Type.create(t.IdentifierType{name: name}, name.start, name.end)
    }

    return nil
  }

  fn _maybeIfStatement (mut self: ref Self, withElifStatement := false) t.Statement? {
    if (
      !self.tokenizer.lookahead(.KwIf) &&
      !(withElifStatement && self.tokenizer.lookahead(.KwElif))
    ) {
      return nil
    }

    readerStartPos := self.tokenizer.readerStartPos()
    mut maybeCondition := self.nextExpression()

    if maybeCondition == nil {
      self._raise(errors.E0109("if"))
      maybeCondition = Expression.dummy()
    }

    condition := maybeCondition as t.Expression
    mut consequent := condition.isParenthesized()
      ? self.nextStatement(withBlockStatement: true)
      : self._maybeBlockStatement()

    if consequent == nil && Expression.endsWithObjExpr(condition) {
      objectExpression := Expression.extractLastObjExpr(condition)
      condition = Expression.subtractLastObjExpr(condition)
      self.tokenizer.errorSeek(objectExpression.errorPosIdx)
      self.tokenizer.readerSeek(objectExpression.id.end)
      consequent = self.nextStatement(withBlockStatement: true)
    }

    if consequent == nil {
      self._raise(errors.E0151())
      consequent = Statement.dummy()
    }

    mut alternate: t.Statement?

    if self.tokenizer.lookahead(.KwElif, true) || self.tokenizer.lookahead(.KwElse) {
      alternate = self.nextStatement(withBlockStatement: true, withElifStatement: true)

      if alternate == nil {
        self._raise(errors.E0152())
        alternate = Statement.dummy()
      }
    }

    return Statement.create(
      t.IfStatement{
        condition: condition,
        consequent: consequent as t.Statement,
        alternate: alternate
      },
      readerStartPos,
      self.tokenizer.readerEndPos()
    )
  }

  fn _maybeImportDeclaration (mut self: ref Self) t.Statement? {
    startPos := self.tokenizer.pos()

    if !self.tokenizer.lookahead(.KwImport) {
      return nil
    }

    readerStartPos := self.tokenizer.readerStartPos()
    earlySource := self._maybeLiteral()

    if earlySource != nil {
      if earlySource.isStringLiteral() {
        return Statement.create(
          t.ImportDeclaration{source: earlySource},
          readerStartPos,
          self.tokenizer.readerEndPos()
        )
      }
    }

    mut specifiers: t.ImportDeclarationSpecifier[]
    mut specifierStartPos := -1

    loop {
      if self.tokenizer.lookahead(.Eof, true) || specifierStartPos == self.tokenizer.pos() {
        if specifiers.empty {
          self.tokenizer.seek(startPos)
          return nil
        }

        self._raise(errors.E0173())
        break
      }

      specifierStartPos = self.tokenizer.pos()

      if self.tokenizer.lookahead(.OpStar) {
        if !self.tokenizer.lookahead(.KwAs) {
          if specifiers.empty {
            self.tokenizer.seek(startPos)
            return nil
          }

          self._raise(errors.E0174())
        }

        mut name := self.nextIdentifier()

        if name == nil {
          self._raise(errors.E0175())
          name = Expression.dummyIdentifier()
        }

        specifiers.push(t.ImportNamespaceSpecifier{name: name as t.Identifier})
      } else {
        mut imported := self.nextIdentifier()

        if imported == nil {
          if specifiers.empty {
            self.tokenizer.seek(startPos)
            return nil
          }

          self._raise(errors.E0139("import declaration specifier imported name"))
          imported = Expression.dummyIdentifier()
        }

        mut local := imported as t.Identifier

        if self.tokenizer.lookahead(.KwAs) {
          identifier := self.nextIdentifier()

          if identifier == nil {
            self._raise(errors.E0176())
            local = Expression.dummyIdentifier()
          } else {
            local = identifier
          }
        }

        specifiers.push(t.ImportSpecifier{imported: imported as t.Identifier, local: local})
      }

      if self.tokenizer.lookahead(.KwFrom, true) {
        break
      }

      if !self.tokenizer.lookahead(.OpComma) {
        self._raise(errors.E0106("import declaration specifier"))
      }
    }

    if !self.tokenizer.lookahead(.KwFrom) {
      self._raise(errors.E0173())
    }

    mut source := self._maybeLiteral()

    if source == nil {
      self._raise(errors.E0177())
      source = Expression.dummy()
    }

    return Statement.create(
      t.ImportDeclaration{specifiers: specifiers, source: source as t.Expression},
      readerStartPos,
      self.tokenizer.readerEndPos()
    )
  }

  fn _maybeLiteral (mut self: ref Self) t.Expression? {
    if self.tokenizer.lookahead(.KwFalse, true) || self.tokenizer.lookahead(.KwTrue, true) {
      tk := self.tokenizer.next()
      return Expression.create(t.BooleanLiteral{value: tk.val}, tk.start, tk.end)
    } elif self.tokenizer.lookahead(.KwNil, true) {
      tk := self.tokenizer.next()
      return Expression.create(t.NilLiteral{}, tk.start, tk.end)
    } elif self.tokenizer.lookahead(.LitChar, true) {
      tk := self.tokenizer.next()
      return Expression.create(t.CharacterLiteral{raw: tk.val, value: tk.val.slice(1, -1)}, tk.start, tk.end)
    } elif (
      self.tokenizer.lookahead(.LitIntBin, true) ||
      self.tokenizer.lookahead(.LitIntDec, true) ||
      self.tokenizer.lookahead(.LitIntHex, true) ||
      self.tokenizer.lookahead(.LitIntOct, true)
    ) {
      tk := self.tokenizer.next()
      return Expression.create(t.IntegerLiteral{t: Token.typeToIntegerLiteralType(tk.t), value: tk.val}, tk.start, tk.end)
    } elif self.tokenizer.lookahead(.LitFloat, true) {
      tk := self.tokenizer.next()
      return Expression.create(t.FloatingPointLiteral{value: tk.val}, tk.start, tk.end)
    } elif self.tokenizer.lookahead(.LitStr, true) {
      tk := self.tokenizer.next()
      return Expression.create(t.StringLiteral{raw: tk.val, value: tk.val.slice(1, -1)}, tk.start, tk.end)
    }

    return nil
  }

  fn _maybeLoopStatement (mut self: ref Self) t.Statement? {
    if !self.tokenizer.lookahead(.KwLoop) {
      return nil
    }

    readerStartPos := self.tokenizer.readerStartPos()
    parenthesized := self.tokenizer.lookahead(.OpLPar)
    mut initializer := self._maybeVariableDeclaration()
    mut initializerIntentionallyEmpty := false
    initializer2 := initializer
    mut condition: t.Expression?
    mut update: t.Expression?
    mut hasAllParts := false

    if initializer2 == nil {
      initializerOrCondition := self.nextExpression()

      if initializerOrCondition != nil && self.tokenizer.lookahead(.OpSemi, true) {
        initializer = Statement.create(t.ExpressionStatement{
          expression: initializerOrCondition
        }, initializerOrCondition.start, initializerOrCondition.end)
      } elif initializerOrCondition != nil {
        condition = initializerOrCondition
      } elif self.tokenizer.lookahead(.OpSemi, true) {
        initializerIntentionallyEmpty = true
      }
    } elif initializer2.isExpression() && !self.tokenizer.lookahead(.OpSemi, true) {
      initializerOrCondition := initializer2.asExpression()
      condition = initializerOrCondition.expression
      initializer = nil
    }

    if initializer != nil || initializerIntentionallyEmpty {
      if !self.tokenizer.lookahead(.OpSemi) {
        self._raise(errors.E0156())
      }

      condition = self.nextExpression()
      mut shouldContinue := true

      if !self.tokenizer.lookahead(.OpSemi) {
        initializer3 := initializer

        if !parenthesized && initializer3 != nil {
          if initializer3.isExpression() {
            expression := initializer3.asExpression()

            if Expression.endsWithObjExpr(expression.expression) {
              objectExpression := Expression.extractLastObjExpr(expression.expression)
              initializerExpression := Expression.subtractLastObjExpr(expression.expression)

              initializer = Statement.create(t.ExpressionStatement{
                expression: initializerExpression
              }, initializerExpression.start, initializerExpression.end)

              self.tokenizer.errorSeek(objectExpression.errorPosIdx)
              self.tokenizer.readerSeek(objectExpression.id.end)
              condition = nil
              shouldContinue = false
            }
          }
        }

        if shouldContinue {
          self._raise(errors.E0157())
        }
      }

      if shouldContinue {
        update = self.nextExpression()
        hasAllParts = true
      }
    }

    if parenthesized && !self.tokenizer.lookahead(.OpRPar) {
      self._raise(errors.E0155())
    }

    condition2 := condition
    update2 := update
    mut body := parenthesized ? self.nextStatement(withBlockStatement: true) : self._maybeBlockStatement()

    if (
      body == nil &&
      !parenthesized &&
      hasAllParts &&
      update2 != nil &&
      Expression.endsWithObjExpr(update as t.Expression)
    ) {
      objectExpression := Expression.extractLastObjExpr(update as t.Expression)
      update = Expression.subtractLastObjExpr(update as t.Expression)
      self.tokenizer.errorSeek(objectExpression.errorPosIdx)
      self.tokenizer.readerSeek(objectExpression.id.end)
      body = self.nextStatement(withBlockStatement: true)
    }

    if body == nil && !parenthesized && hasAllParts && update2 != nil {
      if update2.isMap() {
        self.tokenizer.readerSeek(update2.start)
        update = nil
        body = self.nextStatement(withBlockStatement: true)
      }
    }

    if (
      body == nil &&
      !parenthesized &&
      !hasAllParts &&
      condition2 != nil &&
      Expression.endsWithObjExpr(condition as t.Expression)
    ) {
      objectExpression := Expression.extractLastObjExpr(condition as t.Expression)
      condition = Expression.subtractLastObjExpr(condition as t.Expression)
      self.tokenizer.errorSeek(objectExpression.errorPosIdx)
      self.tokenizer.readerSeek(objectExpression.id.end)
      body = self.nextStatement(withBlockStatement: true)
    }

    if body == nil && !parenthesized && !hasAllParts && condition2 != nil {
      if condition2.isMap() {
        self.tokenizer.readerSeek(condition2.start)
        condition = nil
        body = self.nextStatement(withBlockStatement: true)
      }
    }

    if body == nil {
      self._raise(errors.E0158())
      body = Statement.dummy()
    }

    return Statement.create(
      t.LoopStatement{
        initializer: initializer,
        condition: condition,
        update: update,
        body: body as t.Statement,
        parenthesized: parenthesized
      },
      readerStartPos,
      self.tokenizer.readerEndPos()
    )
  }

  fn _maybeMainDeclaration (mut self: ref Self) t.Statement? {
    if !self.tokenizer.lookahead(.KwMain) {
      return nil
    }

    readerStartPos := self.tokenizer.readerStartPos()
    mut body: t.Statement?

    if self.tokenizer.lookahead(.OpLBrace, true) {
      body = self.nextStatement(withBlockStatement: true)

      if body == nil {
        self._raise(errors.E0153())
        body = Statement.dummy()
      }
    } else {
      self._raise(errors.E0100("main"))
      body = Statement.dummy()
    }

    return Statement.create(
      t.MainDeclaration{body: body as t.Statement},
      readerStartPos,
      self.tokenizer.readerEndPos()
    )
  }

  fn _maybeMapExpression (mut self: ref Self) t.Expression? {
    startPos := self.tokenizer.pos()

    if !self.tokenizer.lookahead(.OpLBrace) {
      return nil
    }

    readerStartPos := self.tokenizer.readerStartPos()
    mut elements: t.MapExpressionElement[]
    mut elementStartPos := -1

    loop !self.tokenizer.lookahead(.OpRBrace) {
      if self.tokenizer.lookahead(.Eof, true) || elementStartPos == self.tokenizer.pos() {
        if elements.empty {
          self.tokenizer.seek(startPos)
          return nil
        }

        self._raise(errors.E0117("map expression"))
        break
      }

      elementStartPos = self.tokenizer.pos()
      key := self.nextExpression(shouldWrap: false)

      if key == nil {
        if elements.empty {
          self.tokenizer.seek(startPos)
          return nil
        }

        self._raise(errors.E0118())
      } elif !self.tokenizer.lookahead(.OpColon) {
        if elements.empty {
          self.tokenizer.seek(startPos)
          return nil
        }

        self._raise(errors.E0113("map expression key"))
        elements.push(t.MapExpressionElement{key: key, value: Expression.dummy()})
      } else {
        value := self.nextExpression()

        if value == nil {
          if elements.empty {
            self.tokenizer.seek(startPos)
            return nil
          }

          self._raise(errors.E0119())
          elements.push(t.MapExpressionElement{key: key, value: Expression.dummy()})
        } else {
          elements.push(t.MapExpressionElement{key: key, value: value})
        }
      }

      if !self.tokenizer.lookahead(.OpComma) && !self.tokenizer.lookahead(.OpRBrace, true) {
        self._raise(errors.E0106("map expression element"))
      }
    }

    return Expression.create(
      t.MapExpression{elements: elements},
      readerStartPos,
      self.tokenizer.readerEndPos()
    )
  }

  fn _maybeMemberAccessExpression (mut self: ref Self) t.Expression? {
    if !self.tokenizer.lookahead(.OpDot) {
      return nil
    }

    readerStartPos := self.tokenizer.readerStartPos()
    mut name := self.nextIdentifier(allowKeywords: true)

    if name == nil {
      self._raise(errors.E0107("dot"))
      name = Expression.dummyIdentifier()
    }

    return Expression.create(
      t.MemberAccessExpression{name: name as t.Identifier},
      readerStartPos,
      self.tokenizer.readerEndPos()
    )
  }

  fn _maybeObjectDeclaration (mut self: ref Self) t.Statement? {
    if !self.tokenizer.lookahead(.KwObj) {
      return nil
    }

    readerStartPos := self.tokenizer.readerStartPos()
    mut name := self.nextIdentifier()

    if name == nil {
      self._raise(errors.E0149("obj"))
      name = Expression.dummyIdentifier()
    }

    if !self.tokenizer.lookahead(.OpLBrace) {
      self._raise(errors.E0102("object declaration name"))
    }

    mut body: t.Statement[]

    loop !self.tokenizer.lookahead(.OpRBrace) {
      if self.tokenizer.lookahead(.Eof, true) {
        self._raise(errors.E0171())
        break
      }

      statement := self.nextStatement(insideObjectDeclaration: true)

      if statement == nil {
        self._raise(errors.E0170())
        break
      }

      body.push(statement as t.Statement)
    }

    return Statement.create(
      t.ObjectDeclaration{
        name: name as t.Identifier,
        body: body
      },
      readerStartPos,
      self.tokenizer.readerEndPos()
    )
  }

  fn _maybeParenthesizedExpression (mut self: ref Self) t.Expression? {
    if !self.tokenizer.lookahead(.OpLPar) {
      return nil
    }

    readerStartPos := self.tokenizer.readerStartPos()
    mut expression := self.nextExpression()

    if expression == nil {
      self._raise(errors.E0107("left parenthesis"))
      expression = Expression.dummy()
    }

    if !self.tokenizer.lookahead(.OpRPar) {
      self._raise(errors.E0103("parenthesized expression"))
    }

    return Expression.create(
      t.ParenthesizedExpression{expression: expression as t.Expression},
      readerStartPos,
      self.tokenizer.readerEndPos()
    )
  }

  fn _maybeReferenceExpression (mut self: ref Self) t.Expression? {
    if !self.tokenizer.lookahead(.KwRef) {
      return nil
    }

    readerStartPos := self.tokenizer.readerStartPos()
    mut expression := self.nextExpression()

    if expression == nil {
      self._raise(errors.E0109("ref"))
      expression = Expression.dummy()
    }

    return Expression.create(
      t.ReferenceExpression{expression: expression as t.Expression},
      readerStartPos,
      self.tokenizer.readerEndPos()
    )
  }

  fn _maybeReferenceType (mut self: ref Self) t.Type? {
    if !self.tokenizer.lookahead(.KwRef) {
      return nil
    }

    readerStartPos := self.tokenizer.readerStartPos()
    mut referencedType := self.nextType()

    if referencedType == nil {
      self._raise(errors.E0123("ref"))
      referencedType = Type.dummy()
    }

    return Type.create(
      t.ReferenceType{t: referencedType as t.Type},
      readerStartPos,
      self.tokenizer.readerEndPos()
    )
  }

  fn _maybeReturnStatement (mut self: ref Self) t.Statement? {
    if !self.tokenizer.lookahead(.KwReturn) {
      return nil
    }

    readerStartPos := self.tokenizer.readerStartPos()
    expression := self.nextExpression()

    return Statement.create(
      t.ReturnStatement{expression: expression},
      readerStartPos,
      self.tokenizer.readerEndPos()
    )
  }

  fn _maybeThrowStatement (mut self: ref Self) t.Statement? {
    if !self.tokenizer.lookahead(.KwThrow) {
      return nil
    }

    readerStartPos := self.tokenizer.readerStartPos()
    mut expression := self.nextExpression()

    if expression == nil {
      self._raise(errors.E0109("throw"))
      expression = Expression.dummy()
    }

    return Statement.create(
      t.ThrowStatement{expression: expression as t.Expression},
      readerStartPos,
      self.tokenizer.readerEndPos()
    )
  }

  fn _maybeTryStatement (mut self: ref Self) t.Statement? {
    if !self.tokenizer.lookahead(.KwTry) {
      return nil
    }

    readerStartPos := self.tokenizer.readerStartPos()
    mut body := self.nextStatement(withBlockStatement: true)

    if body == nil {
      self._raise(errors.E0159())
      body = Statement.dummy()
    }

    mut handlers: t.TryStatementHandler[]

    loop self.tokenizer.lookahead(.KwCatch) {
      mut handlerParameter := self._maybeVariableDeclaration()

      if handlerParameter == nil {
        self._raise(errors.E0161())
        handlerParameter = Statement.dummy()
      }

      mut handlerBody := self.nextStatement(withBlockStatement: true)

      if handlerBody == nil {
        self._raise(errors.E0162())
        handlerBody = Statement.dummy()
      }

      handlers.push(t.TryStatementHandler{
        parameter: handlerParameter as t.Statement,
        body: handlerBody as t.Statement
      })
    }

    if handlers.empty {
      self._raise(errors.E0160())
    }

    return Statement.create(
      t.TryStatement{
        body: body as t.Statement,
        handlers: handlers
      },
      readerStartPos,
      self.tokenizer.readerEndPos()
    )
  }

  fn _maybeTypeAliasDeclaration (mut self: ref Self) t.Statement? {
    if !self.tokenizer.lookahead(.KwType) {
      return nil
    }

    readerStartPos := self.tokenizer.readerStartPos()
    mut name := self.nextIdentifier()

    if name == nil {
      self._raise(errors.E0149("type"))
      name = Expression.dummyIdentifier()
    }

    if !self.tokenizer.lookahead(.OpEq) {
      self._raise(errors.E0154())
    }

    mut aliasType := self.nextType()

    if aliasType == nil {
      self._raise(errors.E0138("equals sign"))
      aliasType = Type.dummy()
    }

    return Statement.create(
      t.TypeAliasDeclaration{name: name as t.Identifier, t: aliasType as t.Type},
      readerStartPos,
      self.tokenizer.readerEndPos()
    )
  }

  fn _maybeUnaryExpression (mut self: ref Self) t.Expression? {
    if (
      !self.tokenizer.lookahead(.OpExcl, true) &&
      !self.tokenizer.lookahead(.OpMinus, true) &&
      !self.tokenizer.lookahead(.OpMinusMinus, true) &&
      !self.tokenizer.lookahead(.OpPlus, true) &&
      !self.tokenizer.lookahead(.OpPlusPlus, true) &&
      !self.tokenizer.lookahead(.OpTilde, true)
    ) {
      return nil
    }

    tk := self.tokenizer.next()
    mut operand := self.nextExpression(shouldWrap: false)

    if operand == nil {
      self._raise(errors.E0122())
      operand = Expression.dummy()
    }

    return Expression.create(
      t.UnaryExpression{operator: tk, operand: operand as t.Expression, prefix: true},
      tk.start,
      self.tokenizer.readerEndPos()
    )
  }

  fn _maybeVariableDeclaration (mut self: ref Self, insideObjectDeclaration := false) t.Statement? {
    startPos := self.tokenizer.pos()

    if (
      !self.tokenizer.lookahead(.KwConst, true) &&
      !self.tokenizer.lookahead(.KwMut, true) &&
      !self.tokenizer.lookahead(.Id, true)
    ) {
      return nil
    }

    readerStartPos := self.tokenizer.readerStartPos(offset: 1)
    mut name: t.Identifier
    mut constant := false
    mut mutable := false

    if self.tokenizer.lookahead(.KwConst) {
      constant = true
      possibleName := self.nextIdentifier(allowKeywords: insideObjectDeclaration)

      if possibleName == nil {
        self._raise(errors.E0131("const"))
      } else {
        name = possibleName
      }
    } elif self.tokenizer.lookahead(.KwMut) {
      mutable = true
      possibleName := self.nextIdentifier(allowKeywords: insideObjectDeclaration)

      if possibleName == nil {
        self._raise(errors.E0131("mut"))
      } else {
        name = possibleName
      }
    } else {
      possibleName := self.nextIdentifier(allowKeywords: insideObjectDeclaration)
      name = possibleName as t.Identifier

      if !self.tokenizer.lookahead(.OpColon, true) && !self.tokenizer.lookahead(.OpColonEq, true) {
        self.tokenizer.seek(startPos)
        return nil
      }
    }

    mut variableType: t.Type?
    mut initializer: t.Expression?

    if self.tokenizer.lookahead(.OpColon) {
      variableType = self.nextType()

      if variableType == nil {
        self._raise(errors.E0133())
        variableType = Type.dummy()
      }

      if self.tokenizer.lookahead(.OpEq) {
        initializer = self.nextExpression()

        if initializer == nil {
          self._raise(errors.E0134("equals sign"))
          initializer = Expression.dummy()
        }
      }
    } elif self.tokenizer.lookahead(.OpColonEq) {
      initializer = self.nextExpression()

      if initializer == nil {
        self._raise(errors.E0134("colon equals sign"))
        initializer = Expression.dummy()
      }
    } else {
      self._raise(errors.E0132())
    }

    if insideObjectDeclaration {
      return Statement.create(
        t.ObjectDeclarationProperty{
          name: name,
          t: variableType,
          initializer: initializer,
          mutable: mutable,
          constant: constant
        },
        readerStartPos,
        self.tokenizer.readerEndPos()
      )
    } else {
      return Statement.create(
        t.VariableDeclaration{
          name: name,
          t: variableType,
          initializer: initializer,
          mutable: mutable,
          constant: constant
        },
        readerStartPos,
        self.tokenizer.readerEndPos()
      )
    }
  }

  fn _maybeWrapArrayOrMapType (mut self: ref Self, typeToWrap: t.Type) t.Type? {
    if !self.tokenizer.lookahead(.OpLBrack) {
      return nil
    }

    if self.tokenizer.lookahead(.OpRBrack) {
      return Type.create(
        t.ArrayType{elementType: typeToWrap},
        typeToWrap.start,
        self.tokenizer.readerEndPos()
      )
    }

    mut valueType := self.nextType()

    if valueType == nil {
      self._raise(errors.E0136())
      valueType = Type.dummy()
    }

    if !self.tokenizer.lookahead(.OpRBrack) {
      self._raise(errors.E0115("map type value type"))
    }

    return Type.create(
      t.MapType{keyType: typeToWrap, valueType: valueType as t.Type},
      typeToWrap.start,
      self.tokenizer.readerEndPos()
    )
  }

  fn _maybeWrapMemberType (mut self: ref Self, typeToWrap: t.Type) t.Type? {
    if !self.tokenizer.lookahead(.OpDot) {
      return nil
    }

    mut name := self.nextIdentifier()

    if name == nil {
      self._raise(errors.E0135())
      name = Expression.dummyIdentifier()
    }

    return Type.create(
      t.MemberType{t: typeToWrap, name: name as t.Identifier},
      typeToWrap.start,
      self.tokenizer.readerEndPos()
    )
  }

  fn _maybeWrapOptionalType (mut self: ref Self, typeToWrap: t.Type) t.Type? {
    if !self.tokenizer.lookahead(.OpQn) {
      return nil
    }

    return Type.create(
      t.OptionalType{t: typeToWrap},
      typeToWrap.start,
      self.tokenizer.readerEndPos()
    )
  }

  fn _maybeWrapUnionType (mut self: ref Self, typeToWrap: t.Type) t.Type? {
    if !self.tokenizer.lookahead(.OpPipe, true) {
      return nil
    }

    mut types := [typeToWrap]

    loop self.tokenizer.lookahead(.OpPipe) {
      mut subType := self.nextType(withoutUnion: true)

      if subType == nil {
        self._raise(errors.E0137())
        subType = Type.dummy()
      }

      types.push(subType as t.Type)
    }

    return Type.create(
      t.UnionType{types: types},
      typeToWrap.start,
      self.tokenizer.readerEndPos()
    )
  }

  fn _precedence (
    mut self: ref Self,
    expression: t.Expression,
    startPos: int,
    tk: t.Token,
    wrapper: ParserExpressionWrapper
  ) ParserWrapOutput {
    if expression.isAssignment() {
      e := expression.asAssignment()

      shouldWrapExpression := Token.precedence(e.operator.t) == Token.precedence(tk.t)
        ? Token.associativity(e.operator.t) == .Right
        : Token.precedence(e.operator.t) < Token.precedence(tk.t)

      if shouldWrapExpression {
        wrapOutput := self._precedence(e.right, startPos, tk, wrapper)

        return ParserWrapOutput{
          expression: Expression.create(
            t.AssignmentExpression{left: e.left, operator: e.operator, right: wrapOutput.expression},
            expression.start,
            wrapOutput.expression.end
          ),
          shouldWrap: wrapOutput.shouldWrap
        }
      }
    } elif expression.isAwait() {
      e := expression.asAwait()

      if Token.precedence(.KwAwait) < Token.precedence(tk.t) {
        wrapOutput := self._precedence(e.expression, startPos, tk, wrapper)

        return ParserWrapOutput{
          expression: Expression.create(
            t.AwaitExpression{expression: wrapOutput.expression},
            expression.start,
            wrapOutput.expression.end
          ),
          shouldWrap: wrapOutput.shouldWrap
        }
      }
    } elif expression.isBinary() {
      e := expression.asBinary()

      shouldWrapExpression := Token.precedence(e.operator.t) == Token.precedence(tk.t)
        ? Token.associativity(e.operator.t) == .Right
        : Token.precedence(e.operator.t) < Token.precedence(tk.t)

      if shouldWrapExpression {
        wrapOutput := self._precedence(e.right, startPos, tk, wrapper)

        return ParserWrapOutput{
          expression: Expression.create(
            t.BinaryExpression{left: e.left, operator: e.operator, right: wrapOutput.expression},
            expression.start,
            wrapOutput.expression.end
          ),
          shouldWrap: wrapOutput.shouldWrap
        }
      }
    } elif expression.isConditional() {
      e := expression.asConditional()

      if Token.precedence(.OpQn) <= Token.precedence(tk.t) {
        wrapOutput := self._precedence(e.alternate, startPos, tk, wrapper)

        return ParserWrapOutput{
          expression: Expression.create(
            t.ConditionalExpression{condition: e.condition, consequent: e.consequent, alternate: wrapOutput.expression},
            expression.start,
            wrapOutput.expression.end
          ),
          shouldWrap: wrapOutput.shouldWrap
        }
      }
    } elif expression.isReference() {
      e := expression.asReference()

      if Token.precedence(.KwRef) < Token.precedence(tk.t) {
        wrapOutput := self._precedence(e.expression, startPos, tk, wrapper)

        return ParserWrapOutput{
          expression: Expression.create(
            t.ReferenceExpression{expression: wrapOutput.expression},
            expression.start,
            wrapOutput.expression.end
          ),
          shouldWrap: wrapOutput.shouldWrap
        }
      }
    } elif expression.isUnary() {
      e := expression.asUnary()

      if e.prefix && Token.precedence(e.operator.t, true) < Token.precedence(tk.t, true) {
        wrapOutput := self._precedence(e.operand, startPos, tk, wrapper)

        return ParserWrapOutput{
          expression: Expression.create(
            t.UnaryExpression{operator: e.operator, operand: wrapOutput.expression, prefix: e.prefix},
            expression.start,
            wrapOutput.expression.end
          ),
          shouldWrap: wrapOutput.shouldWrap
        }
      }
    }

    if wrapper == .As { return self._wrapAsExpression(expression, startPos, tk) }
    elif wrapper == .Assignment { return self._wrapAssignmentExpression(expression, startPos, tk) }
    elif wrapper == .Binary { return self._wrapBinaryExpression(expression, startPos, tk) }
    elif wrapper == .Call { return self._wrapCallExpression(expression, startPos, tk) }
    elif wrapper == .Conditional { return self._wrapConditionalExpression(expression, startPos, tk) }
    elif wrapper == .ElementAccess { return self._wrapElementAccessExpression(expression, startPos, tk) }
    elif wrapper == .Is { return self._wrapIsExpression(expression, startPos, tk) }
    elif wrapper == .Object { return self._wrapObjectExpression(expression, startPos, tk) }
    elif wrapper == .PropertyAccess { return self._wrapPropertyAccessExpression(expression, startPos, tk) }
    elif wrapper == .Unary { return self._wrapUnaryExpression(expression, startPos, tk) }
    else { return ParserWrapOutput{expression: expression, shouldWrap: true} }
  }

  fn _raise (
    mut self: ref Self,
    message: str,
    start := self.tokenizer.readerEndPos(),
    end := self.tokenizer.readerEndPos()
  ) {
    self.tokenizer._raiseException("ParseError", message, start, end)
  }

  fn _wrapAsExpression (mut self: ref Self, expression: t.Expression, startPos: int, tk: t.Token) ParserWrapOutput {
    mut asType := self.nextType()

    if asType == nil {
      self._raise(errors.E0123("as"))
      asType = Type.dummy()
    }

    return ParserWrapOutput{
      expression: Expression.create(
        t.AsExpression{expression: expression, t: asType as t.Type},
        expression.start,
        self.tokenizer.readerEndPos()
      ),
      shouldWrap: true
    }
  }

  fn _wrapAssignmentExpression (mut self: ref Self, expression: t.Expression, startPos: int, tk: t.Token) ParserWrapOutput {
    mut right := self.nextExpression(shouldWrap: false)

    if right == nil {
      self._raise(errors.E0111(tk.val))
      right = Expression.dummy()
    }

    return ParserWrapOutput{
      expression: Expression.create(
        t.AssignmentExpression{left: expression, operator: tk, right: right as t.Expression},
        expression.start,
        self.tokenizer.readerEndPos()
      ),
      shouldWrap: true
    }
  }

  fn _wrapBinaryExpression (mut self: ref Self, expression: t.Expression, startPos: int, tk: t.Token) ParserWrapOutput {
    mut right := self.nextExpression(shouldWrap: false)

    if right == nil {
      self._raise(errors.E0111(tk.val))
      right = Expression.dummy()
    }

    return ParserWrapOutput{
      expression: Expression.create(
        t.BinaryExpression{left: expression, operator: tk, right: right as t.Expression},
        expression.start,
        self.tokenizer.readerEndPos()
      ),
      shouldWrap: true
    }
  }

  fn _wrapCallExpression (mut self: ref Self, expression: t.Expression, startPos: int, tk: t.Token) ParserWrapOutput {
    mut arguments: t.CallExpressionArgument[]
    mut argumentStartPos := -1

    loop !self.tokenizer.lookahead(.OpRPar) {
      if self.tokenizer.lookahead(.Eof, true) || argumentStartPos == self.tokenizer.pos() {
        self._raise(errors.E0103("call expression opening brace"))
        break
      }

      argumentStartPos = self.tokenizer.pos()
      name := self.nextIdentifier(allowKeywords: true)

      if name == nil {
        expression := self.nextExpression()

        if expression == nil {
          self._raise(errors.E0105())
        } else {
          arguments.push(t.CallExpressionArgument{expression: expression})
        }
      } else {
        if self.tokenizer.lookahead(.OpColon) {
          expression := self.nextExpression()

          if expression == nil {
            self._raise(errors.E0107("call expression named argument"))
            arguments.push(t.CallExpressionArgument{name: name, expression: Expression.dummy()})
          } else {
            arguments.push(t.CallExpressionArgument{name: name, expression: expression})
          }
        } else {
          self.tokenizer.seek(argumentStartPos)
          expression := self.nextExpression()

          if expression == nil {
            self._raise(errors.E0105())
          } else {
            arguments.push(t.CallExpressionArgument{expression: expression})
          }
        }
      }

      if !self.tokenizer.lookahead(.OpComma) && !self.tokenizer.lookahead(.OpRPar, true) {
        self._raise(errors.E0106("call expression argument"))
      }
    }

    return ParserWrapOutput{
      expression: Expression.create(
        t.CallExpression{callee: expression, arguments: arguments},
        expression.start,
        self.tokenizer.readerEndPos()
      ),
      shouldWrap: true
    }
  }

  fn _wrapConditionalExpression (mut self: ref Self, expression: t.Expression, startPos: int, tk: t.Token) ParserWrapOutput {
    mut consequent := self.nextExpression()

    if consequent == nil {
      self._raise(errors.E0112())
      consequent = Expression.dummy()
    }

    if !self.tokenizer.lookahead(.OpColon) {
      self._raise(errors.E0113("conditional expression consequent"))
    }

    mut alternate := self.nextExpression(shouldWrap: false)

    if alternate == nil {
      self._raise(errors.E0110())
      alternate = Expression.dummy()
    }

    return ParserWrapOutput{
      expression: Expression.create(
        t.ConditionalExpression{
          condition: expression,
          consequent: consequent as t.Expression,
          alternate: alternate as t.Expression
        },
        expression.start,
        self.tokenizer.readerEndPos()
      ),
      shouldWrap: true
    }
  }

  fn _wrapElementAccessExpression (mut self: ref Self, expression: t.Expression, startPos: int, tk: t.Token) ParserWrapOutput {
    mut argument := self.nextExpression()

    if argument == nil {
      self._raise(errors.E0114())
      argument = Expression.dummy()
    }

    if !self.tokenizer.lookahead(.OpRBrack) {
      self._raise(errors.E0115("element access expression argument"))
    }

    return ParserWrapOutput{
      expression: Expression.create(
        t.ElementAccessExpression{expression: expression, argument: argument as t.Expression},
        expression.start,
        self.tokenizer.readerEndPos()
      ),
      shouldWrap: true
    }
  }

  fn _wrapExpression (mut self: ref Self, mut e: t.Expression) t.Expression {
    startPos := self.tokenizer.pos()

    if self.tokenizer.lookahead(.KwAs, true) {
      tk := self.tokenizer.next()
      mut wrapOutput := self._precedence(e, startPos, tk, .As)
      wrapOutput.expression.trailingComments = self.comments()
      return wrapOutput.shouldWrap ? self._wrapExpression(wrapOutput.expression) : wrapOutput.expression
    } elif (
      self.tokenizer.lookahead(.OpAmpEq, true) ||
      self.tokenizer.lookahead(.OpAmpAmpEq, true) ||
      self.tokenizer.lookahead(.OpCaretEq, true) ||
      self.tokenizer.lookahead(.OpEq, true) ||
      self.tokenizer.lookahead(.OpLShiftEq, true) ||
      self.tokenizer.lookahead(.OpMinusEq, true) ||
      self.tokenizer.lookahead(.OpPercentEq, true) ||
      self.tokenizer.lookahead(.OpPipeEq, true) ||
      self.tokenizer.lookahead(.OpPipePipeEq, true) ||
      self.tokenizer.lookahead(.OpPlusEq, true) ||
      self.tokenizer.lookahead(.OpRShiftEq, true) ||
      self.tokenizer.lookahead(.OpSlashEq, true) ||
      self.tokenizer.lookahead(.OpStarEq, true)
    ) {
      tk := self.tokenizer.next()
      mut wrapOutput := self._precedence(e, startPos, tk, .Assignment)
      wrapOutput.expression.trailingComments = self.comments()
      return wrapOutput.shouldWrap ? self._wrapExpression(wrapOutput.expression) : wrapOutput.expression
    } elif (
      self.tokenizer.lookahead(.OpAmp, true) ||
      self.tokenizer.lookahead(.OpAmpAmp, true) ||
      self.tokenizer.lookahead(.OpCaret, true) ||
      self.tokenizer.lookahead(.OpEqEq, true) ||
      self.tokenizer.lookahead(.OpExclEq, true) ||
      self.tokenizer.lookahead(.OpGt, true) ||
      self.tokenizer.lookahead(.OpGtEq, true) ||
      self.tokenizer.lookahead(.OpLShift, true) ||
      self.tokenizer.lookahead(.OpLt, true) ||
      self.tokenizer.lookahead(.OpLtEq, true) ||
      self.tokenizer.lookahead(.OpMinus, true) ||
      self.tokenizer.lookahead(.OpPercent, true) ||
      self.tokenizer.lookahead(.OpPipe, true) ||
      self.tokenizer.lookahead(.OpPipePipe, true) ||
      self.tokenizer.lookahead(.OpPlus, true) ||
      self.tokenizer.lookahead(.OpRShift, true) ||
      self.tokenizer.lookahead(.OpSlash, true) ||
      self.tokenizer.lookahead(.OpStar, true)
    ) {
      tk := self.tokenizer.next()
      mut wrapOutput := self._precedence(e, startPos, tk, .Binary)
      wrapOutput.expression.trailingComments = self.comments()
      return wrapOutput.shouldWrap ? self._wrapExpression(wrapOutput.expression) : wrapOutput.expression
    } elif self.tokenizer.lookahead(.OpLPar, true) {
      tk := self.tokenizer.next()
      mut wrapOutput := self._precedence(e, startPos, tk, .Call)
      wrapOutput.expression.trailingComments = self.comments()
      return wrapOutput.shouldWrap ? self._wrapExpression(wrapOutput.expression) : wrapOutput.expression
    } elif self.tokenizer.lookahead(.OpQn, true) {
      tk := self.tokenizer.next()
      mut wrapOutput := self._precedence(e, startPos, tk, .Conditional)
      wrapOutput.expression.trailingComments = self.comments()
      return wrapOutput.shouldWrap ? self._wrapExpression(wrapOutput.expression) : wrapOutput.expression
    } elif self.tokenizer.lookahead(.OpLBrack, true) {
      tk := self.tokenizer.next()
      mut wrapOutput := self._precedence(e, startPos, tk, .ElementAccess)
      wrapOutput.expression.trailingComments = self.comments()
      return wrapOutput.shouldWrap ? self._wrapExpression(wrapOutput.expression) : wrapOutput.expression
    } elif self.tokenizer.lookahead(.KwIs, true) {
      tk := self.tokenizer.next()
      mut wrapOutput := self._precedence(e, startPos, tk, .Is)
      wrapOutput.expression.trailingComments = self.comments()
      return wrapOutput.shouldWrap ? self._wrapExpression(wrapOutput.expression) : wrapOutput.expression
    } elif self.tokenizer.lookahead(.OpLBrace, true) {
      tk := self.tokenizer.next()
      mut wrapOutput := self._precedence(e, startPos, tk, .Object)
      wrapOutput.expression.trailingComments = self.comments()
      return wrapOutput.shouldWrap ? self._wrapExpression(wrapOutput.expression) : wrapOutput.expression
    } elif self.tokenizer.lookahead(.OpDot, true) {
      tk := self.tokenizer.next()
      mut wrapOutput := self._precedence(e, startPos, tk, .PropertyAccess)
      wrapOutput.expression.trailingComments = self.comments()
      return wrapOutput.shouldWrap ? self._wrapExpression(wrapOutput.expression) : wrapOutput.expression
    } elif self.tokenizer.lookahead(.OpMinusMinus, true) || self.tokenizer.lookahead(.OpPlusPlus, true) {
      tk := self.tokenizer.next()
      mut wrapOutput := self._precedence(e, startPos, tk, .Unary)
      wrapOutput.expression.trailingComments = self.comments()
      return wrapOutput.shouldWrap ? self._wrapExpression(wrapOutput.expression) : wrapOutput.expression
    }

    e.trailingComments = self.comments()
    return e
  }

  fn _wrapIsExpression (mut self: ref Self, expression: t.Expression, startPos: int, tk: t.Token) ParserWrapOutput {
    mut isType := self.nextType()

    if isType == nil {
      self._raise(errors.E0123("is"))
      isType = Type.dummy()
    }

    return ParserWrapOutput{
      expression: Expression.create(
        t.IsExpression{expression: expression, t: isType as t.Type},
        expression.start,
        self.tokenizer.readerEndPos()
      ),
      shouldWrap: true
    }
  }

  fn _wrapObjectExpression (mut self: ref Self, expression: t.Expression, startPos: int, tk: t.Token) ParserWrapOutput {
    errorPosIdx := self.tokenizer.errors.empty ? -1 : self.tokenizer.errors.len - 1

    if !Expression.validObjExprId(expression) {
      self.tokenizer.seek(startPos)
      return ParserWrapOutput{expression: expression, shouldWrap: false}
    }

    mut properties: t.ObjectExpressionProperty[]
    mut propertyStartPos := -1

    loop !self.tokenizer.lookahead(.OpRBrace) {
      if self.tokenizer.lookahead(.Eof, true) || propertyStartPos == self.tokenizer.pos() {
        if properties.empty {
          self.tokenizer.seek(startPos)
          return ParserWrapOutput{expression: expression, shouldWrap: false}
        }

        self._raise(errors.E0117("object expression"))
        break
      }

      propertyStartPos = self.tokenizer.pos()
      name := self.nextIdentifier(allowKeywords: true)

      if name == nil {
        if properties.empty {
          self.tokenizer.seek(startPos)
          return ParserWrapOutput{expression: expression, shouldWrap: false}
        }

        self._raise(errors.E0120())
      } else {
        if !self.tokenizer.lookahead(.OpColon) {
          if properties.empty {
            self.tokenizer.seek(startPos)
            return ParserWrapOutput{expression: expression, shouldWrap: false}
          }

          self._raise(errors.E0113("object expression property name"))
          properties.push(t.ObjectExpressionProperty{name: name, value: Expression.dummy()})
        } else {
          value := self.nextExpression()

          if value == nil {
            if properties.empty {
              self.tokenizer.seek(startPos)
              return ParserWrapOutput{expression: expression, shouldWrap: false}
            }

            self._raise(errors.E0121())
            properties.push(t.ObjectExpressionProperty{name: name, value: Expression.dummy()})
          } else {
            properties.push(t.ObjectExpressionProperty{name: name, value: value})
          }
        }
      }

      if !self.tokenizer.lookahead(.OpComma) && !self.tokenizer.lookahead(.OpRBrace, true) {
        self._raise(errors.E0106("object expression property value"))
      }
    }

    return ParserWrapOutput{
      expression: Expression.create(
        t.ObjectExpression{id: Expression.toType(expression), properties: properties, errorPosIdx: errorPosIdx},
        expression.start,
        self.tokenizer.readerEndPos()
      ),
      shouldWrap: true
    }
  }

  fn _wrapPropertyAccessExpression (mut self: ref Self, expression: t.Expression, startPos: int, tk: t.Token) ParserWrapOutput {
    mut name := self.nextIdentifier(allowKeywords: true)

    if name == nil {
      self._raise(errors.E0107("dot"))
      name = Expression.dummyIdentifier()
    }

    return ParserWrapOutput{
      expression: Expression.create(
        t.PropertyAccessExpression{expression: expression, name: name as t.Identifier},
        expression.start,
        self.tokenizer.readerEndPos()
      ),
      shouldWrap: true
    }
  }

  fn _wrapUnaryExpression (mut self: ref Self, expression: t.Expression, startPos: int, tk: t.Token) ParserWrapOutput {
    return ParserWrapOutput{
      expression: Expression.create(
        t.UnaryExpression{operator: tk, operand: expression, prefix: false},
        expression.start,
        self.tokenizer.readerEndPos()
      ),
      shouldWrap: true
    }
  }

  fn _wrapStatement (mut self: ref Self, mut statement: t.Statement) t.Statement {
    if self.tokenizer.lookahead(.OpSemi) {
      statement.end = self.tokenizer.readerEndPos()
      statement.trailingComments = self.comments()
      return statement
    }

    return statement
  }

  fn _wrapType (mut self: ref Self, typeToWrap: t.Type, withoutUnion: bool) t.Type {
    mut result: t.Type?

    if (
      (result = self._maybeWrapArrayOrMapType(typeToWrap)) != nil ||
      (result = self._maybeWrapMemberType(typeToWrap)) != nil ||
      (result = self._maybeWrapOptionalType(typeToWrap)) != nil ||
      (!withoutUnion && (result = self._maybeWrapUnionType(typeToWrap)) != nil)
    ) {
      result.trailingComments = self.comments()
      return self._wrapType(result, withoutUnion)
    }

    return typeToWrap
  }
}

export fn init (mut tokenizer: ref Tokenizer) Parser {
  return Parser{tokenizer: tokenizer}
}

export fn parse (path: str) t.File {
  mut reader := Reader.init(path)
  mut tokenizer := Tokenizer.init(ref reader)
  mut parser := init(ref tokenizer)

  mut f := t.File{
    path: reader.path,
    program: t.Program{
      eof: Statement.dummy()
    }
  }

  loop {
    statement := parser.next()

    if statement.isEof() {
      f.program.eof = statement
      break
    }

    f.program.body.push(statement)
  }

  f.errors = parser.tokenizer.errors
  f.hasErrors = !f.errors.empty

  return f
}

export fn report (file: ref t.File) {
  if !file.hasErrors { return }

  loop i := 0; i < file.errors.len; i++ {
    print((i == 0 ? "" : os_EOL) + (file.errors[i] as str), to: "stderr")
  }
}

export fn stringify (file: ref t.File) str {
  mut result := "Program" + os_EOL

  loop i := 0; i < file.program.body.len; i++ {
    result += Statement_toText(file.program.body[i], 2)
  }

  result += Statement_toText(file.program.eof, 2)
  return result
}
