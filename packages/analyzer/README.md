# the/analyzer
The programming language analyzer

## Installation

```bash
the install the/analyzer
```

## Example usage

```the
import analyzer from "the/analyzer"
```

## API

### `analyze (mut f: ref Parser.File) str[]`
Analyzes and generates errors for parsed file. Also, assigned context on all possible nodes.

**Parameters**

- `f` - file parser by Parser

**Return value**

Errors generated by analyzer.

**Examples**

```the
mut f := Parser.parse("path/to/file")
error := analyze(ref f)
```

### `canPromote (a: ref Type, b: ref Type) bool`
Checks whether it's possible to promote type A to type B.

**Parameters**

- `a` - type to promote
- `b` - type to promote to

**Return value**

Whether it's possible to promote type A to type B.

**Examples**

```the
tm := TypeMap{}
canPromote(tm.get("int"), tm.get("i64"))
```

### `contextInitial (it: ref Parser.Expression) ref Type`
Returns initial type of expression context.

**Parameters**

- `it` - expression to return initial type for

**Return value**

Initial type of expression context.

**Examples**

```the
initialType := contextInitial(ref expression)
```

**Exceptions**

- `Error` - thrown for expression that has no context

### `contextSet (mut it: ref Parser.Expression, initialType: ref Type) void`
Creates expression context and sets initial type.

**Parameters**

- `it` - expression to create context and set initial type for
- `initialType` - initial type of the expression context

**Return value**

none

**Examples**

```the
tm := TypeMap{}
contextSet(ref expression, tm.get("int"))
```

### `contextSetExtra (mut it: ref Parser.Expression, extra: any) void`
Sets extra field on expression context.

**Parameters**

- `it` - expression to set context extra field for
- `extra` - data to be stored in extra field

**Return value**

none

**Examples**

```the
contextSetExtra(ref expression, Extra{})
```

**Exceptions**

- `Error` - thrown for expression that has no context

### `contextSetTarget (mut it: ref Parser.Expression, targetType: ref Type) void`
Sets target type on expression context.

**Parameters**

- `it` - expression to set context target type for
- `targetType` - target type of the expression context

**Return value**

none

**Examples**

```the
tm := TypeMap{}
contextSetTarget(ref expression, tm.get("int"))
```

**Exceptions**

- `Error` - thrown for expression that has no context

### `contextTarget (it: ref Parser.Expression) ref Type`
Returns target type or, if not set, initial type of expression context.

**Parameters**

- `it` - expression to return target type for

**Return value**

Target type of expression context.

**Examples**

```the
targetType := contextTarget(ref expression)
```

**Exceptions**

- `Error` - thrown for expression that has no context

### `contextTryTarget (mut it: ref Parser.Expression, targetType: ref Type) void`
Sets target type on expression context if initial type can promote to it.

**Parameters**

- `it` - expression to set context target type for
- `targetType` - target type of the expression context

**Return value**

none

**Examples**

```the
tm := TypeMap{}
contextTryTarget(ref expression, tm.get("int"))
```

**Exceptions**

- `Error` - thrown for expression that has no context

### `match (type1: ref Type, type2: ref Type) bool`
Check whether one type strictly matches another.

**Parameters**

- `type1` - first type to check
- `type2` - second type to check

**Return value**

Whether one type strictly matches another.

**Examples**

```the
tm := TypeMap{}
result := match(tm.get("int"), tm.get("i8"))
```

### `promote (a: ref Type, b: ref Type) ref Type`
Finds whether it's possible to promote type A to B or vice-versa, otherwise throws error.

**Parameters**

- `a` - first type to check
- `b` - second type to check

**Return value**

Promoted type A to B or vice-versa.

**Examples**

```the
tm := TypeMap{}
type := promote(tm.get("int"), tm.get("i64"))
```

**Exceptions**

- `Error` - thrown when unable to promote types

### `promoteMaybe (a: ref Type, b: ref Type) ref Type`
Finds whether it's possible to promote type A to B or vice-versa, otherwise return type A.

**Parameters**

- `a` - first type to check
- `b` - second type to check

**Return value**

Promoted type A to B or vice-versa.

**Examples**

```the
tm := TypeMap{}
type := promoteMaybe(tm.get("int"), tm.get("i64"))
```

### `similarTo (typeToCompare: ref Type, similarToType: ref Type) bool`
Check whether one type is similar another.

**Parameters**

- `typeToCompare` - type to compare from
- `similarToType` - type to compare to

**Return value**

Whether one type is similar another.

**Examples**

```the
tm := TypeMap{}
result := similarTo(tm.get("i8"), tm.get("int"))
```

### `stringifyTC (tc: (ref Type)[str]) str`
Generates string representation of type cast.

**Parameters**

- `tc` - type cast to generate string representation for

**Return value**

String representation of type cast.

**Examples**

```the
tm := TypeMap{}
result := stringifyTC({ "var": tm.get("int") })
```

### `unwrap (t: ref Type, withOptional := false, withReference := true) ref Type`
Recursively unwraps alias type and returns underlying type.

**Parameters**

- `t` - type to unwrap
- `withOptional` - whether to treat optional type as type to unwrap. Defaults to `false`
- `withReference` - whether to treat reference type as type to unwrap. Defaults to `true`

**Return value**

Underlying type of type to unwrap.

**Examples**

```the
tm := TypeMap{}
t := unwrap(tm.get("int"))
```

### `AnalyzerExport.get (mut exports: ref NamespaceMember[], name: str) ref NamespaceMember`
Goes through exports and finds export with matching name.

**Parameters**

- `exports` - exports to go through
- `name` - name to search for

**Return value**

Found export with matching name.

**Exceptions**

- `Error` - throw if export you are looking for doesn't exist.

**Examples**

```the
exportItem := AnalyzerExport.get(ref exports, "name")
```

### `AnalyzerExport.has (exports: ref NamespaceMember[], name: str) bool`
Checks whether export with matching name exists in passed exports.

**Parameters**

- `exports` - exports to go through
- `name` - name to search for

**Return value**

Whether export with matching name exists in passed exports.

**Examples**

```the
result := AnalyzerExport.has(ref exports, "name")
```

### `Type.asAlias () ref AliasType`
### `Type.asArray () ref ArrayType`
### `Type.asEnum () ref EnumType`
### `Type.asFunction () ref FunctionType`
### `Type.asMap () ref MapType`
### `Type.asMethod () ref MethodType`
### `Type.asNamespace () ref NamespaceType`
### `Type.asObject () ref ObjectType`
### `Type.asOptional () ref OptionalType`
### `Type.asReference () ref ReferenceType`
### `Type.asUnion () ref UnionType`
These methods are shortcuts for `as` expression.

**Return value**

Body cast to corresponding body type.

**Examples**

```the
type.asAlias()
```

### `Type.isAlias () bool`
### `Type.isArray () bool`
### `Type.isEnum () bool`
### `Type.isFunction () bool`
### `Type.isMap () bool`
### `Type.isMethod () bool`
### `Type.isNamespace () bool`
### `Type.isObject () bool`
### `Type.isOptional () bool`
### `Type.isReference () bool`
### `Type.isUnion () bool`
These methods are shortcuts for `is` expression.

**Return value**

Whether expression's body contains corresponding type.

**Examples**

```the
type.isAlias()
```

### `Type.canCastTo (to: ref Type) bool`
Checks whether type can be cast to another type (used for AsExpression or IsExpression).

**Parameters**

- `to` - another type to check if possible to cast to

**Return value**

Whether type can be cast to another type.

**Examples**

```the
mut tm := TypeMap{}
tm.get("u8").canCastTo(tm.get("int"))
```

### `Type.canPromoteTo (to: ref Type) bool`
Checks whether type can be promoted to another type.

**Parameters**

- `to` - another type to check if possible to promote to

**Return value**

Whether type can be promoted to another type.

**Examples**

```the
mut tm := TypeMap{}
tm.get("u8").canPromoteTo(tm.get("int"))
```

### `Type.get (nameOrIndex: int | str) TypeProperty`
Finds type's property with specified name or index.

**Parameters**

- `nameOrIndex` - name or index to search for

**Return value**

Type's property with specified name or index.

**Exceptions**

- `Error` - throw if tried to get non-existing property.

**Examples**

```the
property1 := type.get("name")
property2 := type.get(1)
```

### `Type.has (nameOrIndex: int | str) bool`
Checks whether type has property with specified name or index.

**Parameters**

- `nameOrIndex` - name or index to search for

**Return value**

Whether type has property with specified name or index.

**Examples**

```the
result1 := type.has("name")
result2 := type.has(1)
```

### `Type.hasEnumerator (name: str) bool`
Checks whether enum type has enumerator with specified name (should be used only on enum type).

**Parameters**

- `name` - name of enumerator to search for

**Return value**

Whether enum type has enumerator with specified name.

**Examples**

```the
result := type.hasEnumerator("Color")
```

### `Type.hasType (search: ref Type) bool`
Checks whether union type has specified subtype (should be used only on union type).

**Parameters**

- `search` - type to search for

**Return value**

Whether union type has specified subtype.

**Examples**

```the
mut tm := TypeMap{}
result := type.hasType(tm.get("int))
```

### `Type.isErrorLike () bool`
Checks whether type looks like error object (with first 'message' property of `str` type and second 'stack' property of `str` type).

**Return value**

Whether type looks like error object.

**Examples**

```the
result := type.isErrorLike()
```

### `Type.isFloat () bool`
Checks whether type is floating point type.

**Return value**

Whether type is floating point type.

**Examples**

```the
result := type.isFloat()
```

### `Type.isInt () bool`
Checks whether type is integer type.

**Return value**

Whether type is integer type.

**Examples**

```the
result := type.isInt()
```

### `Type.isNumber () bool`
Checks whether type floating point or integer type.

**Return value**

Whether type floating point or integer type.

**Examples**

```the
result := type.isNumber()
```

### `Type.isRequired () bool`
Checks whether type is required to have an initializer.

**Return value**

Whether type is required to have an initializer.

**Examples**

```the
result := type.isRequired()
```

### `Type.isSignedInt () bool`
Checks whether type is signed integer type.

**Return value**

Whether type is signed integer type.

**Examples**

```the
result := type.isSignedInt()
```

### `Type.isUnsignedInt () bool`
Checks whether type is unsigned integer type.

**Return value**

Whether type is unsigned integer type.

**Examples**

```the
result := type.isUnsignedInt()
```

### `Type.toString () str`
Returns string representation of the type.

**Return value**

String representation of the type.

**Exceptions**

- `Error` - throw if tried stringify on unknown type.

**Examples**

```the
result := type.toString()
```

### `TypeMap.init () void`
Initializes type map with globals.

**Return value**

none

**Examples**

```the
mut tm := TypeMap{}
tm.init()
```

### `TypeMap.createAlias (name: str, t: ref Type) ref Type`
Creates alias type and puts it inside type map.

**Parameters**

- `name` - name of the alias type
- `t` - underlying type of the alias type

**Return value**

Created alias type.

**Examples**

```the
mut tm := TypeMap{}
tm.createAlias("Alias", tm.get("int"))
```

### `TypeMap.createArray (elementType: ref Type) ref Type`
Creates array type and puts it inside type map.

**Parameters**

- `elementType` - underlying type of the array type

**Return value**

Created array type.

**Examples**

```the
mut tm := TypeMap{}
tm.createArray(tm.get("int"))
```

### `TypeMap.createEnum (name: str, members: str[]) ref Type`
Creates enum type and puts it inside type map.

**Parameters**

- `name` - name of the enum type
- `members` - members list of the enum type

**Return value**

Created enum type.

**Examples**

```the
mut tm := TypeMap{}
tm.createEnum("Color", ["Red", "Green", "Blue"])
```

### `TypeMap.createFunction (asynchronous: bool, parameters: TypeParameter[], returnType: ref Type) ref Type`
Creates function type and puts it inside type map.

**Parameters**

- `asynchronous` - whether function type should be asynchronous
- `parameters` - parameters list of the function type
- `returnType` - return type of the function type

**Return value**

Created function type.

**Examples**

```the
mut tm := TypeMap{}

tm.createFunction(false, [
  TypeParameter{name: "a", t: tm.get("int"), mutable: true, required: true},
  TypeParameter{name: nil, t: tm.get("int"), variadic: true},
], tm.get("void"))
```

### `TypeMap.createMap (keyType: ref Type, valueType: ref Type) ref Type`
Creates map type and puts it inside type map.

**Parameters**

- `keyType` - key type of the map type
- `valueType` - value type of the map type

**Return value**

Created map type.

**Examples**

```the
mut tm := TypeMap{}
tm.createMap(tm.get("str"), tm.get("str"))
```

### `TypeMap.createMethod (asynchronous: bool, parameters: TypeParameter[], returnType: ref Type, withSelf: bool, selfMutable: bool, selfName: str, selfType: ref Type) ref Type`
Creates method type and puts it inside type map.

**Parameters**

- `asynchronous` - whether method type should be asynchronous
- `parameters` - parameters list of the method type
- `returnType` - return type of the method type
- `withSelf` - whether method type has self as first parameter
- `selfMutable` - whether method type has mutable self as first parameter
- `selfName` - self parameter name of the method type
- `selfType` - self parameter type of the method type

**Return value**

Created method type.

**Examples**

```the
mut tm := TypeMap{}
mut selfType := tm.createObject("Animal")

tm.createMethod(false, [], tm.get("void"), false, false, "", selfType)
tm.createMethod(false, [], tm.get("void"), true, true, "self", tm.createReference(selfType))
```

### `TypeMap.createNamespace (name: str, members: NamespaceMember[]) ref Type`
Creates namespace type and puts it inside type map.

**Parameters**

- `name` - name of the namespace type
- `members` - members list of the namespace type

**Return value**

Created namespace type.

**Examples**

```the
mut tm := TypeMap{}

tm.createNamespace("Namespace", [
  NamespaceMember{name: "Animal", t: tm.get("Animal")},
])
```

### `TypeMap.createObject (name: str, properties: TypeProperty[] = []) ref Type`
Creates object type and puts it inside type map.

**Parameters**

- `name` - name of the object type
- `properties` - optional. properties list of the object type

**Return value**

Created object type.

**Examples**

```the
mut tm := TypeMap{}

tm.createObject("Animal", [
  TypeProperty{name: "age", t: tm.get("int"), mutable: true},
  TypeProperty{name: "name", t: tm.get("str")},
])
```

### `TypeMap.createOptional (t: ref Type) ref Type`
Creates optional type and puts it inside type map.

**Parameters**

- `t` - underlying type of the optional type

**Return value**

Created optional type.

**Examples**

```the
mut tm := TypeMap{}
tm.createOptional(tm.get("int"))
```

### `TypeMap.createReference (t: ref Type) ref Type`
Creates reference type and puts it inside type map.

**Parameters**

- `t` - underlying type of the reference type

**Return value**

Created reference type.

**Examples**

```the
mut tm := TypeMap{}
tm.createReference(tm.get("int"))
```

### `TypeMap.createUnion (types: (ref Type)[]) ref Type`
Creates union type and puts it inside type map.

**Parameters**

- `types` - sub types of the union type

**Return value**

Created union type.

**Examples**

```the
mut tm := TypeMap{}
tm.createUnion([tm.get("i8"), tm.get("i16")])
tm.createUnion([tm.get("i8"), tm.get("i16"), tm.get("i32")])
```

### `TypeMap.decrease () void`
Deletes all types from current scope and decreases inner scope.

**Return value**

none

**Examples**

```the
typeMap.decrease()
```

### `TypeMap.increase () void`
Increases inner scope.

**Return value**

none

**Examples**

```the
typeMap.increase()
```

### `TypeMap.insert (t: ref Type) void`
Inserts specified type into type map.

**Parameters**

- `t` - type to insert

**Return value**

none

**Examples**

```the
mut tm1 := TypeMap{}
mut tm2 := TypeMap{}

t := tm1.createObject("Animal")
tm2.insert(t)
```

### `TypeMap.get (name: str) ref Type`
Searches for type and returns reference to it.

**Parameters**

- `name` - name of the type to search for

**Return value**

Reference to found type.

**Exceptions**

- `Error` - throw if type with this name doesn't exists.

**Examples**

```the
typeMap.get("int")
```

### `TypeMap.has (name: str, global := true) bool`
Checks whether type with specified name exists.

**Parameters**

- `name` - name of the type to search for
- `global` - optional. Whether to search in current scope or globally through all items

**Return value**

Whether type with specified name exists.

**Examples**

```the
typeMap.has("int")
```

### `TypeMap.getSelf () (ref Type)?`
Returns self type that was before set with `TypeMap.setSelf`.

**Return value**

Self type that was before set with `TypeMap.setSelf`.

**Examples**

```the
typeMap.getSelf()
```

### `TypeMap.setSelf (value: (ref Type)?) void`
Sets self type to specified type.

**Parameters**

- `value` - type to set as self type

**Return value**

none

**Examples**

```the
mut tm := TypeMap{}
mut selfType := tm.createObject("Animal")

tm.setSelf(selfType)
```

### `TypeMap.unionAdd (a: ref Type, b: ref Type) ref Type`
Adds `b` type as a sub type of `a` union type and returns a type created as a result of concatenation.

**Parameters**

- `a` - union type to concatenate into
- `b` - sub type to concatenate

**Return value**

Type created as a result of concatenating `a` and `b` types.

**Examples**

```the
mut tm := TypeMap{}
mut a := tm.createUnion([tm.get("i8"), tm.get("i16")])

c := tm.unionAdd(a, tm.get("i32"))
```

### `TypeMap.unionSub (a: ref Type, b: ref Type) ref Type`
Subtracts `b` sub type from `a` union type and returns a type created as a result of subtraction.
If subtraction leaves union type with only one type, the underlying type is returned instead of union type.

**Parameters**

- `a` - union type to subtract from
- `b` - sub type to subtract

**Return value**

Type created as a result of subtracting `b` type from `a` type.

**Examples**

```the
mut tm := TypeMap{}
mut a := tm.createUnion([tm.get("i8"), tm.get("i16"), tm.get("i32")])

c := tm.unionSub(a, tm.get("i32"))
d := tm.unionSub(c, tm.get("i16"))
```

### `VarMap.add (name: str, t: ref Type, mutable: bool) void`
Creates variable and inserts it into underlying items of var map.

**Parameters**

- `name` - name of the variable
- `t` - type of the variable
- `mutable` - whether variable should be mutable

**Return value**

none

**Examples**

```the
mut tm := TypeMap{}
varMap.add("age", tm.get("int"), mutable: false)
```

### `VarMap.decrease () void`
Deletes all variables from current scope and decreases inner scope.

**Return value**

none

**Examples**

```the
varMap.decrease()
```

### `VarMap.increase () void`
Increases inner scope.

**Return value**

none

**Examples**

```the
varMap.increase()
```

### `VarMap.get (name: str) Var`
Searches for variable by name and returns it.

**Parameters**

- `name` - name of the variable to search for

**Return value**

Found variable.

**Exceptions**

- `Error` - throw if variable with this name doesn't exists

**Examples**

```the
varMap.get("int")
```

### `VarMap.has (name: str, global := true) bool`
Checks whether variable with specified name exists.

**Parameters**

- `name` - name of the variable to search for
- `global` - optional. Whether to search in current scope or globally through all items

**Return value**

Whether variable with specified name exists.

**Examples**

```the
varMap.has("int")
```
