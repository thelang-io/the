/*!
 * Copyright (c) Aaron Delasy
 * Licensed under the MIT License
 */

import * as Parser from "the/parser"
import * as Type from "./type"
import * as TypeMap from "./type-map"
import * as VarMap from "./var-map"
import * as errors from "./errors"

export obj GuessTypeResult {
  first: ref Type.Type
  second: ref Type.Type
}

export obj TypeCastResult {
  consequent: (ref Type.Type)[str]
  alternate: (ref Type.Type)[str]
}

export obj AnalyzerState {
  mut loopInit: bool
  mut returnType: (ref Type.Type)?
  mut selfType: (ref Type.Type)?
}

// todo plan:
//   try/throw
//   property circular object
//   import/export
// todo left overs

export obj Analyzer {
  mut errors: str[]
  mut reader: Parser.Reader
  mut state: AnalyzerState
  mut tc: (ref Type.Type)[str]
  mut tm: TypeMap.TypeMap
  mut vm: VarMap.VarMap

  // todo check all self.t and see if it needs self.checkType, because some types are required to have initializer
  // todo test redefinition if variable in upper scope
  // todo test use of initial variable type after type cast

  fn analyze (mut self: ref Self, items: ref Parser.Statement[]) {
    len := items.len

    loop i := 0; i < len; i++ {
      if items[i].isDeclaration() {
        loop j := i; j < len && items[j].isDeclaration(); j++ {
          self.declare(items[j])
        }

        loop j := i; j < len && items[j].isDeclaration(); j++ {
          self.define(items[j])
        }

        loop ; i < len && items[i].isDeclaration(); i++ {
          self.statement(items[i])
        }
      } else {
        self.statement(items[i])
      }
    }
  }

  fn declare (mut self: ref Self, it: ref Parser.Statement) {
    if it.isEnumDeclaration() {
      statement := it.asEnumDeclaration()

      if self.tm.has(statement.name.name) {
        self.raise(errors.E1000(statement.name.name), statement.name.start, statement.name.end)
      }

      membersLen := statement.members.len
      mut members: str[]

      loop i := 0; i < membersLen; i++ {
        members.push(statement.members[i].name.name)
      }

      self.tm.createEnum(statement.name.name, members)
    } elif it.isExportDeclaration() {
      statement := it.asExportDeclaration()
      self.declare(ref statement.statement)
    } elif it.isFunctionDeclaration() {
      statement := it.asFunctionDeclaration()

      if self.vm.has(statement.name.name) {
        self.raise(errors.E1000(statement.name.name), statement.name.start, statement.name.end)
      }
    } elif it.isImportDeclaration() {
      statement := it.asImportDeclaration()
      // todo E1032 - Circular imports are not allowed
      // todo E1033 - Object is not exported
      // todo E1035 - Package not installed
      // todo Path not found
      // todo duplicate declaration of specifier
      // todo specifier name = existing type or variable

      if it.hasParent() {
        self.raise(errors.E1043(), it.start, it.end)
      }
    } elif it.isObjectDeclaration() {
      statement := it.asObjectDeclaration()

      if self.tm.has(statement.name.name) {
        self.raise(errors.E1000(statement.name.name), statement.name.start, statement.name.end)
      }

      self.tm.createObject(statement.name.name)
    }
  }

  fn define (mut self: ref Self, it: ref Parser.Statement) {
    if it.isExportDeclaration() {
      statement := it.asExportDeclaration()
      self.define(ref statement.statement)
    } elif it.isFunctionDeclaration() {
      statement := it.asFunctionDeclaration()

      self.vm.increase()
      parameters := self.functionParametersLight(statement.parameters)
      self.vm.decrease()
      returnType := statement.returnType == nil ? self.tm.get("void") : self.t(statement.returnType)
      t := self.tm.createFunction(statement.asynchronous, parameters, returnType)

      self.vm.add(statement.name.name, t, false)
    } elif it.isObjectDeclaration() {
      statement := it.asObjectDeclaration()
      initialTmSelf := self.tm.getSelf()
      initialStateSelf := self.state.selfType

      t := self.tm.get(statement.name.name)
      len := statement.body.len

      self.state.selfType = Type.opt(t)
      self.tm.setSelf(Type.opt(t))

      loop i := 0; i < len; i++ {
        self.define(statement.body[i])
      }

      self.state.selfType = initialStateSelf
      self.tm.setSelf(initialTmSelf)
    } elif it.isObjectDeclarationMethod() {
      statement := it.asObjectDeclarationMethod()
      selfType := self.state.selfType as ref Type.Type

      if selfType.has(statement.name.name) {
        self.raise(errors.E1051(statement.name.name), statement.name.start, statement.name.end)
      } else {
        print("method doesn't exists")
      }

      self.vm.increase()
      parameters := self.functionParametersLight(statement.parameters)
      self.vm.decrease()

      mut selfParameter: Type.TypeParameter?

      if !parameters.empty && Type.match(parameters[0].t, selfType) {
        selfParameter = parameters[0]
        parameters.remove(0)
      }

      returnType := statement.returnType == nil ? self.tm.get("void") : self.t(statement.returnType)

      t := self.tm.createMethod(
        statement.asynchronous,
        parameters,
        returnType,
        withSelf: selfParameter != nil,
        selfMutable: selfParameter != nil ? selfParameter.mutable : false,
        selfName: selfParameter != nil ? selfParameter.name != nil ? selfParameter.name : "" : "",
        selfType: selfType
      )

      selfType.properties.push(Type.TypeProperty{
        name: statement.name.name,
        t: t,
        mutable: false
      })
    } elif it.isObjectDeclarationProperty() {
      statement := it.asObjectDeclarationProperty()
      selfType := self.state.selfType as ref Type.Type

      if selfType.has(statement.name.name) {
        self.raise(errors.E1051(statement.name.name), statement.name.start, statement.name.end)
      }

      t := statement.t == nil ? self.e(statement.initializer as Parser.Expression) : self.t(statement.t)

      selfType.properties.push(Type.TypeProperty{
        name: statement.name.name,
        t: t,
        mutable: statement.mutable
      })
    } elif it.isTypeAliasDeclaration() {
      statement := it.asTypeAliasDeclaration()

      if self.tm.has(statement.name.name) {
        self.raise(errors.E1000(statement.name.name), statement.name.start, statement.name.end)
      }

      self.tm.createAlias(statement.name.name, self.t(statement.t))
    }
  }

  fn e (mut self: ref Self, it: Parser.Expression, targetType: (ref Type.Type)? = nil, withMutable := false) ref Type.Type {
    if it.isIdentifier() {
      expression := it.asIdentifier()

      if !self.vm.has(expression.name) {
        self.raise(errors.E1003(expression.name), it.start, it.end)
        return targetType == nil ? self.tm.get("any") : targetType
      }

      var := self.vm.get(expression.name)

      if withMutable && !var.mutable {
        self.raise(errors.E1011(expression.name), it.start, it.end)
      }

      code := Parser.stringifyExpression(it)
      return self.tc.has(code) ? self.tc.get(code) : var.t
    } elif it.isBooleanLiteral() {
      return self.tm.get("bool")
    } elif it.isCharacterLiteral() {
      return self.tm.get("char")
    } elif it.isFloatingPointLiteral() {
      expression := it.asFloatingPointLiteral()
      definiteTargetType := Type.unwrap(targetType == nil ? self.tm.get("float") : targetType)
      t := Type.unwrap(definiteTargetType.isFloat() ? definiteTargetType : self.tm.get("float"))

      try {
        if Type.match(t, self.tm.get("f32")) {
          expression.value.toF32()
        } else {
          expression.value.toF64()
        }
      } catch err: error_Error {
        self.raise(errors.E1030(t.toString()), it.start, it.end)
      }

      return t
    } elif it.isIntegerLiteral() {
      expression := it.asIntegerLiteral()
      definiteTargetType := Type.unwrap(targetType == nil ? self.tm.get("int") : targetType)
      t := Type.unwrap(definiteTargetType.isInt() ? definiteTargetType : self.tm.get("int"))

      try {
        if Type.match(t, self.tm.get("i8")) {
          expression.value.toI8()
        } elif Type.match(t, self.tm.get("i16")) {
          expression.value.toI16()
        } elif Type.match(t, self.tm.get("i32")) {
          expression.value.toI32()
        } elif Type.match(t, self.tm.get("i64")) {
          expression.value.toI64()
        } elif Type.match(t, self.tm.get("u8")) {
          expression.value.toU8()
        } elif Type.match(t, self.tm.get("u16")) {
          expression.value.toU16()
        } elif Type.match(t, self.tm.get("u32")) {
          expression.value.toU32()
        } elif Type.match(t, self.tm.get("u64")) {
          expression.value.toU64()
        }
      } catch err: error_Error {
        self.raise(errors.E1029(t.toString()), it.start, it.end)
      }

      return t
    } elif it.isNilLiteral() {
      if targetType == nil {
        self.raise(errors.E1004(), it.start, it.end)
        return self.tm.createOptional(self.tm.get("any"))
      }

      t := Type.unwrap(targetType as ref Type.Type, withOptional: false)

      if t.isOptional() {
        return t
      }

      self.raise(errors.E1006(t.toString()), it.start, it.end)
      return self.tm.createOptional(self.tm.get("any"))
    } elif it.isStringLiteral() {
      return self.tm.get("str")
    } elif it.isArray() {
      expression := it.asArray()
      mut elementType: (ref Type.Type)?

      if targetType != nil {
        t := Type.unwrap(targetType)

        if t.isArray() {
          t := t.asArray()
          elementType = Type.opt(t.elementType)
        }
      }

      if expression.elements.empty {
        if elementType == nil {
          self.raise(errors.E1007(), it.start, it.end)
          return self.tm.createArray(self.tm.get("any"))
        }
      }

      elementsLen := expression.elements.len
      elementTypeForced := elementType != nil

      loop i := 0; i < elementsLen; i++ {
        element := expression.elements[i]
        t := self.e(element, elementType)

        if elementType == nil {
          elementType = t
        } elif !Type.match(elementType, t) {
          if elementTypeForced {
            self.raise(errors.E1008(t.toString(), elementType.toString()), element.start, element.end)
          } else {
            elementType = self.tm.unionAdd(elementType, t)
          }
        }
      }

      return self.tm.createArray(elementType as ref Type.Type)
    } elif it.isAs() {
      expression := it.asAs()
      expressionType := self.e(expression.expression, withMutable: withMutable)
      t := self.t(expression.t)

      if !expressionType.canBe(t) {
        self.raise(errors.E1009(expressionType.toString(), t.toString()), it.start, it.end)
      }

      return t
    } elif it.isAssignment() {
      expression := it.asAssignment()

      guessTypeResult := self.guessType((operandType: (ref Type.Type)?) -> ref Type.Type {
        initialTC := ref self.tc
        return self.e(expression.left, operandType, withMutable: true)
      }, (operandType: (ref Type.Type)?) -> ref Type.Type {
        initialTC := ref self.tc
        return self.e(expression.right, operandType)
      })

      leftType := guessTypeResult.first
      rightType := guessTypeResult.second

      if !self.operands(expression.operator, leftType, rightType) {
        self.raise(errors.E1027(expression.operator.val, leftType.toString()), expression.operator.start, expression.operator.end)
      }

      if !expression.left.isAccess() {
        self.raise(errors.E1010(), expression.left.start, expression.left.end)
      }

      return leftType.isReference() && !rightType.isReference()
        ? Type.unwrap(leftType, withOptional: false)
        : leftType
    } elif it.isAwait() {
      // todo check is used within async method|function or main
      expression := it.asAwait()
      expressionType := Type.unwrap(self.e(expression.expression), withOptional: false)

      if expressionType.isFunction() {
        t := expressionType.asFunction()

        if !t.asynchronous {
          self.raise(errors.E1013(), expression.expression.start, expression.expression.end)
        }

        return t.returnType
      } else {
        self.raise(errors.E1013(), expression.expression.start, expression.expression.end)
        return self.tm.get("any")
      }
    } elif it.isBinary() {
      expression := it.asBinary()

      guessTypeResult := self.guessType((operandType: (ref Type.Type)?) -> ref Type.Type {
        initialTC := ref self.tc
        return Type.unwrap(self.e(expression.left, operandType), withOptional: false)
      }, (operandType: (ref Type.Type)?) -> ref Type.Type {
        initialTC := ref self.tc
        return Type.unwrap(self.e(expression.right, operandType), withOptional: false)
      })

      leftType := guessTypeResult.first
      rightType := guessTypeResult.second

      if !self.operands(expression.operator, leftType, rightType) {
        self.raise(errors.E1026(expression.operator.val, leftType.toString(), rightType.toString()), expression.operator.start, expression.operator.end)
      }

      if (
        expression.operator.t == .OpEqEq ||
        expression.operator.t == .OpExclEq ||
        expression.operator.t == .OpGt ||
        expression.operator.t == .OpGtEq ||
        expression.operator.t == .OpLt ||
        expression.operator.t == .OpLtEq
      ) {
        return self.tm.get("bool")
      } elif Type.match(leftType, self.tm.get("str")) && Type.match(rightType, self.tm.get("str")) {
        return self.tm.get("str")
      } elif leftType.isNumber() && rightType.isNumber() {
        return Type.largest(leftType, rightType)
      }

      return leftType
    } elif it.isCall() {
      // todo check if method is mutating immutable left-hand
      initialErrorsLen := self.errors.len
      expression := it.asCall()
      calleeType := Type.unwrap(self.e(expression.callee), withOptional: false)
      mut asynchronous: bool
      mut parameters: Type.TypeParameter[]
      mut returnType := self.tm.get("void")

      if calleeType.isFunction() {
        t := calleeType.asFunction()
        asynchronous = t.asynchronous
        parameters = t.parameters
        returnType = t.returnType
      } elif calleeType.isMethod() {
        t := calleeType.asMethod()
        asynchronous = t.asynchronous
        parameters = t.parameters
        returnType = t.returnType

        if t.withSelf && t.selfMutable {
          self.errors = self.errors.slice(0, initialErrorsLen)
          self.e(expression.callee, withMutable: true)
        }
      } else {
        self.raise(errors.E1031(calleeType.toString()), expression.callee.start, expression.callee.end)
        return self.tm.get("void")
      }

      argumentsLen := expression.arguments.len
      parametersLen := parameters.len
      mut passedParameters: str[]
      mut hasNamed := false
      mut isVariadic := false
      mut variadicParameter: Type.TypeParameter?
      mut parameterIdx := 0

      loop i := 0; i < argumentsLen; i++ {
        argument := expression.arguments[i]
        mut parameter: Type.TypeParameter?

        if argument.name != nil {
          if passedParameters.contains(argument.name.name) {
            self.raise(errors.E1032(argument.name.name), argument.name.start, argument.name.end)
            break
          }

          loop j := 0; j < parametersLen; j++ {
            typeParameter := parameters[j]

            if typeParameter.name != nil {
              if typeParameter.name == argument.name.name {
                parameter = typeParameter as Type.TypeParameter
                break
              }
            }
          }

          if parameter == nil {
            self.raise(errors.E1032(argument.name.name), argument.name.start, argument.name.end)
            break
          } elif parameter.variadic {
            self.raise(errors.E1033(argument.name.name), argument.name.start, argument.name.end)
            break
          }

          hasNamed = true
          isVariadic = false
          variadicParameter = nil
        } elif hasNamed {
          self.raise(errors.E1034(), argument.expression.start, argument.expression.end)
          break
        } elif isVariadic {
          parameter = variadicParameter
        } elif parameterIdx >= parametersLen {
          self.raise(errors.E1032(), argument.expression.start, argument.expression.end)
          break
        } else {
          parameter = parameters[parameterIdx]
        }

        definiteParameter := parameter as Type.TypeParameter

        if !isVariadic && definiteParameter.variadic {
          isVariadic = true
          variadicParameter = definiteParameter
        }

        mut parameterType := definiteParameter.t

        if definiteParameter.variadic {
          t := parameterType.asArray()
          parameterType = t.elementType
        }

        t := Type.unwrap(self.e(argument.expression, Type.opt(parameterType)), withReference: false)

        if !Type.match(parameterType, t) {
          self.raise(errors.E1035(t.toString(), parameterType.toString()), argument.expression.start, argument.expression.end)
        } elif !isVariadic {
          if definiteParameter.name != nil {
            passedParameters.push(definiteParameter.name)
          }

          parameterIdx++
        }
      }

      loop ; parameterIdx < parametersLen; parameterIdx++ {
        parameter := parameters[parameterIdx]

        if parameter.required && parameter.name != nil {
          self.raise(errors.E1036(parameter.name), it.start, it.end)
        } elif parameter.required {
          self.raise(errors.E1037(), it.start, it.end)
        }
      }

      return asynchronous ? calleeType : returnType
    } elif it.isClosure() {
      expression := it.asClosure()

      self.vm.increase()
      parameters := self.functionParameters(expression.parameters)
      self.statement(expression.body)
      self.vm.decrease()

      return self.tm.createFunction(expression.asynchronous, parameters, self.t(expression.returnType))
    } elif it.isConditional() {
      initialTC := self.tc
      expression := it.asConditional()
      typeCastResult := self.typeCast(expression.condition)
      conditionType := Type.unwrap(self.e(expression.condition), withOptional: false)

      if !Type.match(conditionType, self.tm.get("bool")) {
        self.raise(errors.E1018(conditionType.toString()), expression.condition.start, expression.condition.end)
      }

      guessTypeResult := self.guessType((operandType: (ref Type.Type)?) -> ref Type.Type {
        self.tc.merge(typeCastResult.consequent)
        result := Type.unwrap(self.e(expression.consequent, operandType, withMutable: withMutable), withOptional: false)
        self.tc = initialTC

        return result
      }, (operandType: (ref Type.Type)?) -> ref Type.Type {
        self.tc.merge(typeCastResult.alternate)
        result := Type.unwrap(self.e(expression.alternate, operandType, withMutable: withMutable), withOptional: false)
        self.tc = initialTC

        return result
      })

      consequentType := guessTypeResult.first
      alternateType := guessTypeResult.second

      if consequentType.isNumber() && alternateType.isNumber() {
        return Type.largest(consequentType, alternateType)
      } elif !Type.match(consequentType, alternateType) && !Type.match(alternateType, consequentType) {
        self.raise(errors.E1019(consequentType.toString(), alternateType.toString()), expression.consequent.start, expression.alternate.end)
      }

      return Type.match(consequentType, alternateType) ? consequentType : alternateType
    } elif it.isElementAccess() {
      expression := it.asElementAccess()
      expressionType := Type.unwrap(self.e(expression.expression, withMutable: withMutable), withOptional: false)
      argumentType := Type.unwrap(self.e(expression.argument), withOptional: false)

      if !Type.match(argumentType, self.tm.get("i32")) {
        self.raise(errors.E1014(argumentType.toString()), expression.argument.start, expression.argument.end)
      }

      mut t := self.tm.createReference(self.tm.get("any"))

      if expressionType.isArray() {
        arrayType := expressionType.asArray()
        t = self.tm.createReference(arrayType.elementType)
      } elif Type.match(expressionType, self.tm.get("str")) {
        t = self.tm.createReference(self.tm.get("char"))
      } else {
        self.raise(errors.E1015(argumentType.toString()), expression.expression.start, expression.expression.end)
      }

      code := Parser.stringifyExpression(it)
      return self.tc.has(code) ? self.tc.get(code) : t
    } elif it.isIs() {
      expression := it.asIs()
      expressionType := self.e(expression.expression, withMutable: withMutable)
      t := self.t(expression.t)

      if !expressionType.canBe(t) {
        self.raise(errors.E1009(expressionType.toString(), t.toString()), expression.expression.start, expression.expression.end)
      }

      return self.tm.get("bool")
    } elif it.isMap() {
      expression := it.asMap()
      mut t: (ref Type.Type)?

      if targetType != nil {
        maybeMapType := Type.unwrap(targetType)

        if maybeMapType.isMap() {
          t = maybeMapType
        }
      }

      if expression.elements.empty && t == nil {
        self.raise(errors.E1016(), it.start, it.end)
        return self.tm.createMap(self.tm.get("any"), self.tm.get("any"))
      } elif expression.elements.empty {
        return t
      }

      mut keyType: (ref Type.Type)?
      mut valueType: (ref Type.Type)?

      if t != nil {
        mapType := t.asMap()
        keyType = Type.opt(mapType.keyType)
        valueType = Type.opt(mapType.valueType)
      }

      keyTypeForced := keyType != nil
      valueTypeForced := valueType != nil
      elementsLen := expression.elements.len

      loop i := 0; i < elementsLen; i++ {
        element := expression.elements[i]
        elementKeyType := self.e(element.key, keyType)
        elementValueType := self.e(element.value, valueType)

        if keyType == nil {
          keyType = elementKeyType
        } elif !Type.match(keyType, elementKeyType) && keyTypeForced {
          self.raise(errors.E1005(keyType.toString(), elementKeyType.toString()), element.key.start, element.key.end)
        } elif !Type.match(keyType, elementKeyType) {
          keyType = self.tm.unionAdd(keyType, elementKeyType)
        }

        if valueType == nil {
          valueType = elementValueType
        } elif !Type.match(valueType, elementValueType) && valueTypeForced {
          self.raise(errors.E1005(valueType.toString(), elementValueType.toString()), element.value.start, element.value.end)
        } elif !Type.match(valueType, elementValueType) {
          valueType = self.tm.unionAdd(valueType, elementValueType)
        }
      }

      return self.tm.createMap(keyType as ref Type.Type, valueType as ref Type.Type)
    } elif it.isMemberAccess() {
      expression := it.asMemberAccess()
      mut t: (ref Type.Type)?

      if targetType != nil {
        maybeEnumType := Type.unwrap(targetType, withOptional: false)

        if maybeEnumType.isEnum() {
          t = maybeEnumType
        }
      }

      if t == nil {
        self.raise(errors.E1020(), it.start, it.end)
        return self.tm.get("any")
      } elif !t.hasEnumerator(expression.name.name) {
        self.raise(errors.E1021(expression.name.name), it.start, it.end)
      }

      return t as ref Type.Type
    } elif it.isObject() {
      expression := it.asObject()
      t := self.t(expression.id)
      propertiesLen := expression.properties.len
      mut propertyNames: str[]

      loop i := 0; i < propertiesLen; i++ {
        property := expression.properties[i]

        if !t.has(property.name.name) {
          self.raise(errors.E1002(property.name.name, t.toString()), property.name.start, property.name.end)
          self.e(property.value)
        } else {
          p := t.get(property.name.name)
          propertyType := self.e(property.value, Type.opt(p.t))

          if !Type.match(p.t, propertyType) {
            self.raise(errors.E1005(propertyType.toString(), p.t.toString()), property.value.start, property.value.end)
          }

          propertyNames.push(property.name.name)
        }
      }

      typePropertiesLen := t.properties.len

      loop i := 0; i < typePropertiesLen; i++ {
        property := t.properties[i]

        if !property.builtin && property.t.isRequired() && !propertyNames.contains(property.name) {
          self.raise(errors.E1041(property.name, property.t.toString()), expression.id.start, expression.id.end)
        }
      }

      return t
    } elif it.isParenthesized() {
      expression := it.asParenthesized()
      return self.e(expression.expression, targetType, withMutable: withMutable)
    } elif it.isPropertyAccess() {
      expression := it.asPropertyAccess()
      t := Type.unwrap(self.e(expression.expression, withMutable: withMutable), withOptional: false)

      if t.isEnum() {
        if !t.hasEnumerator(expression.name.name) {
          self.raise(errors.E1021(expression.name.name), expression.name.start, expression.name.end)
        }
        return t
      } elif !t.has(expression.name.name) {
        self.raise(errors.E1002(expression.name.name, t.toString()), expression.name.start, expression.name.end)
        return self.tm.get("any")
      }

      property := t.get(expression.name.name)

      if withMutable && !property.mutable {
        self.raise(errors.E1012(expression.name.name), it.start, it.end)
      }

      code := Parser.stringifyExpression(it)
      return self.tc.has(code) ? self.tc.get(code) : property.t
    } elif it.isReference() {
      expression := it.asReference()
      return self.tm.createReference(self.e(expression.expression, withMutable: withMutable))
    } elif it.isUnary() {
      expression := it.asUnary()

      if expression.operator.t == .OpExcl {
        operandType := Type.unwrap(self.e(expression.operand), withOptional: false)

        if !Type.match(operandType, self.tm.get("bool")) && Type.match(operandType, self.tm.get("byte")) && !operandType.isNumber() {
          self.raise(errors.E1025(expression.operator.val, operandType.toString()), expression.operator.start, expression.operator.end)
        }

        return self.tm.get("bool")
      } elif expression.operator.t == .OpMinusMinus || expression.operator.t == .OpPlusPlus {
        operandType := Type.unwrap(self.e(expression.operand, withMutable: true), withOptional: false)

        if !expression.operand.isAccess() {
          self.raise(errors.E1024(), expression.operator.start, expression.operator.end)
        } elif !operandType.isNumber() {
          self.raise(errors.E1025(expression.operator.val, operandType.toString()), expression.operator.start, expression.operator.end)
        }

        return operandType
      } elif expression.operator.t == .OpMinus {
        operandType := Type.unwrap(self.e(expression.operand), withOptional: false)

        if !operandType.isSignedInt() && !operandType.isFloat() {
          self.raise(errors.E1025(expression.operator.val, operandType.toString()), expression.operator.start, expression.operator.end)
        }

        return operandType
      } elif expression.operator.t == .OpPlus {
        operandType := Type.unwrap(self.e(expression.operand), withOptional: false)

        if !operandType.isNumber() {
          self.raise(errors.E1025(expression.operator.val, operandType.toString()), expression.operator.start, expression.operator.end)
        }

        return operandType
      } elif expression.operator.t == .OpTilde {
        operandType := Type.unwrap(self.e(expression.operand), withOptional: false)

        if !operandType.isInt() {
          self.raise(errors.E1025(expression.operator.val, operandType.toString()), expression.operator.start, expression.operator.end)
        }

        return operandType
      } else {
        return Type.unwrap(self.e(expression.operand), withOptional: false)
      }
    }

    throw error_NewError("Tried analyzing unknown expression")
  }

  fn eNice (mut self: ref Self, it: Parser.Expression) ref Type.Type {
    initialErrorsLen := self.errors.len
    result := self.e(it)

    if self.errors.len != initialErrorsLen {
      self.errors = self.errors.slice(0, initialErrorsLen)
    }

    return result
  }

  fn functionParameters (mut self: ref Self, parameters: Parser.FunctionParameter[]) Type.TypeParameter[] {
    mut parameterNames: str[]
    mut result: Type.TypeParameter[]
    parametersLen := parameters.len

    loop i := 0; i < parametersLen; i++ {
      parameter := parameters[i]

      if parameterNames.contains(parameter.name.name) {
        self.raise(errors.E1054(parameter.name.name), parameter.name.start, parameter.name.end)
      }

      mut t := parameter.t == nil ? self.e(parameter.initializer as Parser.Expression) : self.t(parameter.t)

      if Type.match(t, self.tm.get("void")) {
        if parameter.t == nil {
          initializer := parameter.initializer as Parser.Expression
          self.raise(errors.E1017(), initializer.start, initializer.end)
        } else {
          self.raise(errors.E1017(), parameter.t.start, parameter.t.end)
        }
      }

      if parameter.variadic {
        t = self.tm.createArray(t)

        if parameter.initializer != nil {
          self.raise(errors.E1028(), parameter.initializer.start, parameter.initializer.end)
        }
      }

      if parameter.t != nil && parameter.initializer != nil {
        initializerType := self.e(parameter.initializer, Type.opt(t))

        if !Type.match(t, initializerType) {
          self.raise(errors.E1005(initializerType.toString(), t.toString()), parameter.initializer.start, parameter.initializer.end)
        }
      }

      parameterNames.push(parameter.name.name)
      self.vm.add(parameter.name.name, t, parameter.mutable)

      result.push(Type.TypeParameter{
        name: parameter.name.name,
        t: t,
        mutable: parameter.mutable,
        required: parameter.initializer == nil && !parameter.variadic,
        variadic: parameter.variadic
      })
    }

    return result
  }

  fn functionParametersLight (mut self: ref Self, parameters: Parser.FunctionParameter[]) Type.TypeParameter[] {
    mut parameterNames: str[]
    mut result: Type.TypeParameter[]
    parametersLen := parameters.len

    loop i := 0; i < parametersLen; i++ {
      parameter := parameters[i]

      mut t := parameter.t == nil
        ? self.e(parameter.initializer as Parser.Expression)
        : self.t(parameter.t)

      if parameter.variadic {
        t = self.tm.createArray(t)
      }

      self.vm.add(parameter.name.name, t, parameter.mutable)

      result.push(Type.TypeParameter{
        name: parameter.name.name,
        t: t,
        mutable: parameter.mutable,
        required: parameter.initializer == nil && !parameter.variadic,
        variadic: parameter.variadic
      })
    }

    return result
  }

  fn guessType (mut self: ref Self, cb1: ((ref Type.Type)?) -> ref Type.Type, cb2: ((ref Type.Type)?) -> ref Type.Type) GuessTypeResult {
    initialErrorsLen := self.errors.len
    mut targetType: (ref Type.Type)? = nil
    mut firstType := cb1(targetType)
    firstTypeFailed := self.errors.len != initialErrorsLen

    if firstTypeFailed {
      self.errors = self.errors.slice(0, initialErrorsLen)
    } else {
      targetType = firstType
    }

    secondType := cb2(targetType)
    secondTypeFailed := self.errors.len != initialErrorsLen

    if !secondTypeFailed {
      targetType = secondType
    }

    if firstTypeFailed {
      firstType = cb1(targetType)
    }

    return GuessTypeResult{
      first: firstType,
      second: secondType
    }
  }

  fn operands (mut self: ref Self, op: Parser.Token, t1: ref Type.Type, t2: ref Type.Type) bool {
    if op.t == .OpEqEq || op.t == .OpExclEq {
      if Type.match(t1, self.tm.get("void")) || Type.match(t2, self.tm.get("void")) || !Type.match(t1, t2) {
        return false
      }
    } elif op.t == .OpGt || op.t == .OpGtEq || op.t == .OpLt || op.t == .OpLtEq {
      if (
        !(t1.isNumber() || Type.match(t1, self.tm.get("byte")) || Type.match(t1, self.tm.get("char")) || Type.match(t1, self.tm.get("str"))) ||
        !(t2.isNumber() || Type.match(t2, self.tm.get("byte")) || Type.match(t2, self.tm.get("char")) || Type.match(t2, self.tm.get("str"))) ||
        !Type.match(t1, t2)
      ) {
        return false
      }
    } elif op.t == .OpPlus || op.t == .OpPlusEq {
      if (
        !(t1.isNumber() || Type.match(t1, self.tm.get("byte")) || Type.match(t1, self.tm.get("str"))) ||
        !(t2.isNumber() || Type.match(t2, self.tm.get("byte")) || Type.match(t2, self.tm.get("str"))) ||
        !Type.match(t1, t2)
      ) {
        return false
      }
    } elif (
      op.t == .OpMinus || op.t == .OpMinusEq ||
      op.t == .OpPercent || op.t == .OpPercentEq ||
      op.t == .OpSlash || op.t == .OpSlashEq ||
      op.t == .OpStar || op.t == .OpStarEq
    ) {
      if (
        !(t1.isNumber() || Type.match(t1, self.tm.get("byte"))) ||
        !(t2.isNumber() || Type.match(t2, self.tm.get("byte")))
      ) {
        return false
      }
    } elif op.t == .OpAmpAmp || op.t == .OpAmpAmpEq || op.t == .OpPipePipe || op.t == .OpPipePipeEq {
      if (
        !(t1.isNumber() || Type.match(t1, self.tm.get("bool")) || Type.match(t1, self.tm.get("byte"))) ||
        !(t2.isNumber() || Type.match(t2, self.tm.get("bool")) || Type.match(t2, self.tm.get("byte")))
      ) {
        return false
      }
    } elif (
      op.t == .OpAmp || op.t == .OpAmpEq ||
      op.t == .OpCaret || op.t == .OpCaretEq ||
      op.t == .OpLShift || op.t == .OpLShiftEq ||
      op.t == .OpPipe || op.t == .OpPipeEq ||
      op.t == .OpRShift || op.t == .OpRShiftEq
    ) {
      if !t1.isInt() || !t2.isInt() {
        return false
      }
    }

    return true
  }

  fn raise (mut self: ref Self, message: str, start: int, end: int) {
    error := Parser.Reader_error(ref self.reader, "AnalyzeError", message, start, end)
    self.errors.push(error)
  }

  fn statement (mut self: ref Self, it: Parser.Statement) {
    if it.isBlock() {
      statement := it.asBlock()

      self.vm.increase()
      self.analyze(ref statement.body)
      self.vm.decrease()
    } elif it.isBreak() {
      if !it.hasLoopParent() {
        self.raise(errors.E1050("Break"), it.start, it.end)
      }
    } elif it.isContinue() {
      if !it.hasLoopParent() {
        self.raise(errors.E1050("Continue"), it.start, it.end)
      }
    } elif it.isEnumDeclaration() {
      statement := it.asEnumDeclaration()
      membersLen := statement.members.len
      mut members: str[]

      loop i := 0; i < membersLen; i++ {
        member := statement.members[i]

        if members.contains(member.name.name) {
          self.raise(errors.E1052(member.name.name), member.name.start, member.name.end)
        }

        if member.initializer == nil {
          continue
        }

        initializer := member.initializer as Parser.Expression
        memberType := self.e(initializer, Type.opt(self.tm.get("int")))

        if !Type.match(memberType, self.tm.get("int")) {
          self.raise(errors.E1053(memberType.toString()), initializer.start, initializer.end)
        }
      }
    } elif it.isExportDeclaration() {
      // todo E1022 - Void type can only be used as function return type
      // todo check duplicate export names
      // todo only specific declarations enum | alias | function | etc
      statement := it.asExportDeclaration()

      if it.hasParent() {
        self.raise(errors.E1044(), it.start, it.end)
      }
    } elif it.isExportNamedDeclaration() {
      // todo check if left-hand value
      // todo E1022 - Void type can only be used as function return type
      // todo check duplicate export names
      // todo can't export element access
      statement := it.asExportNamedDeclaration()

      if it.hasParent() {
        self.raise(errors.E1044(), it.start, it.end)
      }
    } elif it.isExpression() {
      statement := it.asExpression()
      self.e(statement.expression)

      if !it.hasParent() {
        self.raise(errors.E1049(), it.start, it.end)
      }
    } elif it.isFunctionDeclaration() {
      statement := it.asFunctionDeclaration()
      initialStateReturnType := self.state.returnType
      var := self.vm.get(statement.name.name)

      if !var.t.isFunction() {
        return
      }

      t := var.t.asFunction()

      self.vm.increase()
      self.functionParameters(statement.parameters)
      self.state.returnType = Type.opt(t.returnType)

      if statement.body != nil {
        if (
          !Type.match(t.returnType, self.tm.get("void")) &&
          !statement.body.isDeadEnd() &&
          statement.returnType != nil
        ) {
          returnType := statement.returnType
          self.raise(errors.E1061(), returnType.start, returnType.end)
        }

        self.statement(statement.body)
      }

      self.state.returnType = initialStateReturnType
      self.vm.decrease()
    } elif it.isIf() {
      initialTC := self.tc
      statement := it.asIf()

      if !it.hasParent() {
        self.raise(errors.E1045(), it.start, it.end)
      }

      typeCastResult := self.typeCast(statement.condition)
      conditionType := Type.unwrap(self.e(statement.condition, Type.opt(self.tm.get("bool"))), withOptional: false)

      if !Type.match(conditionType, self.tm.get("bool")) {
        self.raise(errors.E1018(conditionType.toString()), statement.condition.start, statement.condition.end)
      }

      self.tc.merge(typeCastResult.consequent)
      self.statement(statement.consequent)
      self.tc = initialTC
      self.tc.merge(typeCastResult.alternate)

      if statement.alternate != nil {
        self.statement(statement.alternate)
      }

      if !statement.consequent.isDeadEnd() {
        self.tc = initialTC
      }
    } elif it.isLoop() {
      initialTC := self.tc
      statement := it.asLoop()
      initialLoopInit := self.state.loopInit

      if !it.hasParent() {
        self.raise(errors.E1046(), it.start, it.end)
      }

      self.vm.increase()

      if statement.initializer != nil {
        initializer := statement.initializer

        if initializer.isVariableDeclaration() {
          initializerStatement := initializer.asVariableDeclaration()

          if initializerStatement.mutable {
            self.raise(errors.E1059(), initializerStatement.name.start, initializerStatement.name.end)
          }
        } elif !initializer.isExpression() {
          self.raise(errors.E1058(), initializer.start, initializer.end)
        }

        self.state.loopInit = true
        self.statement(initializer)
        self.state.loopInit = initialLoopInit
      }

      if statement.condition != nil {
        typeCastResult := self.typeCast(statement.condition)

        conditionType := Type.unwrap(
          self.e(statement.condition, Type.opt(self.tm.get("bool"))),
          withOptional: false
        )

        if !Type.match(self.tm.get("bool"), conditionType) {
          self.raise(errors.E1060(conditionType.toString()), statement.condition.start, statement.condition.end)
        }

        self.tc.merge(typeCastResult.consequent)
      }

      if statement.update != nil {
        self.e(statement.update)
      }

      self.statement(statement.body)
      self.vm.decrease()

      self.tc = initialTC
    } elif it.isMainDeclaration() {
      statement := it.asMainDeclaration()
      initialReturnType := self.state.returnType

      if it.hasParent() {
        self.raise(errors.E1042(), it.start, it.end)
      }

      self.state.returnType = Type.opt(self.tm.get("void"))
      self.statement(statement.body)
      self.state.returnType = initialReturnType
    } elif it.isObjectDeclaration() {
      statement := it.asObjectDeclaration()
      initialTmSelf := self.tm.getSelf()
      initialStateSelf := self.state.selfType
      t := self.tm.get(statement.name.name)

      self.state.selfType = Type.opt(t)
      self.tm.setSelf(Type.opt(t))
      self.analyze(ref statement.body)
      self.state.selfType = initialStateSelf
      self.tm.setSelf(initialTmSelf)
    } elif it.isObjectDeclarationMethod() {
      statement := it.asObjectDeclarationMethod()
      initialStateReturnType := self.state.returnType
      selfType := self.state.selfType as ref Type.Type
      property := selfType.get(statement.name.name)

      if !property.t.isMethod() {
        return
      }

      t := property.t.asMethod()

      self.vm.increase()
      self.functionParameters(statement.parameters)
      self.state.returnType = Type.opt(t.returnType)

      if statement.body != nil {
        if (
          !Type.match(t.returnType, self.tm.get("void")) &&
          !statement.body.isDeadEnd() &&
          statement.returnType != nil
        ) {
          self.raise(errors.E1061(), statement.returnType.start, statement.returnType.end)
        }

        self.statement(statement.body)
      }

      self.state.returnType = initialStateReturnType
      self.vm.decrease()
    } elif it.isObjectDeclarationProperty() {
      // todo check that property not referencing self object causing circular object
      statement := it.asObjectDeclarationProperty()

      propertyType := statement.t == nil
        ? self.e(statement.initializer as Parser.Expression, withMutable: statement.mutable)
        : self.t(statement.t)

      if Type.match(propertyType, self.tm.get("void")) {
        if statement.t == nil {
          initializer := statement.initializer as Parser.Expression
          self.raise(errors.E1017(), initializer.start, initializer.end)
        } else {
          self.raise(errors.E1017(), statement.t.start, statement.t.end)
        }
      }

      if statement.initializer != nil {
        self.raise(errors.E1056(), statement.initializer.start, statement.initializer.end)
      }

      if statement.constant {
        self.raise(errors.E1055(), statement.name.start, statement.name.end)
      }
    } elif it.isReturn() {
      statement := it.asReturn()

      if !it.hasFunctionOrMainParent() {
        self.raise(errors.E1057(), it.start, it.end)
      }

      returnType := statement.expression == nil
        ? self.tm.get("void")
        : self.e(statement.expression, self.state.returnType)

      if self.state.returnType != nil {
        if !Type.match(self.state.returnType, returnType) {
          self.raise(errors.E1005(self.state.returnType.toString(), returnType.toString()), it.start, it.end)
        }
      }
    } elif it.isThrow() {
      statement := it.asThrow()

      if !it.hasParent() {
        self.raise(errors.E1047(), it.start, it.end)
      }

      t := self.e(statement.expression)

      if (
        !t.isObject() ||
        !t.has(0) ||
        !t.get(0).name != "message" ||
        !Type.match(t.get(0).t, self.tm.get("str")) ||
        !t.has(1) ||
        !t.get(1).name != "stack" ||
        !Type.match(t.get(1).t, self.tm.get("str"))
      ) {
        self.raise(errors.E1062(), statement.expression.start, statement.expression.end)
      }
    } elif it.isTry() {
      // todo at least one handler
      // todo catch handle param can't be mutable
      // todo E1029 - Catch block can only catch object with first field string `message` and second field string `stack`
      // todo E1022 - Void type can only be used as function return type
      statement := it.asTry()

      if !it.hasParent() {
        self.raise(errors.E1048(), it.start, it.end)
      }
    } elif it.isVariableDeclaration() {
      statement := it.asVariableDeclaration()

      if self.vm.has(statement.name.name) {
        self.raise(errors.E1000(statement.name.name), statement.name.start, statement.name.end)
      }

      varType := statement.t == nil
        ? self.e(statement.initializer as Parser.Expression, withMutable: statement.mutable)
        : self.t(statement.t)

      if Type.match(varType, self.tm.get("void")) {
        if statement.t == nil {
          initializer := statement.initializer as Parser.Expression
          self.raise(errors.E1017(), initializer.start, initializer.end)
        } else {
          self.raise(errors.E1017(), statement.t.start, statement.t.end)
        }
      }

      if statement.t != nil && statement.initializer != nil {
        initializerType := self.e(statement.initializer, Type.opt(varType), withMutable: statement.mutable)

        if !Type.match(varType, initializerType) {
          self.raise(errors.E1005(initializerType.toString(), varType.toString()), statement.initializer.start, statement.initializer.end)
        }
      }

      if statement.initializer == nil && varType.isRequired() {
        self.raise(errors.E1040(statement.name.name, varType.toString()), statement.name.start, statement.name.end)
      }

      self.vm.add(statement.name.name, varType, statement.mutable || self.state.loopInit)

      if statement.constant && it.hasParent() {
        self.raise(errors.E1038(), statement.name.start, statement.name.end)
      } elif !statement.constant && !statement.mutable && !it.hasParent() {
        self.raise(errors.E1039(), statement.name.start, statement.name.end)
      }
    }
  }

  fn t (mut self: ref Self, it: Parser.Type) ref Type.Type {
    if it.isArray() {
      t := it.asArray()
      return self.tm.createArray(self.t(t.elementType))
    } elif it.isFunction() {
      t := it.asFunction()
      mut parameterNames: str[]
      mut parameters: Type.TypeParameter[]
      parametersLen := t.parameters.len

      loop i := 0; i < parametersLen; i++ {
        parameter := t.parameters[i]

        if parameter.name != nil {
          if parameterNames.contains(parameter.name.name) {
            self.raise(errors.E1054(parameter.name.name), parameter.name.start, parameter.name.end)
          }
        }

        mut t := self.t(parameter.t)

        if Type.match(t, self.tm.get("void")) {
          self.raise(errors.E1017(), parameter.t.start, parameter.t.end)
        }

        if parameter.variadic {
          t = self.tm.createArray(t)
        }

        parameters.push(Type.TypeParameter{
          name: parameter.name == nil ? nil : parameter.name.name,
          t: parameter.variadic ? self.tm.createArray(self.t(parameter.t)) : self.t(parameter.t),
          mutable: parameter.mutable,
          required: !parameter.variadic,
          variadic: parameter.variadic
        })
      }

      return self.tm.createFunction(t.asynchronous, parameters, self.t(t.returnType))
    } elif it.isIdentifier() {
      t := it.asIdentifier()

      if !self.tm.has(t.name.name) {
        self.raise(errors.E1001(t.name.name), t.name.start, t.name.end)
        return self.tm.get("any")
      }

      return self.tm.get(t.name.name)
    } elif it.isMap() {
      t := it.asMap()
      // todo void can only be used as a standalone type
      return self.tm.createMap(self.t(t.keyType), self.t(t.valueType))
    } elif it.isMember() {
      t := it.asMember()
      leftType := self.t(t.t)

      if !leftType.isNamespace() {
        self.raise(errors.E1022(leftType.toString()), t.name.start, t.name.end)
        return self.tm.get("any")
      } elif !leftType.has(t.name.name) {
        self.raise(errors.E1023(leftType.toString(), t.name.name), t.name.start, t.name.end)
        return self.tm.get("any")
      }

      property := leftType.get(t.name.name)
      return property.t
    } elif it.isOptional() {
      t := it.asOptional()
      return self.tm.createOptional(self.t(t.t))
    } elif it.isParenthesized() {
      t := it.asParenthesized()
      return self.t(t.t)
    } elif it.isReference() {
      t := it.asReference()
      return self.tm.createReference(self.t(t.t))
    } elif it.isUnion() {
      // todo void can only be used as a standalone type
      t := it.asUnion()
      mut types: (ref Type.Type)[]
      typesLen := t.types.len

      loop i := 0; i < typesLen; i++ {
        types.push(self.t(t.types[i]))
      }

      return self.tm.createUnion(types)
    }

    throw error_NewError("Tried analyzing unknown type")
  }

  fn typeCast (mut self: ref Self, it: Parser.Expression) TypeCastResult {
    initialTC := self.tc
    mut consequent: (ref Type.Type)[str]
    mut alternate: (ref Type.Type)[str]

    if it.isBinary() {
      expression := it.asBinary()

      if expression.operator.t == .OpAmpAmp || expression.operator.t == .OpPipePipe {
        leftTypeCastResult := self.typeCast(expression.left)

        if expression.operator.t == .OpAmpAmp {
          self.tc.merge(leftTypeCastResult.consequent)
        }

        rightTypeCastResult := self.typeCast(expression.right)

        if expression.operator.t == .OpAmpAmp {
          consequent.merge(leftTypeCastResult.consequent)
          consequent.merge(rightTypeCastResult.consequent)
          alternate.merge(leftTypeCastResult.alternate)
          alternate.merge(rightTypeCastResult.alternate)
        } else {
          consequent.merge(rightTypeCastResult.consequent)
          alternate.merge(rightTypeCastResult.alternate)
        }
      } elif expression.operator.t == .OpEqEq || expression.operator.t == .OpExclEq {
        if (
          (expression.left.isAccess() && expression.right.isNilLiteral()) ||
          (expression.right.isAccess() && expression.left.isNilLiteral())
        ) {
          left := expression.left.isAccess() ? expression.left : expression.right
          leftType := Type.unwrap(self.eNice(left), withOptional: false)

          if left.isAccess() && leftType.isOptional() {
            code := Parser.stringifyExpression(left)
            t := leftType.asOptional()

            if expression.operator.t == .OpEqEq {
              alternate.set(code, t.t)
            } else {
              consequent.set(code, t.t)
            }
          }
        }
      }
    } elif it.isIs() {
      expression := it.asIs()

      if expression.expression.isAccess() {
        expressionType := self.eNice(expression.expression)

        if Type.match(expressionType, self.tm.get("any")) || expressionType.isOptional() || expressionType.isUnion() {
          t := self.t(expression.t)
          code := Parser.stringifyExpression(expression.expression)
          consequent.set(code, t)

          if expressionType.isUnion() {
            alternate.set(code, self.tm.unionSub(expressionType, t))
          }
        }
      }
    }

    self.tc = initialTC

    return TypeCastResult{
      consequent: consequent,
      alternate: alternate
    }
  }
}

export fn analyze (f: ref Parser.File) str[] {
  if f.hasErrors {
    return f.errors
  }

  mut analyzer := Analyzer{}

  analyzer.reader = Parser.Reader_init(f.path == "anonymous" ? f.content : f.path)
  analyzer.tm.init()
  analyzer.vm.init(ref analyzer.tm)
  analyzer.analyze(ref f.program.body)

  return analyzer.errors
}

main {
  args := process_args
  mut f := Parser.parse(args[1])
  Parser.interconnect(ref f)
  errors := analyze(ref f)

  if errors.len != 0 {
    print()

    loop i := 0; i < errors.len; i++ {
      if i != 0 { print(to: "stderr") }
      print(errors[i] as str, terminator: "", to: "stderr")
    }

    process_exit(1)
  }
}
