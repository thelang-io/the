Planning Board

=====

```the
const a := "text" // For every variable referenced inside declaration create ARC
fn test () str { return a }
main {
  b := test()
}
```

=====

```the
obj Test {}
fn createTest () ref Test {
  t := Test{}
  return ref t // For every `ref` mark variable as ARC
  // For every return of ARC, create a copy
}
main {
  test := createTest()
}
```

=====

```the
obj Counter {
  mut val: int
  fn count (mut self: ref Self) int {
    return self.val++
  }
}
main {
  mut count := () -> int { return 0 }
  if true {
    mut t := Test{}
    count = t.count
  }
  count() // How to pass here reference to self of `t` from above scope?

  // 1. Storing copy of method on instance with a self param bound to it
  // 2. Creating a closure that references self prop `count = () -> void { return t.count() }
  // 3. Disable method to function assignment, only if function exactly matches
}
```

=====

```the
main {
  mut arr := [0, 1, 2]
  mut opt := ref arr[0] // arc_arc_int
  mut opt2 := arr[0] // arc_int_copy

  // what if every ref will just be converted to arc?
}
```

=====

```the
obj Test { count: int }
main {
  a := 0
  mut refInt := ref a
  loop {
    mut t := Test{}
    refInt = ref t.count // All references should be mutable
    // Referencing a field of variable should mark variable as referenced
    break
  }
  refInt++
}
```

=====

```the
obj Test { count: int }
main {
  a := 0
  test := () -> int {
    return a
    // Should create a copy of arc when returning it from a procedure
  }
  test()
}
```

// Problem if all refs are ARC, then how's that different from referenced variables?
// There's no difference for a user but codegen need to be able to differentiate between ref and ARC variables
// How codegen will know that certain type is actually referenced
// Should there be an ARC to an ARC?
// Refuse ability to have non-ref copies of self, should be treated as a param instead
