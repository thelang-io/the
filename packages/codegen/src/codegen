/*!
 * Copyright (c) Aaron Delasy
 * Licensed under the MIT License
 */

import * as Analyzer from "the/analyzer"
import * as AST from "the/c"
import * as Parser from "the/parser"
import BUILTIN_ENTITIES from "./builtin-entities"
import BlockData, BlockDataContext, BlockDataVariable from "./block-data"
import
  createASTPropertyAccess,
  declarationByDependency,
  expressionIsBuiltinMethod,
  expressionResolve,
  expressionShouldBeAllocatedAfter,
  expressionShouldBeAllocatedBefore,
  expressionShouldBeCopied,
  expressionShouldBeFreed,
  normalizeBlock,
  statementHasPrecedingNonDeclaration,
  statementIsMacroInvocation,
  statementIsMacroInvocationDeclare,
  statementIsMacroInvocationForwardDeclare,
  statementMacroInvocationCallee,
  typeIsSimple,
  typeParameterId,
  typeSafeForTernaryAlternate,
  typeSafeForVaArg,
  typeShouldBeAllocated,
  typeShouldBeFreed
from "./helpers"
import sortStrAsc from "./utils"

// TODO: implement ObjectDeclarationMethod, disallow assigning of methods to functions
// TODO: implement ClosureExpression
// TODO: test FunctionType
// TODO: test MainDeclaration
// TODO: test CallExpression

// TODO: implement EnumDeclaration statement
// TODO: implement MemberAccess expression
// TODO: implement TypeAliasDeclaration statement

// TODO: test VariableDeclaration statement
// TODO: test expressions with types other than primitive
// TODO: test If statement
// TODO: test Loop statement
// TODO: add more tests for Loop statement with other types

// TODO: implement Throw statement
// TODO: implement Try statement
// TODO: error object needs to move message and stack properties upfront

// TODO: implement ImportDeclaration statement
// TODO: implement ExportDeclaration statement
// TODO: implement ExportNamedDeclaration statement
// TODO: implement NamespaceMember type

// TODO: implement async functions
// TODO: implement await expression

// TODO: automatic reference counter and object reference cycles
// TODO: check whether all tests are transferred from old codegen

export obj CodegenAPIBuiltin {
  mut d4Any: bool
  mut d4Arc: bool
  mut d4Array: bool
  mut d4Bool: bool
  mut d4Byte: bool
  mut d4Char: bool
  mut d4Error: bool
  mut d4Fn: bool
  mut d4Globals: bool
  mut d4Macro: bool
  mut d4Map: bool
  mut d4Number: bool
  mut d4Object: bool
  mut d4Optional: bool
  mut d4Reference: bool
  mut d4Rune: bool
  mut d4Safe: bool
  mut d4String: bool
  mut d4Union: bool
  mut stdarg: bool
  mut stdbool: bool
  mut stddef: bool
  mut stdint: bool
  mut stdio: bool
  mut stdlib: bool
  mut wchar: bool
}

export type GenerateReturnType = AST.CStatement | AST.CStatement[]

export obj CodegenEntity {
  mut active: bool
  mut activated: bool
  mut name: str
  mut codeName: str
  mut context: any
  mut generate: (mut self: ref Codegen, entity: ref CodegenEntity) -> GenerateReturnType
  mut result: GenerateReturnType?
}

export obj CodegenFunctionContext {
  contextTypeName: str
  functorTypeName: str
  parameters: Parser.FunctionParameter[]
  body: Parser.Statement
  t: ref Analyzer.Type
  variables: BlockDataVariable[]
}

export obj Codegen {
  mut analyzer: ref Analyzer.Analyzer
  mut builtin: CodegenAPIBuiltin
  mut blockData: BlockData
  mut entities: CodegenEntity[]
  mut flags: str[]
  mut globalStatements: AST.CStatement[]
  mut lastTypeId: int
  mut lastVarId: int
  mut mainStatements: AST.CStatement[]
  mut release: bool
  mut returnType: (ref Analyzer.Type)?
  mut sanitize: bool
  mut statements: AST.CStatement[]
  mut typeDefs: int[str]

  fn init (mut self: ref Self) {
    self.blockData.init()
  }

  fn generate (mut self: ref Self) {
    mut file := self.analyzer.files.last()
    self.blockData.increase()
    statements := self._generateBlockBody(ref file.f.program.body)
    statements.merge(self.mainStatements)
    self.mainStatements = statements
    self._assemble()
  }

  fn getFlags (self: ref Self) str {
    mut extraFlags: str[]

    if (
      self.builtin.d4Any ||
      self.builtin.d4Arc ||
      self.builtin.d4Array ||
      self.builtin.d4Bool ||
      self.builtin.d4Byte ||
      self.builtin.d4Char ||
      self.builtin.d4Error ||
      self.builtin.d4Fn ||
      self.builtin.d4Globals ||
      self.builtin.d4Macro ||
      self.builtin.d4Map ||
      self.builtin.d4Number ||
      self.builtin.d4Object ||
      self.builtin.d4Optional ||
      self.builtin.d4Reference ||
      self.builtin.d4Rune ||
      self.builtin.d4Safe ||
      self.builtin.d4String ||
      self.builtin.d4Union
    ) {
      extraFlags.push("-ld4")
    }

    if !self.release && self.sanitize && os_NAME == "Windows" {
      extraFlags.push("/f" + "sanitize=address")
    } elif !self.release && self.sanitize {
      extraFlags.push("-f" + "sanitize=address")
    }

    if self.release {
      extraFlags.push("-O3")
    } else {
      extraFlags.push("-O0 -g")
    }

    result := [
      "-W" + "all",
      "-W" + "error",
      "-W" + "extra",
      "-pedantic-errors",
      "-Wno-parentheses-equality",
      "-Wno-strict-prototypes",
      "-Wno-unused-but-set-variable",
      "-Wno-unused-parameter",
      "-Wno-unused-value",
      "-Wno-unused-variable",
    ].concat(extraFlags).join(" ")

    return result.empty ? "" : (" " + result)
  }

  fn getAddressSanitizerFlags () str {
    return [
      "abort_on_error=0",
      "exitcode=255",
      "detect_invalid_pointer_pairs=2",
      "detect_leaks=1",
      "detect_stack_use_after_return=1",
      "print_suppressions=0",
      "track_origins=1",
    ].join(":")
  }

  fn getLeakSanitizerFlags () str {
    return "suppressions=lsan.supp"
  }

  fn stringify (self: ref Self) str {
    mut result := ""
    l := self.statements.len

    loop i := 0; i < l; i++ {
      result += self.statements[i].stringify()
    }

    return result
  }

  fn _ (mut self: ref Self, name: str) str {
    if self._hasEntity(name, withBuiltin: false) {
      mut item := self._getEntity(name)

      if !item.active {
        item.active = true
      }

      return item.codeName
    } elif BUILTIN_ENTITIES.get("stdarg").contains(name) {
      self.builtin.stdarg = true
    } elif BUILTIN_ENTITIES.get("stdbool").contains(name) {
      self.builtin.stdbool = true
    } elif BUILTIN_ENTITIES.get("stddef").contains(name) {
      self.builtin.stddef = true
    } elif BUILTIN_ENTITIES.get("stdio").contains(name) {
      self.builtin.stdio = true
    } elif BUILTIN_ENTITIES.get("stdint").contains(name) {
      self.builtin.stdint = true
    } elif BUILTIN_ENTITIES.get("wchar").contains(name) {
      self.builtin.wchar = true
    } elif BUILTIN_ENTITIES.get("d4Any").contains(name) {
      self.builtin.d4Any = true
    } elif BUILTIN_ENTITIES.get("d4Arc").contains(name) {
      self.builtin.d4Arc = true
    } elif BUILTIN_ENTITIES.get("d4Array").contains(name) {
      self.builtin.d4Array = true
    } elif BUILTIN_ENTITIES.get("d4Bool").contains(name) {
      self.builtin.d4Bool = true
    } elif BUILTIN_ENTITIES.get("d4Byte").contains(name) {
      self.builtin.d4Byte = true
    } elif BUILTIN_ENTITIES.get("d4Char").contains(name) {
      self.builtin.d4Char = true
    } elif BUILTIN_ENTITIES.get("d4Error").contains(name) {
      self.builtin.d4Error = true
    } elif BUILTIN_ENTITIES.get("d4Fn").contains(name) {
      self.builtin.d4Fn = true
    } elif BUILTIN_ENTITIES.get("d4Globals").contains(name) {
      self.builtin.d4Globals = true
    } elif BUILTIN_ENTITIES.get("d4Macro").contains(name) {
      self.builtin.d4Macro = true
    } elif BUILTIN_ENTITIES.get("d4Map").contains(name) {
      self.builtin.d4Map = true
    } elif BUILTIN_ENTITIES.get("d4Number").contains(name) {
      self.builtin.d4Number = true
    } elif BUILTIN_ENTITIES.get("d4Object").contains(name) {
      self.builtin.d4Object = true
    } elif BUILTIN_ENTITIES.get("d4Optional").contains(name) {
      self.builtin.d4Optional = true
    } elif BUILTIN_ENTITIES.get("d4Reference").contains(name) {
      self.builtin.d4Reference = true
    } elif BUILTIN_ENTITIES.get("d4Rune").contains(name) {
      self.builtin.d4Rune = true
    } elif BUILTIN_ENTITIES.get("d4Safe").contains(name) {
      self.builtin.d4Safe = true
    } elif BUILTIN_ENTITIES.get("d4String").contains(name) {
      self.builtin.d4String = true
    } elif BUILTIN_ENTITIES.get("d4Union").contains(name) {
      self.builtin.d4Union = true
    } else {
      throw error_NewError("Tried activating unknown entity '" + name + "'")
    }

    return name
  }

  fn _allocateExpression (mut self: ref Self, t: ref Analyzer.Type, expression: AST.CExpression, arc := false) AST.CExpression {
    tmpVar := self._tmpVar()
    tmpVarId := AST.createIdentifier(tmpVar)

    self.blockData.addSetup(
      AST.createVariableDeclaration(
        AST.createType(self._type(t, arc: arc)),
        tmpVar,
        self._defaultInitializerExpression(t),
      ),
    )

    self.blockData.addTeardown(
      AST.createExpressionStatement(self._functionFree(t, tmpVarId)),
    )

    return AST.createAssignmentExpression(tmpVarId, "=", expression)
  }

  fn _assemble (mut self: ref Self) {
    loop {
      len := self.entities.len
      mut activated := 0

      loop i := 0; i < len; i++ {
        // TODO: remove after v1
        oldEntity := self.entities[i]

        if !oldEntity.active || oldEntity.activated {
          continue
        }

        result := oldEntity.generate(self, oldEntity)

        mut entity := self.entities[i]
        entity.result = result
        entity.activated = true
        activated++
      }

      if activated == 0 {
        break
      }
    }

    mut defineStatements: AST.CStatement[]
    mut macroInvocationDeclareStatements: AST.CStatement[]
    mut macroInvocationForwardDeclareStatements: AST.CStatement[]
    mut macroInvocationDefineStatements: AST.CStatement[]
    mut statements: AST.CStatement[]

    loop i := 0; i < self.entities.len; i++ {
      entity := self.entities[i]

      if !entity.active || entity.result == nil {
        continue
      }

      result := entity.result as GenerateReturnType
      resultStatements := (result is AST.CStatement) ? [result] : result

      loop j := 0; j < resultStatements.len; j++ {
        item := resultStatements[j]

        if item.isDefineDirective() {
          defineStatements.push(item)
        } elif statementIsMacroInvocation(item) {
          if statementIsMacroInvocationForwardDeclare(item) {
            macroInvocationForwardDeclareStatements.push(item)
          } elif statementIsMacroInvocationDeclare(item) {
            macroInvocationDeclareStatements.push(item)
          } else {
            macroInvocationDefineStatements.push(item)
          }
        } else {
          statements.push(item)
        }
      }
    }

    if self.builtin.d4Any { self.statements.push(AST.createIncludeDirective("d4/any.h")) }
    if self.builtin.d4Arc { self.statements.push(AST.createIncludeDirective("d4/arc.h")) }
    if self.builtin.d4Array { self.statements.push(AST.createIncludeDirective("d4/array.h")) }
    if self.builtin.d4Bool { self.statements.push(AST.createIncludeDirective("d4/bool.h")) }
    if self.builtin.d4Byte { self.statements.push(AST.createIncludeDirective("d4/byte.h")) }
    if self.builtin.d4Char { self.statements.push(AST.createIncludeDirective("d4/char.h")) }
    if self.builtin.d4Error { self.statements.push(AST.createIncludeDirective("d4/error.h")) }
    if self.builtin.d4Fn { self.statements.push(AST.createIncludeDirective("d4/fn.h")) }
    if self.builtin.d4Globals { self.statements.push(AST.createIncludeDirective("d4/globals.h")) }
    if self.builtin.d4Macro { self.statements.push(AST.createIncludeDirective("d4/macro.h")) }
    if self.builtin.d4Map { self.statements.push(AST.createIncludeDirective("d4/map.h")) }
    if self.builtin.d4Number { self.statements.push(AST.createIncludeDirective("d4/number.h")) }
    if self.builtin.d4Object { self.statements.push(AST.createIncludeDirective("d4/object.h")) }
    if self.builtin.d4Optional { self.statements.push(AST.createIncludeDirective("d4/optional.h")) }
    if self.builtin.d4Reference { self.statements.push(AST.createIncludeDirective("d4/reference.h")) }
    if self.builtin.d4Rune { self.statements.push(AST.createIncludeDirective("d4/rune.h")) }
    if self.builtin.d4Safe { self.statements.push(AST.createIncludeDirective("d4/safe.h")) }
    if self.builtin.d4String { self.statements.push(AST.createIncludeDirective("d4/string.h")) }
    if self.builtin.d4Union { self.statements.push(AST.createIncludeDirective("d4/union.h")) }

    if self.builtin.stdarg { self.statements.push(AST.createIncludeDirective("stdarg.h")) }
    if self.builtin.stdbool { self.statements.push(AST.createIncludeDirective("stdbool.h")) }
    if self.builtin.stddef { self.statements.push(AST.createIncludeDirective("stddef.h")) }
    if self.builtin.stdio { self.statements.push(AST.createIncludeDirective("stdio.h")) }
    if self.builtin.stdint { self.statements.push(AST.createIncludeDirective("stdint.h")) }
    if self.builtin.stdlib { self.statements.push(AST.createIncludeDirective("stdlib.h")) }
    if self.builtin.wchar { self.statements.push(AST.createIncludeDirective("wchar.h")) }

    self.statements.merge(defineStatements)
    self.statements.merge(macroInvocationForwardDeclareStatements)
    self.statements.merge(macroInvocationDeclareStatements)
    self.statements.merge(macroInvocationDefineStatements)
    self.statements.merge(self.globalStatements)
    self.statements.merge(statements)

    dataContextBlock := self.blockData.decrease()
    mut finalMainStatements: AST.CStatement[]

    finalMainStatements.merge(dataContextBlock.setup)
    finalMainStatements.merge(self.mainStatements)
    finalMainStatements.merge(dataContextBlock.teardown)

    self.statements.push(
      AST.createFunctionDeclaration(
        AST.createType("int"),
        "main",
        [AST.createFunctionParameter(AST.createType("void"))],
        AST.createCompoundStatement(finalMainStatements),
      ),
    )
  }

  fn _declareStatement (mut self: ref Self, item: ref Parser.Statement) bool {
    if item.isFunctionDeclaration() {
      self._declareFunction(item)
    } elif item.isMainDeclaration() {
      self._declareMain(item)
    } elif item.isObjectDeclaration() {
      self._declareObject(item)
    }
  }

  fn _declareMain (mut self: ref Codegen, item: ref Parser.Statement) void {
    statement := item.asMainDeclaration()
    statementBody := statement.body.asBlock()
    tm := self._tm()

    self.blockData.increase()
    self.returnType = tm.get("int")
    self.mainStatements = self._generateBlockBody(ref statementBody.body)
    self.returnType = nil
    dataContextBlock := self.blockData.decrease()
    self.blockData.currentMerge(dataContextBlock.setup, dataContextBlock.teardown)

    if self.blockData.usedValueVariable() {
      valueName := self.blockData.getValueVariable()
      self.blockData.addSetup(AST.createVariableDeclaration(AST.createType("int"), valueName, AST.createLiteral("0")))
    }

    if self.blockData.usedReturnVariable() {
      returnName := self.blockData.getReturnVariable()

      self.blockData.addSetup(
        AST.createVariableDeclaration(
          AST.createType("unsigned char"),
          returnName,
          AST.createLiteral("0"),
        ),
      )
    }

    if dataContextBlock.usedValueVariable {
      valueName := dataContextBlock.valueVariable()
      self.mainStatements.push(AST.createReturnStatement(AST.createIdentifier(valueName)))
    }
  }

  fn _declareFunction (mut self: ref Codegen, item: ref Parser.Statement) void {
    statement := item.asFunctionDeclaration()

    if !(item.context is Analyzer.FunctionDeclarationContext) {
      throw error_NewError("Expected FunctionDeclaration context")
    }

    context := item.context as Analyzer.FunctionDeclarationContext

    self._generateFunctionType(context.var.t)
    self.blockData.setFunction(statement.name.name, context.var.t)
  }

  fn _declareObject (mut self: ref Codegen, item: ref Parser.Statement) void {
    statement := item.asObjectDeclaration()

    if !(item.context is Analyzer.ObjectDeclarationContext) {
      throw error_NewError("Expected ObjectDeclaration context")
    }

    context := item.context as Analyzer.ObjectDeclarationContext
    self._generateObjectType(context.selfType)
  }

  fn _defaultInitializerExpression (mut self: ref Self, it: ref Analyzer.Type) AST.CExpression {
    if it.isAlias() {
      t := it.asAlias()
      return self._defaultInitializerExpression(t.t)
    } elif it.name == "any" {
      return AST.createInitializerListExpression([
        AST.createLiteral("-1"),
        AST.createIdentifier(self._("NULL")),
        AST.createIdentifier(self._("NULL")),
        AST.createIdentifier(self._("NULL")),
        AST.createIdentifier(self._("NULL")),
        AST.createIdentifier(self._("NULL")),
      ])
    }

    return self._defaultInitializerDeclaration(it)
  }

  fn _defaultInitializerDeclaration (mut self: ref Self, it: ref Analyzer.Type, arc := false) AST.CExpression {
    if arc {
      return AST.createCastExpression(AST.createType(self._type(it, arc: true)), AST.createInitializerListExpression([
        AST.createLiteral("0"),
        AST.createIdentifier(self._("NULL")),
      ]))
    } elif it.isAlias () {
      t := it.asAlias()
      return self._defaultInitializerDeclaration(t.t)
    } elif it.name == "any" {
      return AST.createCastExpression(AST.createType(self._("d4_any_t")), AST.createInitializerListExpression([
        AST.createLiteral("-1"),
        AST.createIdentifier(self._("NULL")),
        AST.createIdentifier(self._("NULL")),
        AST.createIdentifier(self._("NULL")),
        AST.createIdentifier(self._("NULL")),
        AST.createIdentifier(self._("NULL")),
      ]))
    } elif it.name == "bool" {
      return AST.createIdentifier(self._("false"))
    } elif it.name == "char" {
      return AST.createLiteral("'\\0'")
    } elif it.name == "rune" {
      return AST.createLiteral("L'\\0'")
    } elif it.name == "str" {
      return AST.createIdentifier(self._("d4_str_empty_val"))
    } elif it.isArray() {
      return AST.createCastExpression(AST.createType(self._type(it)), AST.createInitializerListExpression([
        AST.createIdentifier(self._("NULL")),
        AST.createLiteral("0"),
      ]))
    } elif it.isFunction() || it.isMethod() {
      return AST.createCastExpression(AST.createType(self._type(it)), AST.createInitializerListExpression([
        AST.createIdentifier(self._("d4_str_empty_val")),
        AST.createIdentifier(self._("NULL")),
        AST.createIdentifier(self._("NULL")),
        AST.createIdentifier(self._("NULL")),
        AST.createIdentifier(self._("NULL")),
      ]))
    } elif it.isMap() {
      return AST.createCastExpression(AST.createType(self._type(it)), AST.createInitializerListExpression([
        AST.createIdentifier(self._("NULL")),
        AST.createLiteral("0"),
        AST.createLiteral("0"),
      ]))
    } elif it.isCustomObject() {
      mut args: AST.CExpression[]

      loop i := 0; i < it.properties.len; i++ {
        property := it.properties[i]

        if property.builtin || property.t.isMethod() {
          continue
        }

        args.push(self._defaultInitializerDeclaration(property.t))
      }

      return AST.createCastExpression(AST.createType(self._type(it)), AST.createInitializerListExpression(args))
    } elif it.isOptional() || it.isReference() {
      return AST.createIdentifier(self._("NULL"))
    } elif it.isUnion() {
      return AST.createCastExpression(AST.createType(self._type(it)), AST.createInitializerListExpression([
        AST.createLiteral("-1"),
        AST.createInitializerListExpression([
          AST.createLiteral("0"),
        ]),
      ]))
    } elif it.isNumber() {
      return AST.createLiteral("0")
    }

    throw error_NewError("Tried default initializer variable declaration on unknown type '" + it.toString() + "'")
  }

  fn _defineFunction (mut self: ref Codegen, name: Parser.Identifier, parameters: Parser.FunctionParameter[], body: Parser.Statement, t: ref Analyzer.Type, context: (ref Analyzer.Var)[]) AST.CStatement {
    variableName := self.blockData.getVariableName(name.name)
    cType := AST.createType(self._type(t))

    self.globalStatements.push(AST.createVariableDeclaration(cType, variableName))

    self.blockData.addTeardown(
      AST.createExpressionStatement(
        self._functionFree(t, AST.createIdentifier(variableName)),
      ),
    )

    entityContext := CodegenFunctionContext{
      contextTypeName: variableName + "_ctx_t",
      functorTypeName: variableName + "_func",
      parameters: parameters,
      body: body,
      t: t,
      variables: self.blockData.getVariables(context),
    }

    if !entityContext.variables.empty {
      self.entities.push(CodegenEntity{
        name: entityContext.contextTypeName,
        codeName: entityContext.contextTypeName,
        context: entityContext,
        generate: (mut self: ref Codegen, entity: ref CodegenEntity) -> GenerateReturnType {
          ctx := entity.context as CodegenFunctionContext
          mut members: AST.CStatement[]

          loop i := 0; i < ctx.variables.len; i++ {
            contextVariable := ctx.variables[i]

            members.push(
              AST.createStructureMemberDeclaration(
                AST.createType(self._type(contextVariable.t, arc: contextVariable.referenced)),
                contextVariable.name,
              ),
            )
          }

          return AST.createTypedefDeclaration(
            AST.createStructureDeclaration(nil, AST.createCompoundStatement(members), terminated: false),
            entity.codeName,
          )
        }
      })
    }

    self.entities.push(CodegenEntity{
      name: entityContext.functorTypeName,
      codeName: entityContext.functorTypeName,
      context: entityContext,
      generate: (mut self: ref Codegen, entity: ref CodegenEntity) -> GenerateReturnType {
        ctx := entity.context as CodegenFunctionContext
        // TODO: remove after v1
        // Codegen entities are reallocated in the process, reference to entity becomes invalid
        entityCodeName := entity.codeName
        statementBody := ctx.body.asBlock()
        returnType := ctx.t.getReturnType()

        initialLastVarId := self.lastVarId
        initialReturnType := self.returnType

        self.blockData.increase(.Fn)
        self.blockData.currentMergeVariables(ctx.variables)

        self.lastVarId = 0
        self.returnType = returnType

        cParameters := AST.createIdentifier("params")
        mut parameters: AST.CFunctionParameter[]

        if !ctx.variables.empty {
          cContextType := AST.createType(self._(ctx.contextTypeName), reference: true)

          parameters.push(
            AST.createFunctionParameter(cContextType, "ctx"),
          )
        } else {
          parameters.push(AST.createFunctionParameter(AST.createType("void", reference: true), "ctx"))
        }

        if ctx.t.hasParameters() || ctx.t.hasSelfParam() {
          cParametersType := AST.createType(self._type(ctx.t, "_params_t"), reference: true)

          parameters.push(
            AST.createFunctionParameter(cParametersType, "params"),
          )
        } else {
          parameters.push(AST.createFunctionParameter(AST.createType("void", reference: true), "params"))
        }

        loop i := 0; i < ctx.variables.len; i++ {
          contextVariable := ctx.variables[i]

          self.blockData.addSetup(
            AST.createVariableDeclaration(
              AST.createType(self._type(contextVariable.t, arc: contextVariable.referenced)),
              contextVariable.fullName(),
              AST.createPropertyAccessExpression(AST.createIdentifier("ctx"), contextVariable.name, pointed: true),
            ),
          )

          self.blockData.addTeardown(
            AST.createExpressionStatement(
              self._functionFree(
                contextVariable.t,
                AST.createIdentifier(contextVariable.fullName()),
                arc: contextVariable.referenced,
              ),
            ),
          )
        }

        if ctx.t.hasSelfParam() {
          methodType := ctx.t.asMethod()
          selfCodeName := self.blockData.setVariable(methodType.selfName, methodType.selfType)

          self.blockData.addSetup(
            AST.createVariableDeclaration(
              AST.createType(self._type(methodType.selfType)),
              selfCodeName,
              AST.createPropertyAccessExpression(cParameters, "self"),
            ),
          )
        }

        if ctx.t.hasParameters() {
          typeParameters := ctx.t.getParameters()

          loop i := 0; i < ctx.parameters.len; i++ {
            parameter := ctx.parameters[i]
            typeParameter := typeParameters[i]
            parameterType := self._type(typeParameter.t)
            parameterCodeName := self.blockData.setVariable(parameter.name.name, typeParameter.t)

            mut initializer := AST.createPropertyAccessExpression(cParameters, "n" + i.str(), true)

            if parameter.initializer != nil {
              parameterInitializer := parameter.initializer

              initializer = AST.createConditionalExpression(
                AST.createBinaryExpression(
                  AST.createPropertyAccessExpression(cParameters, "o" + i.str(), true),
                  "==",
                  AST.createLiteral("1"),
                ),
                initializer,
                self._generateExpression(ref parameterInitializer),
              )
            }

            self.blockData.addSetup(
              AST.createVariableDeclaration(
                AST.createType(parameterType),
                parameterCodeName,
                initializer,
              ),
            )
          }
        }

        statements := self._generateBlockBody(ref statementBody.body)

        if returnType.name != "void" && self.blockData.usedValueVariable() {
          valueName := self.blockData.getValueVariable()
          self.blockData.addSetup(AST.createVariableDeclaration(AST.createType(self._type(returnType)), valueName))
        }

        if self.blockData.usedReturnVariable() {
          returnName := self.blockData.getReturnVariable()

          self.blockData.addSetup(
            AST.createVariableDeclaration(
              AST.createType("unsigned char"),
              returnName,
              AST.createLiteral("0"),
            ),
          )
        }

        self.returnType = initialReturnType
        self.lastVarId = initialLastVarId

        mut cBody: AST.CStatement[]
        cReturnType := AST.createType(self._type(returnType))
        dataContextBlock := self.blockData.decrease()

        cBody.merge(dataContextBlock.setup)
        cBody.merge(statements)
        cBody.merge(dataContextBlock.teardown)

        if returnType.name != "void" && dataContextBlock.usedValueVariable {
          valueName := dataContextBlock.valueVariable()
          cBody.push(AST.createReturnStatement(AST.createIdentifier(valueName)))
        }

        return AST.createFunctionDeclaration(
          cReturnType,
          entityCodeName,
          parameters,
          AST.createCompoundStatement(cBody),
        )
      }
    })

    allocTypeName := self._type(t, "_alloc")
    returnType := t.getReturnType()
    cReturnType := AST.createType(self._type(returnType))

    mut cContext := AST.createIdentifier(self._("NULL"))

    if !entityContext.variables.empty {
      mut contextInitializerList: AST.CExpression[]

      loop i := 0; i < entityContext.variables.len; i++ {
        contextVariable := entityContext.variables[i]

        contextInitializerList.push(
          AST.createCallExpression(
            AST.createIdentifier(self._type(contextVariable.t, "_copy", arc: contextVariable.referenced)),
            [AST.createIdentifier(contextVariable.fullName())],
          ),
        )
      }

      tmpVar := self._tmpVar()
      cTmpVar := AST.createIdentifier(tmpVar)

      self.blockData.addSetup(
        AST.createVariableDeclaration(AST.createType("void", reference: true), tmpVar, AST.createIdentifier(self._("NULL"))),
      )

      cContext = AST.createAssignmentExpression(
        cTmpVar,
        "=",
        AST.createCallExpression(AST.createIdentifier(self._("d4_safe_calloc")), [
          AST.createUnaryExpression("&", AST.createCastExpression(
            AST.createType(self._(entityContext.contextTypeName)),
            AST.createInitializerListExpression(contextInitializerList),
          )),
          AST.createCallExpression(AST.createIdentifier("sizeof"), [
            AST.createType(self._(entityContext.contextTypeName)),
          ]),
        ]),
      )

      self.blockData.addTeardown(
        AST.createExpressionStatement(
          AST.createCallExpression(AST.createIdentifier(self._("d4_safe_free")), [cTmpVar]),
        ),
      )
    }

    return AST.createExpressionStatement(
      AST.createAssignmentExpression(
        AST.createIdentifier(variableName),
        "=",
        AST.createCallExpression(AST.createIdentifier(allocTypeName), [
          self._str(name.name),
          cContext,
          AST.createIdentifier(self._("NULL")), // TODO: ctx copy
          AST.createIdentifier(self._("NULL")), // TODO: ctx free
          AST.createCastExpression(
            AST.createType(cReturnType.stringify(declaration: true) + "(*) (void *, void *)"),
            AST.createIdentifier(self._(entityContext.functorTypeName)),
          ),
        ]),
      ),
    )
  }

  fn _functionCopy (mut self: ref Self, it: ref Analyzer.Type, expression: AST.CExpression, arc := false) AST.CExpression {
    t := Analyzer.unwrap(it, withReference: false)

    if (
      arc ||
      t.name == "any" ||
      t.name == "str" ||
      t.isArray() ||
      t.isFunction() ||
      t.isMap() ||
      t.isMethod() ||
      t.isCustomObject() ||
      t.isOptional() ||
      t.isUnion()
    ) {
      return AST.createCallExpression(AST.createIdentifier(self._type(t, "_copy", arc: arc)), [expression])
    }

    return expression
  }

  fn _functionEq (mut self: ref Self, it: ref Analyzer.Type, left: AST.CExpression, right: AST.CExpression, reverse := false) AST.CExpression {
    t := Analyzer.unwrap(it, withReference: false)

    if (
      t.name == "any" ||
      t.name == "str" ||
      t.isArray() ||
      t.isFunction() ||
      t.isMap() ||
      t.isMethod() ||
      t.isCustomObject() ||
      t.isOptional() ||
      t.isUnion()
    ) {
      result := AST.createCallExpression(AST.createIdentifier(self._type(t, "_eq")), [left, right])
      return reverse ? AST.createUnaryExpression("!", result) : result
    }

    return AST.createAssignmentExpression(left, reverse ? "!=" : "==", right)
  }

  fn _functionFree (mut self: ref Self, it: ref Analyzer.Type, expression: AST.CExpression, arc := false) AST.CExpression {
    t := Analyzer.unwrap(it, withReference: false)

    if (
      arc ||
      t.name == "any" ||
      t.name == "str" ||
      t.isArray() ||
      t.isFunction() ||
      t.isMap() ||
      t.isMethod() ||
      t.isCustomObject() ||
      t.isOptional() ||
      t.isUnion()
    ) {
      return AST.createCallExpression(AST.createIdentifier(self._type(t, "_free", arc: arc)), [expression])
    }

    return AST.createCastExpression(AST.createType("void"), expression)
  }

  fn _functionRealloc (mut self: ref Self, it: ref Analyzer.Type, left: AST.CExpression, right: AST.CExpression, arc := false) AST.CExpression {
    t := Analyzer.unwrap(it, withReference: false)

    cReallocCall := AST.createCallExpression(
      AST.createIdentifier(self._type(t, "_realloc", arc: arc)),
      [left, right],
    )

    if arc {
      return cReallocCall
    } elif (
      t.name == "any" ||
      t.name == "str" ||
      t.isArray() ||
      t.isFunction() ||
      t.isMap() ||
      t.isMethod() ||
      t.isCustomObject() ||
      t.isOptional() ||
      t.isUnion()
    ) {
      return AST.createAssignmentExpression(left, "=", cReallocCall)
    }

    throw error_NewError("Tried re-allocating unknown type '" + t.toString() + "'")
  }

  fn _functionStr (mut self: ref Self, it: ref Analyzer.Type, expression: AST.CExpression, quote := false) AST.CExpression {
    if it.isAlias() {
      t := it.asAlias()
      return self._functionStr(t.t, expression, quote: quote)
    } elif it.name == "any" {
      return AST.createCallExpression(AST.createIdentifier(self._("d4_any_str")), [expression])
    } elif it.name == "str" && quote {
      return AST.createCallExpression(AST.createIdentifier(self._("d4_str_quoted_escape")), [expression])
    } elif it.name == "str" {
      return AST.createCallExpression(AST.createIdentifier(self._("d4_str_copy")), [expression])
    } elif it.isEnum() {
      return AST.createCallExpression(AST.createIdentifier(self._("d4_enum_str")), [expression])
    } elif it.isReference() {
      t := it.asReference()
      return self._functionStr(t.t, AST.createUnaryExpression("*", expression), quote: quote)
    } elif (
      it.name == "bool" ||
      it.name == "byte" ||
      it.name == "char" ||
      it.name == "rune" ||
      it.isNumber()
    ) {
      typeName := self._typeName(it)
      return AST.createCallExpression(AST.createIdentifier(self._("d4_" + typeName + "_str")), [expression])
    } elif (
      it.isArray() ||
      it.isEnum() ||
      it.isFunction() ||
      it.isMap() ||
      it.isMethod() ||
      it.isCustomObject() ||
      it.isOptional() ||
      it.isUnion()
    ) {
      return AST.createCallExpression(AST.createIdentifier(self._type(it, "_str")), [expression])
    }

    throw error_NewError("Tried stringifying unknown type '" + it.toString() + "'")
  }

  fn _generateBlock (mut self: ref Self, items: ref Parser.Statement[]) AST.CStatement[] {
    if items.empty {
      return []
    }

    self.blockData.increase()
    result := self._generateBlockBody(items)
    blockData := self.blockData.decrease()

    return self._generateBlockTail(result, items.first.parentMaybe(), ref blockData)
  }

  fn _generateBlockBody (mut self: ref Self, items: ref Parser.Statement[]) AST.CStatement[] {
    mut result: AST.CStatement[]
    l := items.len
    mut mainDeclaration: (ref Parser.Statement)?
    mut declarations: (ref Parser.Statement)[]

    loop i := 0; i < l; i++ {
      item := items[i]

      if item.isMainDeclaration() {
        mainDeclaration = item
      } elif item.isDeclaration() {
        declarations.push(item)
      }
    }

    declarations.sort(declarationByDependency)
    dl := declarations.len

    loop i := 0; i < dl; i++ {
      declaration := declarations[i] as ref Parser.Statement
      self._declareStatement(declaration)
    }

    loop i := 0; i < l; i++ {
      item := items[i]
      declarationAsStatement := item.isFunctionDeclaration()

      if !(item.isDeclaration() && !declarationAsStatement) {
        result.push(self._generateStatement(item))
      }
    }

    if mainDeclaration != nil {
      self._declareStatement(mainDeclaration)
    }

    return result
  }

  fn _generateBlockTail (mut self: ref Self, result: AST.CStatement[], parent: (ref Parser.Statement)?, blockData: ref BlockDataContext) AST.CStatement[] {
    mut finalResult: AST.CStatement[]
    finalResult.merge(blockData.setup)
    finalResult.merge(result)
    finalResult.merge(blockData.teardown)

    mut parentIsLoop := false

    if parent != nil {
      parentIsLoop = parent.isLoopDeep()
    }

    if !parentIsLoop && blockData.usedContinueVariable {
      finalResult.push(
        AST.createIfStatement(
          AST.createBinaryExpression(
            AST.createIdentifier(blockData.continueVariable()),
            "==",
            AST.createLiteral("1"),
          ),
          self.blockData.hasUntil(.Loop)
            ? AST.createGotoStatement(self.blockData.getLabel())
            : AST.createContinueStatement(),
        )
      )
    }

    if blockData.usedBreakVariable {
      finalResult.push(
        AST.createIfStatement(
          AST.createBinaryExpression(
            AST.createIdentifier(blockData.breakVariable()),
            "==",
            AST.createLiteral("1"),
          ),
          !parentIsLoop && self.blockData.hasUntil(.Loop)
            ? AST.createGotoStatement(self.blockData.getLabel())
            : AST.createBreakStatement(),
        )
      )
    }

    if blockData.usedReturnVariable && !blockData.empty() {
      returnTypeName := self.returnType == nil ? "" : self.returnType.name

      finalResult.push(
        AST.createIfStatement(
          AST.createBinaryExpression(
            AST.createIdentifier(blockData.returnVariable()),
            "==",
            AST.createLiteral("1"),
          ),
          self.blockData.hasUntil(.Fn)
            ? AST.createGotoStatement(self.blockData.getLabel())
            : returnTypeName == "void"
              ? AST.createReturnStatement()
              : AST.createReturnStatement(AST.createIdentifier(self.blockData.getValueVariable())),
        ),
      )
    }

    return finalResult
  }

  fn _generateExpression (mut self: ref Self, item: ref Parser.Expression, allocate := true, deallocate := true, arc := false, lvalue := false) AST.CExpression {
    mut result: AST.CExpression?

    if (
      (result = self._generateIdentifier(item, lvalue: lvalue)) != nil ||
      (result = self._generateCallExpression(item)) != nil ||
      (result = self._generateLiteral(item)) != nil ||
      (result = self._generateParenthesizedExpression(item, lvalue: lvalue)) != nil ||
      (result = self._generateArrayExpression(item)) != nil ||
      (result = self._generateAsExpression(item)) != nil ||
      (result = self._generateAssignmentExpression(item)) != nil ||
      (result = self._generateBinaryExpression(item)) != nil ||
      (result = self._generateConditionalExpression(item)) != nil ||
      (result = self._generateElementAccessExpression(item)) != nil ||
      (result = self._generateIsExpression(item)) != nil ||
      (result = self._generateMapExpression(item)) != nil ||
      (result = self._generateObjectExpression(item)) != nil ||
      (result = self._generatePropertyAccessExpression(item)) != nil ||
      (result = self._generateReferenceExpression(item)) != nil ||
      (result = self._generateUnaryExpression(item)) != nil
    ) {
      initialType := Analyzer.contextInitial(item)
      targetType := Analyzer.contextTarget(item)

      return self._wrap(result, item, initialType, targetType, allocate: allocate, deallocate: deallocate, arc: arc)
    }

    throw error_NewError("Tried code generation for unknown expression '" + Parser.stringifyExpression(item) + "'")
  }

  fn _generateStatement (mut self: ref Self, item: ref Parser.Statement) AST.CStatement {
    mut result: AST.CStatement?

    if (
      (result = self._generateBlockStatement(item)) != nil ||
      (result = self._generateBreakStatement(item)) != nil ||
      (result = self._generateContinueStatement(item)) != nil ||
      (result = self._generateExpressionStatement(item)) != nil ||
      (result = self._generateFunctionDeclaration(item)) != nil ||
      (result = self._generateIfStatement(item)) != nil ||
      (result = self._generateLoopStatement(item)) != nil ||
      (result = self._generateReturnStatement(item)) != nil ||
      (result = self._generateVariableDeclaration(item)) != nil
    ) {
      return result
    }

    throw error_NewError("Tried code generation for unknown statement '" + Parser.stringifyStatement(item) + "'")
  }

  fn _generateIdentifier (mut self: ref Codegen, item: ref Parser.Expression, lvalue := false) AST.CExpression? {
    if !item.isIdentifier() {
      return nil
    }

    expression := item.asIdentifier()
    mut name := expression.name

    if name == "print" {
      name = self._("d4_print")
    } elif self._hasEntity(name) {
      name = self._(name)
    } else {
      blockDataVariable := self.blockData.getVariable(name)
      name = blockDataVariable.fullName()

      if blockDataVariable.referenced && !lvalue {
        return AST.createPropertyAccessExpression(
          AST.createIdentifier(name),
          "ref",
          pointed: true,
        )
      }
    }

    return AST.createIdentifier(name)
  }

  fn _generateLiteral (mut self: ref Codegen, item: ref Parser.Expression) AST.CExpression? {
    mut tm := self._tm()

    if item.isBooleanLiteral() {
      expression := item.asBooleanLiteral()
      return AST.createLiteral(self._(expression.value))
    } elif item.isCharacterLiteral() {
      expression := item.asCharacterLiteral()
      return AST.createLiteral("L'" + expression.value + "'")
    } elif item.isFloatingPointLiteral() {
      expression := item.asFloatingPointLiteral()
      return AST.createLiteral(expression.value)
    } elif item.isIntegerLiteral() {
      expression := item.asIntegerLiteral()
      mut numValue: u64

      if expression.value.lower.slice(0, 2) == "0b" {
        binary := expression.value.lower.slice(2)
        binaryLen := binary.len

        loop i := 0; i < binaryLen; i++ {
          numValue = numValue * 2 + (binary[i] == '1' ? 1 : 0)
        }
      } elif expression.value.lower.slice(0, 2) == "0x" {
        hex := expression.value.lower.slice(2)
        hexLen := hex.len

        loop i := 0; i < hexLen; i++ {
          code := hex[i].lower.byte
          start := code >= 97 && code <= 102 ? 87 : 48
          numValue = numValue * 16 + (code - start)
        }
      } elif expression.value.lower.slice(0, 2) == "0o" {
        octal := expression.value.lower.slice(2)
        octalLen := octal.len

        loop i := 0; i < octalLen; i++ {
          numValue = numValue * 8 + (octal[i].byte - 48)
        }
      } else {
        numValue = expression.value.toU64()
      }

      return AST.createLiteral(numValue.str() + (numValue > 9223372036854775807 ? "U" : ""))
    } elif item.isNilLiteral() {
      expression := item.asNilLiteral()
      return AST.createIdentifier(self._("NULL"))
    } elif item.isStringLiteral() {
      expression := item.asStringLiteral()
      sanitizedValue := expression.value
        .replace(os_EOL, "\" " + self._("D4_EOL") + " \"")
        .replace("\n", "\" " + self._("D4_EOL") + " \"")
      rawValue := "L\"" + sanitizedValue + "\""

      return AST.createCallExpression(
        AST.createIdentifier(self._("d4_str_alloc")),
        [AST.createLiteral(rawValue)],
      )
    }

    return nil
  }

  fn _generateArrayExpression (mut self: ref Codegen, item: ref Parser.Expression) AST.CExpression? {
    if !item.isArray() {
      return nil
    }

    expression := item.asArray()
    targetType := Analyzer.contextTarget(item)
    mut arguments: (AST.CExpression | AST.CType)[] = [AST.createLiteral(expression.elements.len.str())]

    loop i := 0; i < expression.elements.len; i++ {
      element := expression.elements[i]
      arguments.push(self._generateExpression(element))
    }

    return AST.createCallExpression(AST.createIdentifier(self._type(targetType, "_alloc")), arguments)
  }

  fn _generateAsExpression (mut self: ref Codegen, item: ref Parser.Expression) AST.CExpression? {
    if !item.isAs() {
      return nil
    }

    expression := item.asAs()

    if !(item.contextExtra is Analyzer.AsExpressionContextExtra) {
      throw error_NewError("Expected AsExpression context extra")
    }

    initialType := Analyzer.contextInitial(item)
    contextExtra := item.contextExtra as Analyzer.AsExpressionContextExtra
    result := self._generateExpression(ref expression.expression)

    if Analyzer.match(contextExtra.fromType, initialType) {
      return result
    }

    return self._wrap(result, item, contextExtra.fromType, initialType)
  }

  fn _generateAssignmentExpression (mut self: ref Codegen, item: ref Parser.Expression) AST.CExpression? {
    if !item.isAssignment() {
      return nil
    }

    expression := item.asAssignment()
    leftType := Analyzer.unwrap(Analyzer.contextTarget(ref expression.left), withReference: false)
    rightType := Analyzer.unwrap(Analyzer.contextTarget(ref expression.right), withReference: false)
    isLeftArc := self._isArc(ref expression.left)
    left := self._generateExpression(ref expression.left, lvalue: true)
    mut right := self._generateExpression(ref expression.right)

    if expression.operator.t == .OpPlusEq && (leftType.name == "str" || rightType.name == "str") {
      cConcatLeft := self._generateExpression(ref expression.left)
      return self._functionRealloc(
        leftType,
        left,
        self._allocateExpression(
          leftType,
          AST.createCallExpression(AST.createIdentifier(self._("d4_str_concat")), [cConcatLeft, right]),
        ),
        arc: isLeftArc
      )
    } elif isLeftArc || !typeIsSimple(leftType) || !typeIsSimple(rightType) {
      return self._functionRealloc(leftType, left, right, arc: isLeftArc)
    } elif expression.operator.t == .OpAmpAmp || expression.operator.t == .OpPipePipe {
      right = AST.createBinaryExpression(left, expression.operator.val, right)
      return AST.createAssignmentExpression(left, "=", right)
    }

    return AST.createAssignmentExpression(left, expression.operator.val, right)
  }

  fn _generateBinaryExpression (mut self: ref Codegen, item: ref Parser.Expression) AST.CExpression? {
    if !item.isBinary() {
      return nil
    }

    expression := item.asBinary()
    wrappedLeftType := Analyzer.unwrap(Analyzer.contextTarget(ref expression.left), withReference: false)
    leftType := Analyzer.unwrap(wrappedLeftType)
    wrappedRightType := Analyzer.unwrap(Analyzer.contextTarget(ref expression.right), withReference: false)
    rightType := Analyzer.unwrap(wrappedRightType)
    mut left := self._generateExpression(ref expression.left)
    mut right := self._generateExpression(ref expression.right)
    operatorSafeForRef := expression.operator.t == .OpEqEq || expression.operator.t == .OpExclEq

    if !operatorSafeForRef && wrappedLeftType.isReference() {
      left = self._wrap(left, ref expression.left, wrappedLeftType, leftType)
    }

    if !operatorSafeForRef && wrappedRightType.isReference() {
      right = self._wrap(right, ref expression.right, wrappedRightType, rightType)
    }

    if (
      (expression.operator.t == .OpEqEq || expression.operator.t == .OpExclEq) &&
      (!typeIsSimple(leftType) || !typeIsSimple(rightType))
    ) {
      return self._functionEq(leftType, left, right, reverse: expression.operator.t == .OpExclEq)
    } elif leftType.name == "str" && rightType.name == "str" && (
      expression.operator.t == .OpLt ||
      expression.operator.t == .OpLtEq ||
      expression.operator.t == .OpGt ||
      expression.operator.t == .OpGtEq
    ) {
      operator := expression.operator.t == .OpLt
        ? "lt"
        : expression.operator.t == .OpLtEq
          ? "le"
          : expression.operator.t == .OpGt
            ? "gt"
            : "ge"

      return AST.createCallExpression(AST.createIdentifier(self._("d4_str_" + operator)), [left, right])
    } elif expression.operator.t == .OpPlus && leftType.name == "str" && rightType.name == "str" {
      return AST.createCallExpression(AST.createIdentifier(self._("d4_str_concat")), [left, right])
    }

    return AST.createBinaryExpression(left, expression.operator.val, right)
  }

  fn _generateCallExpression (mut self: ref Codegen, item: ref Parser.Expression) AST.CExpression? {
    if !item.isCall() {
      return nil
    }

    expression := item.asCall()

    if !(item.contextExtra is Analyzer.CallExpressionContextExtra) {
      throw error_NewError("Expected CallExpression context extra")
    }

    contextExtra := item.contextExtra as Analyzer.CallExpressionContextExtra
    isBuiltinMethod := expressionIsBuiltinMethod(ref expression.callee)
    calleeTargetType := Analyzer.contextTarget(ref expression.callee)
    cCalleeExpression := self._generateExpression(ref expression.callee)
    mut paramsArgs: AST.CExpression[]

    if !isBuiltinMethod && calleeTargetType.hasSelfParam() {
      paramsArgs.push(cCalleeExpression)
    } elif calleeTargetType.hasSelfParam() {
      calleeBody := expression.callee.asPropertyAccess()
      paramsArgs.push(self._generateExpression(ref calleeBody.expression))
    }

    loop i := 0; i < contextExtra.parameters.len; i++ {
      param := contextExtra.parameters[i]

      if param.variadic {
        mut variadicArgs: (AST.CExpression | AST.CType)[]

        loop j := 0; j < contextExtra.arguments.len; j++ {
          arg := contextExtra.arguments[j]

          if arg.parameterIdx != i {
            continue
          }

          variadicArgs.push(
            self._generateExpression(ref arg.argument.expression),
          )
        }

        mut variadicAllocArgs: (AST.CExpression | AST.CType)[] = [AST.createLiteral(variadicArgs.len.str())]
        variadicAllocArgs.merge(variadicArgs)
        variadicAllocType := self._type(param.t, "_alloc")

        paramsArgs.push(
          self._allocateExpression(
            param.t,
            AST.createCallExpression(AST.createIdentifier(variadicAllocType), variadicAllocArgs),
          ),
        )

        continue
      }

      mut argIdx := -1

      loop j := 0; j < contextExtra.arguments.len; j++ {
        arg := contextExtra.arguments[j]

        if arg.parameterIdx == i {
          argIdx = j
          break
        }
      }

      if !param.required {
        paramsArgs.push(AST.createLiteral(argIdx == -1 ? "0" : "1"))
      }

      if argIdx != -1 {
        arg := contextExtra.arguments[argIdx]
        paramsArgs.push(self._generateExpression(ref arg.argument.expression))
      } else {
        paramsArgs.push(self._defaultInitializerDeclaration(param.t))
      }
    }

    mut args: (AST.CExpression | AST.CType)[] = []

    if isBuiltinMethod {
      calleeBody := expression.callee.asPropertyAccess()
      calleeBodyTargetType := Analyzer.unwrap(Analyzer.contextTarget(ref calleeBody.expression))

      if !paramsArgs.empty {
        loop i := 0; i < paramsArgs.len; i++ {
          paramsArg := paramsArgs[i] as AST.CExpression
          args.push(paramsArg)
        }
      }

      return AST.createCallExpression(
        AST.createIdentifier(self._type(calleeBodyTargetType, "_" + calleeBody.name.name)),
        args,
      )
    }

    args.push(createASTPropertyAccess(cCalleeExpression, "ctx"))

    if paramsArgs.empty {
      args.push(AST.createIdentifier(self._("NULL")))
    } else {
      tmpVar := self._tmpVar()
      cTmpVar := AST.createIdentifier(tmpVar)
      paramsName := self._type(calleeTargetType, "_params_t")

      self.blockData.addSetup(
        AST.createVariableDeclaration(AST.createType("void", reference: true), tmpVar, AST.createIdentifier(self._("NULL"))),
      )

      args.push(
        AST.createAssignmentExpression(
          cTmpVar,
          "=",
          AST.createCallExpression(AST.createIdentifier(self._("d4_safe_calloc")), [
            AST.createUnaryExpression("&", AST.createCastExpression(
              AST.createType(paramsName),
              AST.createInitializerListExpression(paramsArgs),
            )),
            AST.createCallExpression(AST.createIdentifier("sizeof"), [
              AST.createType(paramsName),
            ]),
          ]),
        ),
      )

      self.blockData.addTeardown(
        AST.createExpressionStatement(
          AST.createCallExpression(AST.createIdentifier(self._("d4_safe_free")), [cTmpVar]),
        ),
      )
    }

    return AST.createCallExpression(createASTPropertyAccess(cCalleeExpression, "func"), args)
  }

  fn _generateConditionalExpression (mut self: ref Codegen, item: ref Parser.Expression) AST.CExpression? {
    if !item.isConditional() {
      return nil
    }

    expression := item.asConditional()
    alternateType := Analyzer.unwrap(Analyzer.contextTarget(ref expression.alternate), withReference: false)
    mut alternate := self._generateExpression(ref expression.alternate, allocate: false)

    if alternate.isAssignmentExpression() && !typeSafeForTernaryAlternate(alternateType) {
      alternate = alternate.wrap()
    }

    return AST.createConditionalExpression(
      self._generateExpression(ref expression.condition),
      self._generateExpression(ref expression.consequent, allocate: false),
      alternate,
    )
  }

  fn _generateElementAccessExpression (mut self: ref Codegen, item: ref Parser.Expression) AST.CExpression? {
    if !item.isElementAccess() {
      return nil
    }

    expression := item.asElementAccess()

    if !(item.contextExtra is Analyzer.ElementAccessExpressionContextExtra) {
      throw error_NewError("Expected ElementAccessExpression context extra")
    }

    contextExtra := item.contextExtra as Analyzer.ElementAccessExpressionContextExtra
    startLoc := Parser.Reader_locate(self._r(), item.start)

    return AST.createCallExpression(AST.createIdentifier(self._type(contextExtra.selfType, "_at")), [
      AST.createUnaryExpression("&", AST.createIdentifier(self._("d4_err_state"))),
      AST.createLiteral(startLoc.line.str()),
      AST.createLiteral(startLoc.col.str()),
      self._generateExpression(ref expression.expression),
      self._generateExpression(ref expression.argument),
    ])
  }

  fn _generateIsExpression (mut self: ref Codegen, item: ref Parser.Expression) AST.CExpression? {
    if !item.isIs() {
      return nil
    }

    expression := item.asIs()

    if !(item.contextExtra is Analyzer.IsExpressionContextExtra) {
      throw error_NewError("Expected IsExpression context extra")
    }

    contextExtra := item.contextExtra as Analyzer.IsExpressionContextExtra
    mut left := self._generateExpression(ref expression.expression)
    leftType := Analyzer.contextTarget(ref expression.expression)
    typeDef := self._typeDef(contextExtra.t)
    right := AST.createIdentifier(self._(typeDef))

    if Analyzer.match(contextExtra.t, leftType) {
      result := AST.createCommaExpression(left, AST.createIdentifier(self._("true")))
      return result.wrap()
    }

    left = createASTPropertyAccess(left, "type")
    return AST.createBinaryExpression(left, "==", right)
  }

  fn _generateMapExpression (mut self: ref Codegen, item: ref Parser.Expression) AST.CExpression? {
    if !item.isMap() {
      return nil
    }

    expression := item.asMap()
    targetType := Analyzer.contextTarget(item)
    len := expression.elements.len
    mut arguments: (AST.CExpression | AST.CType)[] = [AST.createLiteral(len.str())]

    loop i := 0; i < len; i++ {
      element := expression.elements[i]
      arguments.push(self._generateExpression(ref element.key))
      arguments.push(self._generateExpression(ref element.value))
    }

    return AST.createCallExpression(AST.createIdentifier(self._type(targetType, "_alloc")), arguments)
  }

  fn _generateObjectExpression (mut self: ref Codegen, item: ref Parser.Expression) AST.CExpression? {
    if !item.isObject() {
      return nil
    }

    expression := item.asObject()
    targetType := Analyzer.contextTarget(item)

    mut fields: (AST.CExpression | AST.CType)[]

    loop i := 0; i < targetType.properties.len; i++ {
      property := targetType.properties[i]

      if property.builtin || property.t.isMethod() {
        continue
      }

      mut propertyValue: (ref Parser.Expression)?

      loop j := 0; j < expression.properties.len; j++ {
        expressionProperty := expression.properties[j]

        if expressionProperty.name.name == property.name {
          propertyValue = ref expressionProperty.value
          break
        }
      }

      fields.push(
        propertyValue == nil
          ? self._defaultInitializerDeclaration(property.t)
          : self._generateExpression(propertyValue)
      )
    }

    return AST.createCallExpression(AST.createIdentifier(self._type(targetType, "_alloc")), fields)
  }

  fn _generateParenthesizedExpression (mut self: ref Codegen, item: ref Parser.Expression, lvalue := false) AST.CExpression? {
    if !item.isParenthesized() {
      return nil
    }

    expression := item.asParenthesized()
    result := self._generateExpression(ref expression.expression, lvalue: lvalue)
    return result.wrap()
  }

  fn _generatePropertyAccessExpression (mut self: ref Codegen, item: ref Parser.Expression) AST.CExpression? {
    if !item.isPropertyAccess() {
      return nil
    }

    expression := item.asPropertyAccess()

    return createASTPropertyAccess(
      self._generateExpression(ref expression.expression),
      expression.name.name,
    )
  }

  fn _generateReferenceExpression (mut self: ref Codegen, item: ref Parser.Expression) AST.CExpression? {
    if !item.isReference() {
      return nil
    }

    expression := item.asReference()
    return AST.createUnaryExpression("&", self._generateExpression(ref expression.expression))
  }

  fn _generateUnaryExpression (mut self: ref Codegen, item: ref Parser.Expression) AST.CExpression? {
    if !item.isUnary() {
      return nil
    }

    expression := item.asUnary()
    wrappedOperandType := Analyzer.contextTarget(ref expression.operand)
    operandType := Analyzer.unwrap(wrappedOperandType)
    mut operand := self._generateExpression(ref expression.operand)

    if wrappedOperandType.isReference() {
      operand = self._wrap(operand, ref expression.operand, wrappedOperandType, operandType)
    }

    if operandType.isFloat() {
      operand = AST.createCastExpression(AST.createType(self._("bool")), operand)
      operand = operand.wrap()
    }

    return AST.createUnaryExpression(
      expression.operator.val,
      operand,
      postfix: !expression.prefix,
    )
  }

  fn _generateBlockStatement (mut self: ref Codegen, item: ref Parser.Statement) AST.CStatement? {
    if !item.isBlock() {
      return nil
    }

    statement := item.asBlock()
    return AST.createCompoundStatement(self._generateBlock(ref statement.body))
  }

  fn _generateBreakStatement (mut self: ref Codegen, item: ref Parser.Statement) AST.CStatement? {
    if !item.isBreak() {
      return nil
    }

    statement := item.asBreak()

    if !self.blockData.hasUntil(.Loop) {
      return AST.createBreakStatement()
    }

    mut result := AST.createExpressionStatement(
      AST.createAssignmentExpression(
        AST.createIdentifier(self.blockData.getBreakVariable()),
        "=",
        AST.createLiteral("1"),
      )
    )

    if item.hasNext() {
      jumpStatement := AST.createGotoStatement(self.blockData.getLabel())
      result = AST.createCompoundStatement([result, jumpStatement])
    }

    return result
  }

  fn _generateContinueStatement (mut self: ref Codegen, item: ref Parser.Statement) AST.CStatement? {
    if !item.isContinue() {
      return nil
    }

    statement := item.asContinue()

    if !self.blockData.hasUntil(.Loop) {
      return AST.createContinueStatement()
    }

    mut result := AST.createExpressionStatement(
      AST.createAssignmentExpression(
        AST.createIdentifier(self.blockData.getContinueVariable()),
        "=",
        AST.createLiteral("1"),
      )
    )

    if item.hasNext() {
      jumpStatement := AST.createGotoStatement(self.blockData.getLabel())
      result = AST.createCompoundStatement([result, jumpStatement])
    }

    return result
  }

  fn _generateExpressionStatement (mut self: ref Codegen, item: ref Parser.Statement) AST.CStatement? {
    if !item.isExpression() {
      return nil
    }

    statement := item.asExpression()
    return AST.createExpressionStatement(self._generateExpression(ref statement.expression))
  }

  fn _generateFunctionDeclaration (mut self: ref Codegen, item: ref Parser.Statement) AST.CStatement? {
    if !item.isFunctionDeclaration() {
      return nil
    }

    statement := item.asFunctionDeclaration()

    if !(item.context is Analyzer.FunctionDeclarationContext) {
      throw error_NewError("Expected FunctionDeclaration context")
    }

    context := item.context as Analyzer.FunctionDeclarationContext

    return self._defineFunction(
      statement.name,
      statement.parameters,
      statement.body,
      context.var.t,
      context.context,
    )
  }

  fn _generateIfStatement (mut self: ref Codegen, item: ref Parser.Statement) AST.CStatement? {
    if !item.isIf() {
      return nil
    }

    statement := item.asIf()
    condition := self._generateExpression(ref statement.condition)
    items := normalizeBlock(ref statement.consequent)
    consequent := AST.createCompoundStatement(self._generateBlock(ref items))
    mut alternate: AST.CStatement?

    if statement.alternate != nil {
      statementAlternate := statement.alternate
      alternate = self._generateStatement(ref statementAlternate)
    }

    return AST.createIfStatement(condition, consequent, alternate)
  }

  fn _generateLoopStatement (mut self: ref Codegen, item: ref Parser.Statement) AST.CStatement? {
    if !item.isLoop() {
      return nil
    }

    statement := item.asLoop()
    mut initializer: AST.CStatement?
    mut condition: AST.CExpression?
    mut update: AST.CExpression?
    bodyIsBlock := statement.body.isBlock()
    mut body: AST.CStatement[]

    self.blockData.increase()

    if statement.initializer != nil {
      initializerStatement := self._generateStatement(ref statement.initializer)

      if !self.blockData.currentEmpty() {
        self.blockData.addSetup(initializerStatement)
      } else {
        initializer = initializerStatement
      }
    }

    self.blockData.increase(.Loop)
    self.blockData.increaseVariableIndexes()

    if statement.condition != nil {
      self.blockData.increase()
      conditionExpression := self._generateExpression(ref statement.condition)
      blockData := self.blockData.decrease()

      if !blockData.empty() {
        self.blockData.currentMerge(blockData.setup, blockData.teardown)

        body.push(
          AST.createIfStatement(
            AST.createUnaryExpression("!", conditionExpression.wrap()),
            AST.createCompoundStatement([
              AST.createExpressionStatement(
                AST.createAssignmentExpression(
                  AST.createIdentifier(self.blockData.getBreakVariable()),
                  "=",
                  AST.createLiteral("1"),
                ),
              ),
              AST.createGotoStatement(self.blockData.getLabel()),
            ]),
          ),
        )
      } else {
        condition = conditionExpression
      }
    }

    if statement.update != nil {
      self.blockData.increase()
      updateExpression := self._generateExpression(ref statement.update)
      blockData := self.blockData.decrease()

      if !blockData.empty() {
        self.blockData.currentMerge(blockData.setup, blockData.teardown)
        self.blockData.addTeardown(AST.createExpressionStatement(updateExpression))
      } else {
        update = updateExpression
      }
    }

    mut bodyItems := normalizeBlock(ref statement.body)
    body.merge(self._generateBlockBody(ref bodyItems))
    self.blockData.decreaseVariableIndexes()

    blockDataLoop := self.blockData.decrease()
    optItem: (ref Parser.Statement)? = item // TODO: remove after v1
    body = self._generateBlockTail(body, optItem, ref blockDataLoop)

    if blockDataLoop.usedContinueVariable {
      body = [
        AST.createVariableDeclaration(
          AST.createType("unsigned char"),
          blockDataLoop.continueVariable(),
          AST.createLiteral("0"),
        )
      ].concat(body)
    }

    if blockDataLoop.usedBreakVariable {
      body = [
        AST.createVariableDeclaration(
          AST.createType("unsigned char"),
          blockDataLoop.breakVariable(),
          AST.createLiteral("0"),
        )
      ].concat(body)
    }

    statementBody := !bodyIsBlock && body.len == 1 ? body[0] : AST.createCompoundStatement(body)

    if initializer == nil && condition == nil && update == nil {
      condition = AST.createLiteral("1")
    }

    mut result := AST.createForStatement(initializer, condition, update, statementBody)

    if initializer == nil && condition != nil && update == nil {
      result = AST.createWhileStatement(condition, statementBody)
    }

    blockDataBlock := self.blockData.decrease()

    if !blockDataBlock.empty() {
      mut newStatementBody := blockDataBlock.setup
      newStatementBody.push(result)
      newStatementBody.merge(blockDataBlock.teardown)

      if blockDataBlock.usedReturnVariable {
        returnTypeName := self.returnType == nil ? "" : self.returnType.name

        newStatementBody.push(
          AST.createIfStatement(
            AST.createBinaryExpression(
              AST.createIdentifier(self.blockData.getReturnVariable()),
              "==",
              AST.createLiteral("1"),
            ),
            self.blockData.hasUntil(.Fn)
              ? AST.createGotoStatement(self.blockData.getLabel())
              : returnTypeName == "void"
                ? AST.createReturnStatement()
                : AST.createReturnStatement(AST.createIdentifier(self.blockData.getValueVariable())),
          ),
        )
      }

      result = AST.createCompoundStatement(newStatementBody)
    }

    return result
  }

  fn _generateReturnStatement (mut self: ref Codegen, item: ref Parser.Statement) AST.CStatement? {
    if !item.isReturn() {
      return nil
    }

    statement := item.asReturn()
    mut cExpression: AST.CExpression?

    if statement.expression != nil {
      statementExpression := statement.expression
      expressionTargetType := Analyzer.contextTarget(ref statementExpression)

      cExpression = self._functionCopy(
        expressionTargetType,
        self._generateExpression(ref statementExpression, allocate: true, deallocate: false),
      )
    }

    mut result: AST.CStatement[]

    if self.blockData.hasTeardownUntil(.Fn) || self.blockData.usedReturnVariable() {
      if self.blockData.hasTeardownUntil(.Fn) {
        result.push(
          AST.createExpressionStatement(
            AST.createAssignmentExpression(
              AST.createIdentifier(self.blockData.getReturnVariable()),
              "=",
              AST.createLiteral("1"),
            ),
          ),
        )
      }

      if cExpression != nil {
        result.push(
          AST.createExpressionStatement(
            AST.createAssignmentExpression(
              AST.createIdentifier(self.blockData.getValueVariable()),
              "=",
              cExpression,
            ),
          ),
        )
      }

      p := item.parent()
      atRoot := p.isDeclaration()

      if (
        item.hasNext() ||
        (!atRoot && self.blockData.hasTeardownUntil(.Fn))
      ) {
        result.push(AST.createGotoStatement(self.blockData.getLabel()))
      }
    } elif cExpression != nil {
      result.push(AST.createReturnStatement(cExpression))
    } elif item.hasMainParent() {
      result.push(AST.createReturnStatement(AST.createLiteral("0")))
    } else {
      result.push(AST.createReturnStatement())
    }

    if result.len == 1 {
      return result[0]
    } elif result.len > 1 {
      return AST.createCompoundStatement(result)
    }

    return nil
  }

  fn _generateVariableDeclaration (mut self: ref Codegen, item: ref Parser.Statement) AST.CStatement? {
    if !item.isVariableDeclaration() {
      return nil
    }

    statement := item.asVariableDeclaration()

    if !(item.context is Analyzer.VariableDeclarationContext) {
      throw error_NewError("Expected VariableDeclaration context")
    }

    context := item.context as Analyzer.VariableDeclarationContext

    mut initializer := statement.initializer == nil
      ? self._defaultInitializerDeclaration(context.var.t, arc: context.var.referenced)
      : self._generateExpression(ref statement.initializer, allocate: false, deallocate: false, arc: context.var.referenced)

    variableName := self.blockData.setVariable(statement.name.name, context.var.t, referenced: context.var.referenced)

    if statement.initializer != nil {
      statementInitializer := statement.initializer

      if typeShouldBeAllocated(context.var.t) && expressionShouldBeCopied(ref statementInitializer) {
        initializer = self._functionCopy(context.var.t, initializer, arc: context.var.referenced)
      }
    }

    if context.var.referenced || typeShouldBeFreed(context.var.t) {
      self.blockData.addTeardown(
        AST.createExpressionStatement(
          self._functionFree(context.var.t, AST.createIdentifier(variableName), arc: context.var.referenced),
        ),
      )
    }

    cType := AST.createType(self._type(context.var.t, arc: context.var.referenced))

    if statementHasPrecedingNonDeclaration(item) {
      self.blockData.addSetup(
        AST.createVariableDeclaration(cType, variableName),
      )

      return AST.createExpressionStatement(
        AST.createAssignmentExpression(AST.createIdentifier(variableName), "=", initializer),
      )
    } else {
      return AST.createVariableDeclaration(cType, variableName, initializer)
    }
  }

  fn _generateAnyType (mut self: ref Codegen, item: ref Analyzer.Type) str {
    typeName := "d4_any_" + self._typeName(item)
    name := typeName + "_t"

    if self._hasEntity(name) {
      return name
    }

    self._typeGen(item)

    self.entities.push(CodegenEntity{
      name: name,
      codeName: name,
      context: item,
      generate: (mut self: ref Codegen, entity: ref CodegenEntity) -> GenerateReturnType {
        it := entity.context as ref Analyzer.Type
        t := self._type(it)
        typeDef := self._typeDef(it)
        typeName := self._typeName(it)

        return [
          AST.createExpressionStatement(AST.createMacroInvocation(self._("D4_ANY_DECLARE"), [
            AST.createIdentifier(typeName),
            AST.createType(t),
          ]), terminated: false),
          AST.createExpressionStatement(AST.createMacroInvocation(self._("D4_ANY_DEFINE"), [
            AST.createIdentifier(self._(typeDef)),
            AST.createIdentifier(typeName),
            AST.createType(t),
            self._functionCopy(it, AST.createIdentifier("val")),
            self._functionEq(it, AST.createIdentifier("lhs_val"), AST.createIdentifier("rhs_val")),
            self._functionFree(it, AST.createIdentifier("val")),
            self._functionStr(it, AST.createIdentifier("val")),
          ]), terminated: false),
        ]
      }
    })

    methods := ["alloc", "copy", "eq", "free", "str"]

    entityCallee := (mut self: ref Codegen, entity: ref CodegenEntity) -> GenerateReturnType {
      self._(entity.context as str)
      return AST.createEmptyStatement()
    }

    loop i := 0; i < methods.len; i++ {
      methodName := methods[i] as str

      self.entities.push(CodegenEntity{
        name: typeName + "_" + methodName,
        codeName: typeName + "_" + methodName,
        context: name,
        generate: entityCallee,
      })
    }

    return name
  }

  fn _generateArcType (mut self: ref Codegen, item: ref Analyzer.Type) str {
    typeName := "d4_arc_" + self._typeName(item)
    name := typeName + "_t"

    if self._hasEntity(name) {
      return name
    }

    self._typeGen(item)

    self.entities.push(CodegenEntity{
      name: name,
      codeName: name,
      context: item,
      generate: (mut self: ref Codegen, entity: ref CodegenEntity) -> GenerateReturnType {
        it := entity.context as ref Analyzer.Type
        t := self._type(it)
        typeDef := self._typeDef(it)
        typeName := self._typeName(it)

        return [
          AST.createExpressionStatement(AST.createMacroInvocation(self._("D4_ARC_FORWARD_DECLARE"), [
            AST.createIdentifier(typeName),
          ]), terminated: false),
          AST.createExpressionStatement(AST.createMacroInvocation(self._("D4_ARC_DECLARE"), [
            AST.createIdentifier(typeName),
            AST.createType(t),
          ]), terminated: false),
          AST.createExpressionStatement(AST.createMacroInvocation(self._("D4_ARC_DEFINE"), [
            AST.createIdentifier(typeName),
            AST.createType(t),
            self._functionCopy(it, AST.createIdentifier("ref")),
            self._functionEq(it, AST.createIdentifier("lhs_ref"), AST.createIdentifier("rhs_ref")),
            self._functionFree(it, AST.createIdentifier("ref")),
            self._functionStr(it, AST.createIdentifier("ref")),
          ]), terminated: false),
        ]
      }
    })

    methods := ["alloc", "copy", "eq", "free", "realloc", "str"]

    entityCallee := (mut self: ref Codegen, entity: ref CodegenEntity) -> GenerateReturnType {
      self._(entity.context as str)
      return AST.createEmptyStatement()
    }

    loop i := 0; i < methods.len; i++ {
      methodName := methods[i] as str

      self.entities.push(CodegenEntity{
        name: typeName + "_" + methodName,
        codeName: typeName + "_" + methodName,
        context: name,
        generate: entityCallee,
      })
    }

    return name
  }

  fn _generateArrayType (mut self: ref Codegen, item: ref Analyzer.Type) str {
    typeName := "d4_" + self._typeName(item)
    name := typeName + "_t"

    if self._hasEntity(name) {
      return name
    }

    itemType := item.asArray()
    self._typeGen(itemType.elementType)

    self.entities.push(CodegenEntity{
      name: name,
      codeName: name,
      context: item,
      generate: (mut self: ref Codegen, entity: ref CodegenEntity) -> GenerateReturnType {
        it := entity.context as ref Analyzer.Type
        t := it.asArray()
        elementTypeName := self._typeName(t.elementType)

        return [
          AST.createExpressionStatement(AST.createMacroInvocation(self._("D4_ARRAY_DECLARE"), [
            AST.createIdentifier(elementTypeName),
            AST.createType(self._type(t.elementType)),
          ]), terminated: false),
          AST.createExpressionStatement(AST.createMacroInvocation(self._("D4_ARRAY_DEFINE"), [
            AST.createIdentifier(elementTypeName),
            AST.createType(self._type(t.elementType)),
            AST.createType(self._type(typeSafeForVaArg(self._tm(), t.elementType))),
            self._functionCopy(t.elementType, AST.createIdentifier("element")),
            self._functionEq(t.elementType, AST.createIdentifier("lhs_element"), AST.createIdentifier("rhs_element")),
            self._functionFree(t.elementType, AST.createIdentifier("element")),
            self._functionStr(t.elementType, AST.createIdentifier("element"), quote: true),
          ]), terminated: false),
        ]
      }
    })

    methods := [
      "alloc",
      "at",
      "clear",
      "concat",
      "contains",
      "copy",
      "empty",
      "eq",
      "filter",
      "first",
      "forEach",
      "free",
      "join",
      "last",
      "merge",
      "pop",
      "push",
      "realloc",
      "remove",
      "reverse",
      "slice",
      "sort",
      "str"
    ]

    entityCallee := (mut self: ref Codegen, entity: ref CodegenEntity) -> GenerateReturnType {
      self._(entity.context as str)
      return AST.createEmptyStatement()
    }

    loop i := 0; i < methods.len; i++ {
      methodName := methods[i] as str

      self.entities.push(CodegenEntity{
        name: typeName + "_" + methodName,
        codeName: typeName + "_" + methodName,
        context: name,
        generate: entityCallee,
      })
    }

    return name
  }

  fn _generateFunctionType (mut self: ref Codegen, item: ref Analyzer.Type) str {
    typeName := "d4_" + self._typeName(item)
    name := typeName + "_t"

    if self._hasEntity(name) {
      return name
    }

    itemType := item.asFunction()
    hasParams := !itemType.parameters.empty
    self._typeGen(itemType.returnType)

    if hasParams {
      loop i := 0; i < itemType.parameters.len; i++ {
        self._typeGen(itemType.parameters[i].t)
      }

      self.entities.push(CodegenEntity{
        name: name,
        codeName: name,
        context: item,
        generate: (mut self: ref Codegen, entity: ref CodegenEntity) -> GenerateReturnType {
          it := entity.context as ref Analyzer.Type
          t := it.asFunction()
          returnType := self._type(t.returnType)
          returnTypeName := self._typeName(t.returnType)
          mut parametersTypeName := ""
          mut parametersDefinition: AST.CStatement[]

          loop i := 0; i < t.parameters.len; i++ {
            parameter := t.parameters[i]
            parametersTypeName += typeParameterId(parameter) + self._typeName(parameter.t)

            if !parameter.required && !parameter.variadic {
              parametersDefinition.push(AST.createStructureMemberDeclaration(
                AST.createType("unsigned char"),
                "o" + i.str(),
              ))
            }

            parametersDefinition.push(AST.createStructureMemberDeclaration(
              AST.createType(self._type(parameter.t)),
              "n" + i.str(),
            ))
          }

          return [
            AST.createExpressionStatement(AST.createMacroInvocation(self._("D4_FUNCTION_DECLARE_WITH_PARAMS"), [
              AST.createIdentifier(t.asynchronous ? "a" : "s"),
              AST.createIdentifier(returnTypeName),
              AST.createType(returnType),
              AST.createIdentifier(parametersTypeName),
              AST.createCompoundStatement(parametersDefinition),
            ]), terminated: false),
            AST.createExpressionStatement(AST.createMacroInvocation(self._("D4_FUNCTION_DEFINE_WITH_PARAMS"), [
              AST.createIdentifier(t.asynchronous ? "a" : "s"),
              AST.createIdentifier(returnTypeName),
              AST.createType(returnType),
              AST.createIdentifier(parametersTypeName),
            ]), terminated: false),
          ]
        }
      })
    } else {
      self.entities.push(CodegenEntity{
        name: name,
        codeName: name,
        context: item,
        generate: (mut self: ref Codegen, entity: ref CodegenEntity) -> GenerateReturnType {
          it := entity.context as ref Analyzer.Type
          t := it.asFunction()
          returnType := self._type(t.returnType)
          returnTypeName := self._typeName(t.returnType)

          return [
            AST.createExpressionStatement(AST.createMacroInvocation(self._("D4_FUNCTION_DECLARE"), [
              AST.createIdentifier(t.asynchronous ? "a" : "s"),
              AST.createIdentifier(returnTypeName),
              AST.createType(returnType),
            ]), terminated: false),
            AST.createExpressionStatement(AST.createMacroInvocation(self._("D4_FUNCTION_DEFINE"), [
              AST.createIdentifier(t.asynchronous ? "a" : "s"),
              AST.createIdentifier(returnTypeName),
              AST.createType(returnType),
            ]), terminated: false),
          ]
        }
      })
    }

    methods := ["alloc", "copy", "eq", "free", "realloc", "str"]

    entityCallee := (mut self: ref Codegen, entity: ref CodegenEntity) -> GenerateReturnType {
      self._(entity.context as str)
      return AST.createEmptyStatement()
    }

    loop i := 0; i < methods.len; i++ {
      methodName := methods[i] as str

      self.entities.push(CodegenEntity{
        name: typeName + "_" + methodName,
        codeName: typeName + "_" + methodName,
        context: name,
        generate: entityCallee,
      })
    }

    if hasParams {
      self.entities.push(CodegenEntity{
        name: typeName + "_params_t",
        codeName: typeName + "_params_t",
        context: name,
        generate: entityCallee
      })
    }

    return name
  }

  fn _generateMapType (mut self: ref Codegen, item: ref Analyzer.Type) str {
    typeName := "d4_" + self._typeName(item)
    name := typeName + "_t"

    if self._hasEntity(name) {
      return name
    }

    itemType := item.asMap()
    tm := self._tm()

    self._typeGen(itemType.keyType)
    self._typeGen(itemType.valueType)
    self._typeGen(tm.createArray(itemType.keyType))
    self._typeGen(tm.createArray(itemType.valueType))

    self.entities.push(CodegenEntity{
      name: name,
      codeName: name,
      context: item,
      generate: (mut self: ref Codegen, entity: ref CodegenEntity) -> GenerateReturnType {
        it := entity.context as ref Analyzer.Type
        t := it.asMap()
        tm := self._tm()

        self._type(tm.createArray(t.keyType))
        self._type(tm.createArray(t.valueType))

        keyType := self._type(t.keyType)
        valueType := self._type(t.valueType)

        keyTypeName := self._typeName(t.keyType)
        valueTypeName := self._typeName(t.valueType)

        return [
          AST.createExpressionStatement(AST.createMacroInvocation(self._("D4_MAP_DECLARE"), [
            AST.createIdentifier(keyTypeName),
            AST.createType(keyType),
            AST.createIdentifier(valueTypeName),
            AST.createType(valueType),
          ]), terminated: false),
          AST.createExpressionStatement(AST.createMacroInvocation(self._("D4_MAP_DEFINE"), [
            AST.createIdentifier(keyTypeName),
            AST.createType(keyType),
            AST.createType(self._type(typeSafeForVaArg(tm, t.keyType))),
            self._functionCopy(t.keyType, AST.createIdentifier("key")),
            self._functionEq(t.keyType, AST.createIdentifier("lhs_key"), AST.createIdentifier("rhs_key")),
            self._functionFree(t.keyType, AST.createIdentifier("key")),
            self._functionStr(t.keyType, AST.createIdentifier("key")),
            self._functionStr(t.keyType, AST.createIdentifier("key"), quote: true),
            AST.createIdentifier(valueTypeName),
            AST.createType(valueType),
            AST.createType(self._type(typeSafeForVaArg(tm, t.valueType))),
            self._functionCopy(t.valueType, AST.createIdentifier("val")),
            self._functionEq(t.valueType, AST.createIdentifier("lhs_val"), AST.createIdentifier("rhs_val")),
            self._functionFree(t.valueType, AST.createIdentifier("val")),
            self._functionStr(t.valueType, AST.createIdentifier("val"), quote: true),
          ]), terminated: false),
        ]
      }
    })

    methods := [
      "alloc",
      "clear",
      "copy",
      "empty",
      "eq",
      "free",
      "get",
      "has",
      "keys",
      "merge",
      "realloc",
      "remove",
      "reserve",
      "set",
      "shrink",
      "str",
      "values"
    ]

    entityCallee := (mut self: ref Codegen, entity: ref CodegenEntity) -> GenerateReturnType {
      self._(entity.context as str)
      return AST.createEmptyStatement()
    }

    loop i := 0; i < methods.len; i++ {
      methodName := methods[i] as str

      self.entities.push(CodegenEntity{
        name: typeName + "_" + methodName,
        codeName: typeName + "_" + methodName,
        context: name,
        generate: entityCallee,
      })
    }

    return name
  }

  fn _generateObjectType (mut self: ref Codegen, item: ref Analyzer.Type) str {
    typeName := "d4_" + self._typeName(item)
    name := typeName + "_t"

    if self._hasEntity(name) {
      return name
    }

    self.entities.push(CodegenEntity{
      name: name,
      codeName: name,
      context: item,
      generate: (mut self: ref Codegen, entity: ref CodegenEntity) -> GenerateReturnType {
        return AST.createEmptyStatement()
      }
    })

    loop i := 0; i < item.properties.len; i++ {
      property := item.properties[i]

      if property.builtin || property.t.isMethod() {
        continue
      }

      self._typeGen(property.t)
    }

    self._removeEntity(name)

    self.entities.push(CodegenEntity{
      name: name,
      codeName: name,
      context: item,
      generate: (mut self: ref Codegen, entity: ref CodegenEntity) -> GenerateReturnType {
        it := entity.context as ref Analyzer.Type

        mut extraDeclarationArguments: (AST.CExpression | AST.CStatement | AST.CType)[]
        mut structureBlock: AST.CStatement[]
        mut allocBlock: AST.CStatement[]
        mut copyBlock: AST.CStatement[]
        mut eqExpression := AST.createIdentifier(self._("true"))
        mut freeBlock: AST.CStatement[]
        mut strBlock: AST.CStatement[]
        mut propertyIdx := 0

        loop i := 0; i < it.properties.len; i++ {
          property := it.properties[i]

          if property.builtin || property.t.isMethod() {
            continue
          }

          cPropertyType := self._type(property.t)
          cSelfProperty := AST.createPropertyAccessExpression(AST.createIdentifier("self"), property.name)

          extraDeclarationArguments.push(
            AST.createVariableDeclaration(
              AST.createType(cPropertyType, constant: true),
              property.name,
              terminated: false,
            )
          )

          structureBlock.push(
            AST.createVariableDeclaration(AST.createType(cPropertyType), property.name)
          )

          allocBlock.push(
            AST.createExpressionStatement(
              AST.createAssignmentExpression(
                cSelfProperty,
                "=",
                self._functionCopy(property.t, AST.createIdentifier(property.name)),
              ),
            ),
          )

          copyBlock.push(
            AST.createExpressionStatement(
              AST.createAssignmentExpression(
                AST.createPropertyAccessExpression(AST.createIdentifier("result"), property.name),
                "=",
                self._functionCopy(property.t, cSelfProperty),
              ),
            ),
          )

          eqExpressionPiece := self._functionEq(
            property.t,
            cSelfProperty,
            AST.createPropertyAccessExpression(AST.createIdentifier("rhs"), property.name),
          )

          eqExpression = propertyIdx == 0
            ? eqExpressionPiece
            : AST.createBinaryExpression(eqExpression, "&&", eqExpressionPiece)

          if typeShouldBeFreed(property.t) {
            freeBlock.push(
              AST.createExpressionStatement(
                self._functionFree(property.t, cSelfProperty),
              ),
            )
          }

          strBlock.push(
            AST.createExpressionStatement(
              AST.createAssignmentExpression(
                AST.createIdentifier("result"),
                "=",
                AST.createCallExpression(AST.createIdentifier(self._("d4_obj_str_append")), [
                  AST.createIdentifier("result"),
                  AST.createCallExpression(AST.createIdentifier(self._("d4_str_alloc")), [
                    AST.createLiteral("L\"" + property.name + "\""),
                  ]),
                  self._functionStr(property.t, cSelfProperty, quote: true),
                ]),
              ),
            ),
          )

          propertyIdx++
        }

        mut eqBlock: AST.CStatement[]

        if propertyIdx == 0 {
          extraDeclarationArguments.push(AST.createType("void"))

          structureBlock.push(
            AST.createVariableDeclaration(AST.createType(self._("bool")), "_")
          )

          allocBlock.push(
            AST.createExpressionStatement(
              AST.createAssignmentExpression(
                AST.createPropertyAccessExpression(AST.createIdentifier("self"), "_"),
                "=",
                AST.createIdentifier(self._("false")),
              ),
            ),
          )

          copyBlock.push(
            AST.createExpressionStatement(
              AST.createAssignmentExpression(
                AST.createPropertyAccessExpression(AST.createIdentifier("result"), "_"),
                "=",
                AST.createPropertyAccessExpression(AST.createIdentifier("self"), "_"),
              ),
            ),
          )
        }

        eqBlock.push(AST.createReturnStatement(eqExpression))

        cNameIdentifier := AST.createIdentifier(it.name)

        forwardDeclarationArguments: (AST.CExpression | AST.CStatement | AST.CType)[] = [
          cNameIdentifier,
        ]

        mut declarationArguments: (AST.CExpression | AST.CStatement | AST.CType)[] = [
          cNameIdentifier,
          AST.createCompoundStatement(structureBlock),
        ]

        mut definitionArguments: (AST.CExpression | AST.CStatement | AST.CType)[] = [
          cNameIdentifier,
          cNameIdentifier,
          AST.createCompoundStatement(allocBlock),
          AST.createCompoundStatement(copyBlock),
          AST.createCompoundStatement(eqBlock),
          AST.createCompoundStatement(freeBlock),
          AST.createCompoundStatement(strBlock),
        ]

        declarationArguments.merge(extraDeclarationArguments)
        definitionArguments.merge(extraDeclarationArguments)

        return [
          AST.createExpressionStatement(
            AST.createMacroInvocation(self._("D4_OBJECT_FORWARD_DECLARE"), forwardDeclarationArguments),
            terminated: false,
          ),
          AST.createExpressionStatement(
            AST.createMacroInvocation(self._("D4_OBJECT_DECLARE"), declarationArguments),
            terminated: false,
          ),
          AST.createExpressionStatement(
            AST.createMacroInvocation(self._("D4_OBJECT_DEFINE"), definitionArguments),
            terminated: false,
          ),
        ]
      }
    })

    methods := ["alloc", "copy", "eq", "free", "realloc", "str"]

    entityCallee := (mut self: ref Codegen, entity: ref CodegenEntity) -> GenerateReturnType {
      self._(entity.context as str)
      return AST.createEmptyStatement()
    }

    loop i := 0; i < methods.len; i++ {
      methodName := methods[i] as str

      self.entities.push(CodegenEntity{
        name: typeName + "_" + methodName,
        codeName: typeName + "_" + methodName,
        context: name,
        generate: entityCallee,
      })
    }

    return name
  }

  fn _generateOptionalType (mut self: ref Codegen, item: ref Analyzer.Type) str {
    typeName := "d4_" + self._typeName(item)
    name := typeName + "_t"

    if self._hasEntity(name) {
      return name
    }

    itemType := item.asOptional()
    self._typeGen(itemType.t)

    self.entities.push(CodegenEntity{
      name: name,
      codeName: name,
      context: item,
      generate: (mut self: ref Codegen, entity: ref CodegenEntity) -> GenerateReturnType {
        it := entity.context as ref Analyzer.Type
        t := it.asOptional()
        underlyingType := self._type(t.t)
        underlyingTypeName := self._typeName(t.t)

        return [
          AST.createExpressionStatement(AST.createMacroInvocation(self._("D4_OPTIONAL_DECLARE"), [
            AST.createIdentifier(underlyingTypeName),
            AST.createType(underlyingType),
          ]), terminated: false),
          AST.createExpressionStatement(AST.createMacroInvocation(self._("D4_OPTIONAL_DEFINE"), [
            AST.createIdentifier(underlyingTypeName),
            AST.createType(underlyingType),
            self._functionCopy(t.t, AST.createIdentifier("val")),
            self._functionEq(t.t, AST.createIdentifier("lhs_val"), AST.createIdentifier("rhs_val")),
            self._functionFree(t.t, AST.createIdentifier("val")),
            self._functionStr(t.t, AST.createIdentifier("val")),
          ]), terminated: false),
        ]
      }
    })

    methods := ["alloc", "copy", "eq", "free", "realloc", "str"]

    entityCallee := (mut self: ref Codegen, entity: ref CodegenEntity) -> GenerateReturnType {
      self._(entity.context as str)
      return AST.createEmptyStatement()
    }

    loop i := 0; i < methods.len; i++ {
      methodName := methods[i] as str

      self.entities.push(CodegenEntity{
        name: typeName + "_" + methodName,
        codeName: typeName + "_" + methodName,
        context: name,
        generate: entityCallee,
      })
    }

    return name
  }

  fn _generateReferenceType (mut self: ref Codegen, item: ref Analyzer.Type) str {
    typeName := "d4_" + self._typeName(item)
    name := typeName + "_t"

    if self._hasEntity(name) {
      return name
    }

    itemType := item.asReference()
    self._typeGen(itemType.t)

    self.entities.push(CodegenEntity{
      name: name,
      codeName: name,
      context: item,
      generate: (mut self: ref Codegen, entity: ref CodegenEntity) -> GenerateReturnType {
        it := entity.context as ref Analyzer.Type
        t := it.asReference()

        return AST.createExpressionStatement(AST.createMacroInvocation(self._("D4_REFERENCE_DECLARE"), [
          AST.createIdentifier(self._typeName(t.t)),
          AST.createType(self._type(t.t)),
        ]), terminated: false)
      }
    })

    return name
  }

  fn _generateUnionType (mut self: ref Codegen, item: ref Analyzer.Type) str {
    typeName := "d4_" + self._typeName(item)
    name := typeName + "_t"

    if self._hasEntity(name) {
      return name
    }

    itemType := item.asUnion()
    subtypesLen := itemType.types.len

    loop i := 0; i < subtypesLen; i++ {
      subtype := itemType.types[i] as ref Analyzer.Type
      self._typeGen(subtype)
    }

    self.entities.push(CodegenEntity{
      name: name,
      codeName: name,
      context: item,
      generate: (mut self: ref Codegen, entity: ref CodegenEntity) -> GenerateReturnType {
        it := entity.context as ref Analyzer.Type
        t := it.asUnion()
        unionName := entity.codeName.slice("d4_union_".len, "UE_t".len * -1)

        mut structureBlock: AST.CStatement[]
        mut allocBlock: AST.CStatement[]
        mut copyBlock: AST.CStatement[]
        mut eqBlock: AST.CStatement[]
        mut freeBlock: AST.CStatement[]
        mut strBlock: AST.CStatement[]

        loop i := 0; i < t.types.len; i++ {
          subType := t.types[i] as ref Analyzer.Type
          typeDecl := self._type(subType)
          typeDef := self._typeDef(subType)
          typeDefIdx := self.typeDefs.get(typeDef)
          typeProperty := "v" + typeDefIdx.str()

          structureBlock.push(
            AST.createVariableDeclaration(AST.createType(typeDecl), typeProperty),
          )

          allocBlock.push(
            AST.createIfStatement(
              AST.createBinaryExpression(
                AST.createPropertyAccessExpression(AST.createIdentifier("self"), "type"),
                "==",
                AST.createIdentifier(self._(typeDef)),
              ),
              AST.createExpressionStatement(
                AST.createAssignmentExpression(
                  AST.createPropertyAccessExpression(
                    AST.createPropertyAccessExpression(
                      AST.createIdentifier("self"),
                      "data",
                    ),
                    typeProperty,
                  ),
                  "=",
                  self._functionCopy(
                    subType,
                    AST.createCallExpression(AST.createIdentifier(self._("va_arg")), [
                      AST.createIdentifier("args"),
                      AST.createType(typeDecl),
                    ]),
                  ),
                ),
              ),
            ),
          )

          copyBlock.push(
            AST.createIfStatement(
              AST.createBinaryExpression(
                AST.createPropertyAccessExpression(AST.createIdentifier("self"), "type"),
                "==",
                AST.createIdentifier(self._(typeDef)),
              ),
              AST.createExpressionStatement(
                AST.createAssignmentExpression(
                  AST.createPropertyAccessExpression(
                    AST.createPropertyAccessExpression(AST.createIdentifier("result"), "data"),
                    typeProperty,
                  ),
                  "=",
                  self._functionCopy(
                    subType,
                    AST.createPropertyAccessExpression(
                      AST.createPropertyAccessExpression(AST.createIdentifier("self"), "data"),
                      typeProperty,
                    ),
                  ),
                ),
              ),
            ),
          )

          eqBlock.push(
            AST.createIfStatement(
              AST.createBinaryExpression(
                AST.createPropertyAccessExpression(AST.createIdentifier("self"), "type"),
                "==",
                AST.createIdentifier(self._(typeDef)),
              ),
              AST.createReturnStatement(
                self._functionEq(
                  subType,
                  AST.createPropertyAccessExpression(
                    AST.createPropertyAccessExpression(AST.createIdentifier("self"), "data"),
                    typeProperty,
                  ),
                  AST.createPropertyAccessExpression(
                    AST.createPropertyAccessExpression(AST.createIdentifier("rhs"), "data"),
                    typeProperty,
                  ),
                ),
              ),
            ),
          )

          if typeShouldBeFreed(subType) {
            freeBlock.push(
              AST.createIfStatement(
                AST.createBinaryExpression(
                  AST.createPropertyAccessExpression(AST.createIdentifier("self"), "type"),
                  "==",
                  AST.createIdentifier(self._(typeDef)),
                ),
                AST.createExpressionStatement(
                  self._functionFree(
                    subType,
                    AST.createPropertyAccessExpression(
                      AST.createPropertyAccessExpression(AST.createIdentifier("self"), "data"),
                      typeProperty,
                    ),
                  ),
                ),
              ),
            )
          }

          strBlock.push(
            AST.createIfStatement(
              AST.createBinaryExpression(
                AST.createPropertyAccessExpression(AST.createIdentifier("self"), "type"),
                "==",
                AST.createIdentifier(self._(typeDef)),
              ),
              AST.createReturnStatement(
                self._functionStr(
                  subType,
                  AST.createPropertyAccessExpression(
                    AST.createPropertyAccessExpression(AST.createIdentifier("self"), "data"),
                    typeProperty,
                  ),
                ),
              ),
            ),
          )
        }

        return [
          AST.createExpressionStatement(AST.createMacroInvocation(self._("D4_UNION_DECLARE"), [
            AST.createIdentifier(unionName),
            AST.createCompoundStatement(structureBlock),
          ]), terminated: false),
          AST.createExpressionStatement(AST.createMacroInvocation(self._("D4_UNION_DEFINE"), [
            AST.createIdentifier(unionName),
            AST.createCompoundStatement(allocBlock),
            AST.createCompoundStatement(copyBlock),
            AST.createCompoundStatement(eqBlock),
            AST.createCompoundStatement(freeBlock),
            AST.createCompoundStatement(strBlock),
          ]), terminated: false),
        ]
      }
    })

    methods := ["alloc", "copy", "eq", "free", "realloc", "str"]

    entityCallee := (mut self: ref Codegen, entity: ref CodegenEntity) -> GenerateReturnType {
      self._(entity.context as str)
      return AST.createEmptyStatement()
    }

    loop i := 0; i < methods.len; i++ {
      methodName := methods[i] as str

      self.entities.push(CodegenEntity{
        name: typeName + "_" + methodName,
        codeName: typeName + "_" + methodName,
        context: name,
        generate: entityCallee,
      })
    }

    return name
  }

  fn _getEntity (self: ref Self, name: str) ref CodegenEntity {
    loop i := self.entities.len - 1; i >= 0; i-- {
      entity := self.entities[i]

      if entity.name == name {
        return entity
      }
    }

    throw error_NewError("Entity with name '" + name + "' doesn't exists")
  }

  fn _hasEntity (self: ref Self, name: str, withBuiltin := true) bool {
    loop i := self.entities.len - 1; i >= 0; i-- {
      entity := self.entities[i]

      if entity.name == name {
        return true
      }
    }

    if withBuiltin {
      builtinEntitiesValues := BUILTIN_ENTITIES.values

      loop i := builtinEntitiesValues.len - 1; i >= 0; i-- {
        entityValues := builtinEntitiesValues[i]

        if entityValues.contains(name) {
          return true
        }
      }
    }

    return false
  }

  fn _isArc (self: ref Self, item: ref Parser.Expression) bool {
    itemDown := expressionResolve(item, down: true)

    if !itemDown.isIdentifier() {
      return false
    }

    expression := itemDown.asIdentifier()

    if !self.blockData.hasVariable(expression.name) {
      return false
    }

    blockDataVariable := self.blockData.getVariable(expression.name)
    return blockDataVariable.referenced
  }

  fn _r (mut self: ref Self) ref Parser.Reader {
    mut file := self.analyzer.files.last()
    return ref file.reader
  }

  fn _removeEntity (mut self: ref Self, name: str) void {
    loop i := self.entities.len - 1; i >= 0; i-- {
      entity := self.entities[i]

      if entity.name == name {
        self.entities.remove(i)
        return
      }
    }

    throw error_NewError("Entity '" + name + "' can't be removed")
  }

  fn _str (mut self: ref Self, content: str) AST.CExpression {
    escapedContent := content.replace("\\", "\\\\").replace("\"", "\\\"")

    return AST.createCastExpression(
      AST.createType(self._("d4_str_t")),
      AST.createInitializerListExpression([
        AST.createLiteral("L\"" + escapedContent + "\""),
        AST.createLiteral(escapedContent.len.str()),
        AST.createIdentifier(self._("true")),
      ]),
    )
  }

  fn _tm (mut self: ref Self) ref Analyzer.TypeMap {
    mut file := self.analyzer.files.last()
    return ref file.tm
  }

  fn _tmpVar (mut self: ref Self) str {
    self.lastVarId++
    return "__THE_" + self.lastVarId.str()
  }

  fn _type (mut self: ref Self, it: ref Analyzer.Type, postfix := "_t", arc := false) str {
    mut result := ""

    if arc {
      self._typeGen(it, arc: true)
      result = self._("d4_" + self._typeName(it, arc: true) + postfix) + (postfix.slice(-3) == "_t" ? " " : "")
    } elif it.isAlias() {
      t := it.asAlias()
      result = self._type(t.t)
    } elif it.name == "any" {
      result = self._("d4_any" + postfix) + (postfix.slice(-3) == "_t" ? " " : "")
    } elif it.name == "bool" {
      if postfix == "_t" {
        result = self._("bool") + " "
      } else {
        result = self._("d4_bool" + postfix) + (postfix.slice(-3) == "_t" ? " " : "")
      }
    } elif it.name == "byte" {
      if postfix == "_t" {
        result = "unsigned char "
      } else {
        result = self._("d4_byte" + postfix) + (postfix.slice(-3) == "_t" ? " " : "")
      }
    } elif it.name == "char" {
      if postfix == "_t" {
        result = "char "
      } else {
        result = self._("d4_char" + postfix) + (postfix.slice(-3) == "_t" ? " " : "")
      }
    } elif it.name == "f32" {
      if postfix == "_t" {
        result = "float "
      } else {
        result = self._("d4_f32" + postfix) + (postfix.slice(-3) == "_t" ? " " : "")
      }
    } elif it.name == "f64" {
      if postfix == "_t" {
        result = "double "
      } else {
        result = self._("d4_f64" + postfix) + (postfix.slice(-3) == "_t" ? " " : "")
      }
    } elif it.name == "float" {
      if postfix == "_t" {
        result = "double "
      } else {
        result = self._("d4_float" + postfix) + (postfix.slice(-3) == "_t" ? " " : "")
      }
    } elif it.name == "i8" {
      if postfix == "_t" {
        result = self._("int8_t") + " "
      } else {
        result = self._("d4_i8" + postfix) + (postfix.slice(-3) == "_t" ? " " : "")
      }
    } elif it.name == "i16" {
      if postfix == "_t" {
        result = self._("int16_t") + " "
      } else {
        result = self._("d4_i16" + postfix) + (postfix.slice(-3) == "_t" ? " " : "")
      }
    } elif it.name == "i32" {
      if postfix == "_t" {
        result = self._("int32_t") + " "
      } else {
        result = self._("d4_i32" + postfix) + (postfix.slice(-3) == "_t" ? " " : "")
      }
    } elif it.name == "int" {
      if postfix == "_t" {
        result = self._("int32_t") + " "
      } else {
        result = self._("d4_int" + postfix) + (postfix.slice(-3) == "_t" ? " " : "")
      }
    } elif it.name == "i64" {
      if postfix == "_t" {
        result = self._("int64_t") + " "
      } else {
        result = self._("d4_i64" + postfix) + (postfix.slice(-3) == "_t" ? " " : "")
      }
    } elif it.name == "isize" {
      if postfix == "_t" {
        result = self._("ptrdiff_t") + " "
      } else {
        result = self._("d4_isize" + postfix) + (postfix.slice(-3) == "_t" ? " " : "")
      }
    } elif it.name == "rune" {
      if postfix == "_t" {
        result = self._("wchar_t") + " "
      } else {
        result = self._("d4_rune" + postfix) + (postfix.slice(-3) == "_t" ? " " : "")
      }
    } elif it.name == "str" {
      result = self._("d4_str" + postfix) + (postfix.slice(-3) == "_t" ? " " : "")
    } elif it.name == "u8" {
      if postfix == "_t" {
        result = self._("uint8_t") + " "
      } else {
        result = self._("d4_u8" + postfix) + (postfix.slice(-3) == "_t" ? " " : "")
      }
    } elif it.name == "u16" {
      if postfix == "_t" {
        result = self._("uint16_t") + " "
      } else {
        result = self._("d4_u16" + postfix) + (postfix.slice(-3) == "_t" ? " " : "")
      }
    } elif it.name == "u32" {
      if postfix == "_t" {
        result = self._("uint32_t") + " "
      } else {
        result = self._("d4_u32" + postfix) + (postfix.slice(-3) == "_t" ? " " : "")
      }
    } elif it.name == "u64" {
      if postfix == "_t" {
        result = self._("uint64_t") + " "
      } else {
        result = self._("d4_u64" + postfix) + (postfix.slice(-3) == "_t" ? " " : "")
      }
    } elif it.name == "usize" {
      if postfix == "_t" {
        result = self._("size_t") + " "
      } else {
        result = self._("d4_usize" + postfix) + (postfix.slice(-3) == "_t" ? " " : "")
      }
    } elif it.name == "void" {
      result = "void "
    } elif (
      it.isArray() ||
      it.isEnum() ||
      it.isFunction() ||
      it.isMap() ||
      it.isMethod() ||
      it.isCustomObject() ||
      it.isOptional() ||
      it.isReference() ||
      it.isUnion()
    ) {
      self._typeGen(it)
      result = self._("d4_" + self._typeName(it) + postfix) + (postfix.slice(-3) == "_t" ? " " : "")
    }

    if result.empty {
      throw error_NewError("Failed to generate type for '" + it.toString() + "'")
    }

    return result
  }

  fn _typeGen (mut self: ref Self, it: ref Analyzer.Type, arc := false) {
    if arc {
      self._generateArcType(it)
    } elif it.isAlias() {
      t := it.asAlias()
      self._typeGen(t.t)
    } elif it.isArray() {
      self._generateArrayType(it)
    } elif it.isCustomObject() {
      self._generateObjectType(it)
    } elif it.isFunction() {
      self._generateFunctionType(it)
    } elif it.isMap() {
      self._generateMapType(it)
    } elif it.isMethod() {
      tm := self._tm()
      self._generateFunctionType(tm.convertMethod(it))
    } elif it.isOptional() {
      self._generateOptionalType(it)
    } elif it.isReference() {
      self._generateReferenceType(it)
    } elif it.isUnion() {
      self._generateUnionType(it)
    }
  }

  fn _typeDef (mut self: ref Self, it: ref Analyzer.Type) str {
    typeName := "TYPE_" + self._typeName(it)

    if self._hasEntity(typeName) {
      return typeName
    }

    lastTypeId := ++self.lastTypeId
    self.typeDefs.set(typeName, lastTypeId)

    self.entities.push(CodegenEntity{
      name: typeName,
      codeName: typeName,
      context: it,
      generate: (mut self: ref Codegen, entity: ref CodegenEntity) -> GenerateReturnType {
        typeDefIdx := self.typeDefs.get(entity.codeName)
        return AST.createDefineDirective(entity.codeName, nil, typeDefIdx.str())
      },
    })

    return typeName
  }

  fn _typeName (mut self: ref Self, it: ref Analyzer.Type, arc := false) str {
    if arc {
      return "arc_" + self._typeName(it)
    } elif it.isAlias() {
      t := it.asAlias()
      return self._typeName(t.t)
    } elif it.isArray() {
      t := it.asArray()
      return "arr_" + self._typeName(t.elementType)
    } elif it.isCustomObject() {
      return "obj_" + it.name
    } elif it.isEnum() || it.isObject() {
      return it.name
    } elif it.isFunction() {
      t := it.asFunction()
      mut name := "fn_" + (t.asynchronous ? "a" : "s")

      loop i := 0; i < t.parameters.len; i++ {
        parameter := t.parameters[i]
        name += typeParameterId(parameter) + self._typeName(parameter.t)
      }

      return name + "FR" + self._typeName(t.returnType) + "FE"
    } elif it.isMap() {
      t := it.asMap()
      return "map_" + self._typeName(t.keyType) + "MS" + self._typeName(t.valueType) + "ME"
    } elif it.isMethod() {
      tm := self._tm()
      return self._typeName(tm.convertMethod(it))
    } elif it.isOptional() {
      t := it.asOptional()
      return "opt_" + self._typeName(t.t)
    } elif it.isReference() {
      t := it.asReference()
      return "ref_" + self._typeName(t.t)
    } elif it.isUnion() {
      t := it.asUnion()
      mut names: str[]

      loop i := 0; i < t.types.len; i++ {
        subType := t.types[i] as ref Analyzer.Type
        names.push(self._typeName(subType))
      }

      namesSorted := names.sort(sortStrAsc)
      return "union_" + namesSorted.join("US") + "UE"
    }

    throw error_NewError("Failed to generate type name for '" + it.name + "'")
  }

  fn _wrap (mut self: ref Self, mut expression: AST.CExpression, item: ref Parser.Expression, t: ref Analyzer.Type, targetType: ref Analyzer.Type, allocate := false, deallocate := false, arc := false) AST.CExpression {
    shouldFree := deallocate && typeShouldBeFreed(targetType) && expressionShouldBeFreed(item)
    shouldAllocateBefore := typeShouldBeAllocated(t) && expressionShouldBeAllocatedBefore(item)

    shouldAllocateAfter :=
      arc ||
      (targetType.name == "any" && t.name != "any") ||
      (targetType.isOptional() && !t.isOptional()) ||
      (targetType.isUnion() && !t.isUnion())

    shouldPreAllocate :=
      (allocate && !shouldFree && shouldAllocateBefore) ||
      (!allocate && !shouldFree && shouldAllocateBefore && shouldAllocateAfter)

    if shouldPreAllocate {
      expression = self._allocateExpression(t, expression)
    }

    if targetType.name == "any" && t.name != "any" {
      typeName := self._generateAnyType(t)
      allocAnyType := typeName.slice(0, -2) + "_alloc"
      expression = AST.createCallExpression(AST.createIdentifier(self._(allocAnyType)), [expression])
    } elif targetType.name != "any" && t.name == "any" {
      typeName := self._generateAnyType(targetType)

      // TODO: throw runtime error if not possible to cast
      innerExpression := AST.createCastExpression(
        AST.createType(self._(typeName)),
        createASTPropertyAccess(expression, "ctx"),
      )

      expression = AST.createUnaryExpression("*", innerExpression.wrap())
    } elif targetType.isOptional() && !t.isOptional() {
      allocOptionalType := self._generateOptionalType(targetType).slice(0, -2) + "_alloc"
      expression = AST.createCallExpression(AST.createIdentifier(self._(allocOptionalType)), [expression])
    } elif !targetType.isReference() && t.isReference() {
      expression = AST.createUnaryExpression("*", expression)
    } elif targetType.isReference() && !t.isReference() {
      expression = AST.createUnaryExpression("&", expression)
    } elif targetType.isUnion() && !t.isUnion() {
      allocTargetType := self._type(targetType, "_alloc")
      typeDef := self._typeDef(t)
      cTypeDef := AST.createIdentifier(self._(typeDef))
      expression = AST.createCallExpression(AST.createIdentifier(allocTargetType), [cTypeDef, expression])
    } elif !targetType.isUnion() && t.isUnion() {
      typeDef := self._typeDef(targetType)
      typeDefIdx := self.typeDefs.get(typeDef)

      // TODO: throw runtime error if not possible to access
      expression = AST.createPropertyAccessExpression(
        createASTPropertyAccess(expression, "data"),
        "v" + typeDefIdx.str(),
      )
    } elif !Analyzer.match(t, targetType) && (
      targetType.name == "bool" ||
      targetType.name == "byte" ||
      targetType.name == "char" ||
      targetType.name == "rune" ||
      targetType.isNumber()
    ) {
      expression = AST.createCastExpression(AST.createType(self._type(targetType)), expression)
    }

    if arc {
      typeName := self._generateArcType(t)
      allocAnyType := typeName.slice(0, -2) + "_alloc"
      expression = AST.createCallExpression(AST.createIdentifier(self._(allocAnyType)), [expression])
    }

    if deallocate && shouldFree {
      expression = self._functionFree(targetType, expression)
    } elif allocate && expressionShouldBeAllocatedAfter(item) && shouldAllocateAfter {
      expression = self._allocateExpression(targetType, expression)
    }

    return expression
  }
}

export fn compile (analyzer: ref Analyzer.Analyzer, executablePath: str, release := false, sanitize := false) {
  mut generator := Codegen{analyzer: analyzer, release: release, sanitize: sanitize}
  codePath := executablePath + ".c"
  mut caughtError: error_Error?

  try {
    generator.init()
    generator.generate()

    fs_writeFileSync(codePath, generator.stringify().toBuffer())
    process_runSync("clang '" + codePath + "' -o '" + executablePath + "' " + generator.getFlags())
  } catch err: error_Error {
    caughtError = err
  }

  fs_rmSync(codePath)

  if caughtError != nil {
    throw caughtError
  }
}
