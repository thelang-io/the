/*!
 * Copyright (c) Aaron Delasy
 * Licensed under the MIT License
 */

import * as Analyzer from "the/analyzer"
import * as AST from "the/c"
import * as Parser from "the/parser"

// todo error object needs special generation rules to move message and stack properties up front

export obj CodegenAPIBuiltin {
  mut theAny: bool
  mut theArray: bool
  mut theBool: bool
  mut theByte: bool
  mut theError: bool
  mut theFn: bool
  mut theMacro: bool
  mut theNumber: bool
  mut theOptional: bool
  mut theReference: bool
  mut theSafe: bool
  mut theString: bool
  mut theThreadPool: bool
  mut theUnion: bool
  mut stdarg: bool
  mut stdbool: bool
  mut stddef: bool
  mut stdint: bool
  mut stdio: bool
  mut stdlib: bool
  mut wchar: bool
}

export obj BlockData {
  mut cleanup: AST.CStatement[]

  fn addCleanup (mut self: ref Self, item: AST.CStatement) {
    self.cleanup.push(item)
  }

  fn hasCleanup (mut self: ref Self) bool {
    return self.cleanup.empty
  }

  fn getCleanup (mut self: ref Self) AST.CStatement[] {
    mut cleanup := self.cleanup.reverse()
    self.cleanup = []
    return cleanup
  }
}

export obj CodegenEntity {
  mut active: bool
  mut name: str
  mut codeName: str
  mut context: any
  mut generate: (mut self: ref Codegen, mut tm: ref Analyzer.TypeMap, entity: ref CodegenEntity) -> AST.CStatement | AST.CStatement[]
}

export fn typeParameterId (parameter: ref Analyzer.TypeParameter) str {
  if parameter.mutable && parameter.required { return "FP5" }
  elif parameter.mutable && parameter.variadic { return "FP6" }
  elif parameter.mutable { return "FP2" }
  elif parameter.required { return "FP3" }
  elif parameter.variadic { return "FP4" }
  else { return "FP1" }
}

export fn typePrimitive (it: ref Analyzer.Type) bool {
  return !(
    it.name == "any" ||
    it.name == "str" ||
    it.isArray() ||
    it.isFunction() ||
    it.isMap() ||
    // todo
    // it.isObject() ||
    it.isOptional() ||
    it.isUnion()
  )
}

export fn typeSafeForTernaryAlternate (it: ref Analyzer.Type) bool {
  return it.name == "any" ||
    it.name == "str" ||
    it.isArray() ||
    it.isFunction() ||
    it.isMap() ||
    // todo
    // it.isObj() ||
    it.isOptional() ||
    it.isUnion()
}

export fn typeSafeForVaArg (mut tm: ref Analyzer.TypeMap, it: ref Analyzer.Type) ref Analyzer.Type {
  return ["i8", "i16", "u8", "u16", "byte", "char"].contains(it.name) ? tm.get("i32") : it
}

export fn typeShouldBeFreed (self: ref Analyzer.Type) bool {
  if self.isAlias() {
    t := self.asAlias()
    return typeShouldBeFreed(t.t)
  } elif self.isUnion() {
    t := self.asUnion()

    loop i := 0; i < t.types.len; i++ {
      subType := t.types[i]

      if typeShouldBeFreed(subType) {
        return true
      }
    }

    return false
  }

  return
    self.name == "any" ||
    self.name == "str" ||
    self.isArray() ||
    self.isFunction() ||
    self.isMap() ||
    self.isOptional()
}

export fn validateContext (valid: bool) {
  if !valid {
    throw error_NewError("Context is not set")
  }
}

export obj Codegen {
  mut analyzer: ref Analyzer.Analyzer
  mut builtin: CodegenAPIBuiltin
  mut blockData: BlockData
  mut entities: CodegenEntity[]
  mut flags: str[]
  mut lastTypeId: int
  mut mainStatements: AST.CStatement[]
  mut globalStatements: AST.CStatement[]
  mut statements: AST.CStatement[]
  mut typeDefs: int[str]

  fn init (mut self: ref Self) {
  }

  fn generate (mut self: ref Self) {
    mut file := self.analyzer.files.last()
    self.globalStatements = self._generateBlock(ref file.f.program.body)
    self._assemble()
  }

  fn getFlags (self: ref Self) str {
    mut extraFlags: str[]

    if (
      self.builtin.theAny ||
      self.builtin.theArray ||
      self.builtin.theBool ||
      self.builtin.theByte ||
      self.builtin.theFn ||
      self.builtin.theError ||
      self.builtin.theMacro ||
      self.builtin.theNumber ||
      self.builtin.theOptional ||
      self.builtin.theReference ||
      self.builtin.theSafe ||
      self.builtin.theString ||
      self.builtin.theThreadPool ||
      self.builtin.theUnion
    ) {
      extraFlags.push("-lthe")
    }

    result := [
      "-O0",
      "-Wall",
      "-Werror",
      "-Wextra",
      "-pedantic-errors",
      "-Wno-gnu-binary-literal",
      "-Wno-strict-prototypes",
      "-Wno-unused-but-set-variable",
      "-Wno-unused-value",
      "-Wno-unused-variable",
    ].concat(extraFlags).join(" ")

    return result.empty ? "" : (" " + result)
  }

  fn stringify (self: ref Self) str {
    mut result := ""
    l := self.statements.len

    loop i := 0; i < l; i++ {
      result += self.statements[i].stringify()
    }

    return result
  }

  fn _ (mut self: ref Self, name: str) str {
    if self._hasEntity(name) {
      mut item := self._getEntity(name)

      if !item.active {
        item.active = true
      }

      return item.codeName
    } elif ["va_arg", "va_copy", "va_end", "va_list", "va_start"].contains(name) {
      self.builtin.stdarg = true
    } elif ["bool", "false", "true"].contains(name) {
      self.builtin.stdbool = true
    } elif (
      [
        "EXIT_FAILURE",
        "NULL",
        "exit",
        "size_t"
      ].contains(name)
    ) {
      self.builtin.stddef = true
    } elif (
      [
        "fprintf",
        "printf",
        "snprintf",
        "sprintf",
        "stderr",
        "stdin",
        "stdout"
      ].contains(name)
    ) {
      self.builtin.stdio = true
    } elif (
      [
        "int8_t",
        "int16_t",
        "int32_t",
        "int64_t",
        "uint8_t",
        "uint16_t",
        "uint32_t",
        "uint64_t"
      ].contains(name)
    ) {
      self.builtin.stdint = true
    } elif (
      [
        "wchar_t"
      ].contains(name)
    ) {
      self.builtin.wchar = true
    } elif (
      [
        "the_any_t",
        "the_any_copy",
        "the_any_eq",
        "the_any_free",
        "the_any_ne",
        "the_any_realloc",
        "the_any_str"
      ].contains(name)
    ) {
      self.builtin.theAny = true
    } elif ["THE_ARRAY_DECLARE", "THE_ARRAY_DEFINE"].contains(name) {
      self.builtin.theArray = true
    } elif ["the_bool_str"].contains(name) {
      self.builtin.theBool = true
    } elif ["the_byte_str"].contains(name) {
      self.builtin.theByte = true
    } elif (
      [
        "the_Error_t",
        "the_err_buf_t",
        "the_err_stack_t",
        "the_err_state",
        "the_err_state_t",
        "the_error_assign",
        "the_error_assign_generic",
        "the_error_buf_decrease",
        "the_error_buf_increase",
        "the_error_stack_pop",
        "the_error_stack_push",
        "the_error_unset",
        "the_Error_alloc",
        "the_Error_free"
      ].contains(name)
    ) {
      self.builtin.theError = true
    } elif (
      [
        "THE_FUNCTION_DECLARE",
        "THE_FUNCTION_DECLARE_WITH_PARAMS",
        "THE_FUNCTION_DEFINE",
        "THE_FUNCTION_DEFINE_WITH_PARAMS",
        "the_fn_ctx_free_generic"
      ].contains(name)
    ) {
      self.builtin.theFn = true
    } elif ["THE_OS_WINDOWS", "THE_OS_MACOS", "THE_OS_LINUX", "THE_EOL", "THE_PATH_SEP"].contains(name) {
      self.builtin.theMacro = true
    } elif (
      [
        "the_f32_str",
        "the_f64_str",
        "the_float_str",
        "the_i8_str",
        "the_i16_str",
        "the_i32_str",
        "the_i64_str",
        "the_int_str",
        "the_isize_str",
        "the_u8_str",
        "the_u16_str",
        "the_u32_str",
        "the_u64_str",
        "the_usize_str"
      ].contains(name)
    ) {
      self.builtin.theNumber = true
    } elif ["THE_OPTIONAL_DECLARE", "THE_OPTIONAL_DEFINE"].contains(name) {
      self.builtin.theOptional = true
    } elif ["THE_REFERENCE_DECLARE"].contains(name) {
      self.builtin.theReference = true
    } elif ["the_safe_alloc", "the_safe_free", "the_safe_realloc", "the_safe_swap"].contains(name) {
      self.builtin.theSafe = true
    } elif ["the_thread_pool_init"].contains(name) {
      self.builtin.theThreadPool = true
    } elif (
      [
        "the_str_t",
        "the_str_alloc",
        "the_str_calloc",
        "the_str_at",
        "the_str_concat",
        "the_str_contains",
        "the_str_copy",
        "the_str_empty",
        "the_str_eq",
        "the_str_escape",
        "the_str_find",
        "the_str_free",
        "the_str_ge",
        "the_str_gt",
        "the_str_le",
        "the_str_lines",
        "the_str_lower",
        "the_str_lowerFirst",
        "the_str_lt",
        "the_str_ne",
        "the_str_not",
        "the_str_realloc",
        "the_str_replace",
        "the_str_slice",
        "the_str_split",
        "the_str_toFloat",
        "the_str_toF32",
        "the_str_toF64",
        "the_str_toIsize",
        "the_str_toI8",
        "the_str_toI16",
        "the_str_toI32",
        "the_str_toI64",
        "the_str_toUsize",
        "the_str_toU8",
        "the_str_toU16",
        "the_str_toU32",
        "the_str_toU64",
        "the_str_trim",
        "the_str_trimEnd",
        "the_str_trimStart",
        "the_str_upper",
        "the_str_upperFirst"
      ].contains(name)
    ) {
      self.builtin.theString = true
    } elif ["THE_UNION_DECLARE", "THE_UNION_DEFINE"].contains(name) {
      self.builtin.theUnion = true
    } else {
      throw error_NewError("Tried activating unknown entity '" + name + "'")
    }

    return name
  }

  fn _assemble (mut self: ref Self) {
    mut statements: AST.CStatement[]
    mut file := self.analyzer.files.last()
    mut prevActive := 0

    loop {
      statements = []
      mut currentActive := 0

      loop i := 0; i < self.entities.len; i++ {
        entity := self.entities[i]

        if !entity.active {
          continue
        }

        result := entity.generate(self, ref file.tm, entity)

        if result is AST.CStatement {
          statements.push(result)
        } else {
          resultStatements := result
          statements.merge(resultStatements)
        }

        currentActive++
      }

      if prevActive == currentActive {
        break
      }

      prevActive = currentActive
    }

    if self.builtin.theAny { self.statements.push(AST.createIncludeDirective("the/any.h")) }
    if self.builtin.theArray { self.statements.push(AST.createIncludeDirective("the/array.h")) }
    if self.builtin.theBool { self.statements.push(AST.createIncludeDirective("the/bool.h")) }
    if self.builtin.theByte { self.statements.push(AST.createIncludeDirective("the/byte.h")) }
    if self.builtin.theError { self.statements.push(AST.createIncludeDirective("the/error.h")) }
    if self.builtin.theFn { self.statements.push(AST.createIncludeDirective("the/fn.h")) }
    if self.builtin.theMacro { self.statements.push(AST.createIncludeDirective("the/macro.h")) }
    if self.builtin.theNumber { self.statements.push(AST.createIncludeDirective("the/number.h")) }
    if self.builtin.theOptional { self.statements.push(AST.createIncludeDirective("the/optional.h")) }
    if self.builtin.theReference { self.statements.push(AST.createIncludeDirective("the/reference.h")) }
    if self.builtin.theSafe { self.statements.push(AST.createIncludeDirective("the/safe.h")) }
    if self.builtin.theString { self.statements.push(AST.createIncludeDirective("the/string.h")) }
    if self.builtin.theThreadPool { self.statements.push(AST.createIncludeDirective("the/thread-pool.h")) }
    if self.builtin.theUnion { self.statements.push(AST.createIncludeDirective("the/union.h")) }

    if self.builtin.stdarg { self.statements.push(AST.createIncludeDirective("stdarg.h")) }
    if self.builtin.stdbool { self.statements.push(AST.createIncludeDirective("stdbool.h")) }
    if self.builtin.stddef { self.statements.push(AST.createIncludeDirective("stddef.h")) }
    if self.builtin.stdio { self.statements.push(AST.createIncludeDirective("stdio.h")) }
    if self.builtin.stdint { self.statements.push(AST.createIncludeDirective("stdint.h")) }
    if self.builtin.stdlib { self.statements.push(AST.createIncludeDirective("stdlib.h")) }
    if self.builtin.wchar { self.statements.push(AST.createIncludeDirective("wchar.h")) }

    self.statements.merge(statements)

    self.statements.push(
      AST.createFunctionDeclaration(
        AST.createType("int"),
        "main",
        [],
        AST.createCompoundStatement(self.mainStatements)
      )
    )
  }

  fn _defaultInitializerObjectExpression (mut self: ref Self, it: ref Analyzer.Type) AST.CExpression {
    if it.isAlias() {
      t := it.asAlias()
      return self._defaultInitializerObjectExpression(t.t)
    } elif it.name == "any" {
      return AST.createCastExpression(AST.createType(self._("the_any_t")), AST.createInitializerListExpression([
        AST.createLiteral(-1),
        AST.createIdentifier(self._("NULL")),
        AST.createIdentifier(self._("NULL")),
        AST.createIdentifier(self._("NULL")),
        AST.createIdentifier(self._("NULL")),
        AST.createIdentifier(self._("NULL"))
      ]))
    } elif it.name == "bool" {
      return AST.createIdentifier(self._("false"))
    } elif it.name == "char" {
      return AST.createLiteral("'\\0'")
    } elif it.name == "str" {
      return AST.createCallExpression(AST.createIdentifier(self._("the_str_alloc")), [
        AST.createLiteral("\"\"")
      ])
    } elif it.isArray() || it.isMap() {
      typeName := self._typeName(it)

      return AST.createCallExpression(AST.createIdentifier(self._("the_" + typeName + "_alloc")), [
        AST.createLiteral(0)
      ])
    // todo
    // } elif it.isObject() {
      // typeName := self._typeName(it)
      // mut args: AST.CExpression[]
      // loop i := 0; i < it.properties.len; i++ {
      //   property := it.properties[i]
      //   if property.builtin || property.t.isMethod() {
      //     continue
      //   }
      //   args.push(self._defaultInitializerObjectExpression(property.t))
      // }
      // return AST.createCallExpression(AST.createIdentifier(self._(typeName + "_alloc")), args)
    } elif it.isOptional() {
      return AST.createIdentifier(self._("NULL"))
    } elif it.isUnion() {
      // todo
    } elif !it.isFunction() && !it.isReference() {
      return AST.createLiteral(0)
    }

    throw error_NewError("Tried default object expressions declaration on unknown type")
  }

  fn _defaultInitializerVariableDeclaration (mut self: ref Self, it: ref Analyzer.Type) AST.CExpression {
    if it.isAlias () {
      t := it.asAlias()
      return self._defaultInitializerVariableDeclaration(t.t)
    } elif it.name == "any" {
      return AST.createInitializerListExpression([
        AST.createLiteral(-1),
        AST.createIdentifier(self._("NULL")),
        AST.createIdentifier(self._("NULL")),
        AST.createIdentifier(self._("NULL")),
        AST.createIdentifier(self._("NULL")),
        AST.createIdentifier(self._("NULL"))
      ])
    } elif it.name == "bool" {
      return AST.createIdentifier(self._("false"))
    } elif it.name == "char" {
      return AST.createLiteral("'\\0'")
    } elif it.name == "str" {
      return AST.createCallExpression(AST.createIdentifier(self._("the_str_alloc")), [AST.createLiteral("\"\"")])
    } elif it.isArray() || it.isMap() {
      typeName := self._typeName(it)
      return AST.createCallExpression(AST.createIdentifier(self._("the_" + typeName + "_alloc")), [
        AST.createLiteral(0)
      ])
    // todo
    // } elif it.isObject() {
      // typeName := self._typeName(it)
      // mut args : AST.CExpression[]
      // loop i := 0; i < it.properties.len; i++ {
      //   property := it.properties[i]
      //   if property.builtin || property.t.isMethod() {
      //     continue
      //   }
      //   args.push(self._defaultInitializerObjectExpression(property.t))
      // }
      // return AST.createCallExpression(AST.createIdentifier(self._(typeName + "_alloc")), args)
    } elif it.isOptional() {
      return AST.createIdentifier(self._("NULL"))
    } elif it.isUnion() {
      // todo
    } elif !it.isFunction() && !it.isReference() {
      return AST.createLiteral(0)
    }

    throw error_NewError("Tried default initializer variable declaration on unknown type")
  }

  fn _functionCopy (mut self: ref Self, it: ref Analyzer.Type, expression: AST.CExpression) AST.CExpression {
    if it.isAlias() {
      t := it.asAlias()
      return self._functionCopy(t.t, expression)
    } elif it.name == "any" {
      return AST.createCallExpression(AST.createIdentifier(self._("the_any_copy")), [expression])
    } elif it.name == "str" {
      return AST.createCallExpression(AST.createIdentifier(self._("the_str_copy")), [expression])
    } elif (
      it.isArray() ||
      it.isFunction() ||
      it.isMap() ||
      // todo
      // it.isObject() ||
      it.isOptional() ||
      it.isUnion()
    ) {
      typeName := self._typeName(it)
      return AST.createCallExpression(AST.createIdentifier(self._(typeName + "_copy")), [expression])
    }

    return expression
  }

  fn _functionEq (mut self: ref Self, it: ref Analyzer.Type, left: AST.CExpression, right: AST.CExpression, reverse := false) AST.CExpression {
    direction := reverse ? "ne" : "eq"

    if it.isAlias() {
      t := it.asAlias()
      return self._functionEq(t.t, left, right, reverse)
    } elif it.name == "any" {
      return AST.createCallExpression(AST.createIdentifier(self._("the_any_" + direction)), [left, right])
    } elif it.name == "str" {
      return AST.createCallExpression(AST.createIdentifier(self._("the_str_" + direction)), [left, right])
    } elif (
      it.isArray() ||
      it.isMap() ||
      // todo
      // it.isObject() ||
      it.isOptional() ||
      it.isUnion()
    ) {
      typeName := self._typeName(it)
      return AST.createCallExpression(AST.createIdentifier(self._(typeName + "_" + direction)), [left, right])
    } else {
      return AST.createAssignmentExpression(left, reverse ? "!=" : "==", right)
    }
  }

  fn _functionFree (mut self: ref Self, it: ref Analyzer.Type, expression: AST.CExpression) AST.CExpression {
    if it.isAlias() {
      t := it.asAlias()
      return self._functionFree(t.t, expression)
    } elif it.name == "any" {
      return AST.createCallExpression(AST.createIdentifier(self._("the_any_free")), [expression])
    } elif it.name == "str" {
      return AST.createCallExpression(AST.createIdentifier(self._("the_str_free")), [expression])
    } elif it.isArray() {
      typeName := self._typeName(it)
      return AST.createCallExpression(AST.createIdentifier(self._("the_" + typeName + "_free")), [expression])
    } elif (
      it.isArray() ||
      it.isFunction() ||
      it.isMap() ||
      // todo
      // it.isObject() ||
      it.isOptional() ||
      it.isUnion()
    ) {
      typeName := self._typeName(it)
      return AST.createCallExpression(AST.createIdentifier(self._("the_" + typeName + "_free")), [expression])
    }

    return AST.createCastExpression(AST.createType("void"), expression)
  }

  fn _functionRealloc (mut self: ref Self, it: ref Analyzer.Type, left: AST.CExpression, right: AST.CExpression) AST.CExpression {
    if it.isAlias() {
      t := it.asAlias()
      return self._functionRealloc(t.t, left, right)
    } elif (
      it.isArray() ||
      it.isFunction() ||
      it.isMap() ||
      // todo
      // it.isObject() ||
      it.isOptional() ||
      it.isUnion()
    ) {
      typeName := self._typeName(it)

      return AST.createAssignmentExpression(
        left,
        "=",
        AST.createCallExpression(AST.createIdentifier(self._("the_" + typeName + "_realloc")), [left, right])
      )
    }

    return AST.createIdentifier(self._("NULL"))
  }

  fn _functionStr (mut self: ref Self, it: ref Analyzer.Type, expression: AST.CExpression, escape := true) AST.CExpression {
    if it.isAlias() {
      t := it.asAlias()
      return self._functionStr(t.t, expression, escape)
    } elif it.name == "any" {
      return AST.createCallExpression(AST.createIdentifier(self._("the_any_str")), [expression])
    } elif it.name == "str" && escape {
      return AST.createCallExpression(AST.createIdentifier(self._("the_str_escape")), [expression])
    } elif it.name == "str" && escape {
      return expression
    } elif it.isEnum() {
      return AST.createCallExpression(AST.createIdentifier(self._("the_enum_str")), [expression])
    } else {
      typeName := self._typeName(it)
      return AST.createCallExpression(AST.createIdentifier(self._("the_" + typeName + "_str")), [expression])
    }
  }

  fn _generateBlock (mut self: ref Self, items: ref Parser.Statement[]) AST.CStatement[] {
    mut result: AST.CStatement[]
    l := items.len

    loop i := 0; i < l; i++ {
      result.push(self._generateStatement(items[i]))
    }

    return result
  }

  fn _generateExpression (mut self: ref Self, item: ref Parser.Expression) AST.CExpression {
    mut result: AST.CExpression?

    if (
      (result = self._generateIdentifier(item)) != nil ||
      (result = self._generateCallExpression(item)) != nil ||
      (result = self._generateLiteral(item)) != nil ||
      (result = self._generateParenthesizedExpression(item)) != nil ||
      (result = self._generateArrayExpression(item)) != nil ||
      (result = self._generateAssignmentExpression(item)) != nil ||
      (result = self._generateBinaryExpression(item)) != nil ||
      (result = self._generateConditionalExpression(item)) != nil ||
      (result = self._generateIsExpression(item)) != nil ||
      (result = self._generateReferenceExpression(item)) != nil ||
      (result = self._generateUnaryExpression(item)) != nil
    ) {
      return result
    }

    throw error_NewError("Tried code generation for unknown expression")
  }

  fn _generateStatement (mut self: ref Self, item: ref Parser.Statement) AST.CStatement {
    mut result: AST.CStatement?

    if (
      (result = self._generateBlockStatement(item)) != nil ||
      (result = self._generateBreakStatement(item)) != nil ||
      (result = self._generateContinueStatement(item)) != nil ||
      (result = self._generateEnumDeclaration(item)) != nil ||
      (result = self._generateExportDeclaration(item)) != nil ||
      (result = self._generateExpressionStatement(item)) != nil ||
      (result = self._generateFunctionDeclaration(item)) != nil ||
      (result = self._generateIfStatement(item)) != nil ||
      (result = self._generateLoopStatement(item)) != nil ||
      (result = self._generateMainDeclaration(item)) != nil ||
      (result = self._generateObjectDeclaration(item)) != nil ||
      (result = self._generateReturnStatement(item)) != nil ||
      (result = self._generateThrowStatement(item)) != nil ||
      (result = self._generateTryStatement(item)) != nil ||
      (result = self._generateVariableDeclaration(item)) != nil
    ) {
      return result
    }

    throw error_NewError("Tried code generation for unknown statement")
  }

  fn _generateIdentifier (mut self: ref Codegen, item: ref Parser.Expression) AST.CExpression? {
    if item.isIdentifier() {
      expression := item.asIdentifier()

      if self._hasEntity(expression.name) {
        return AST.createIdentifier(self._(expression.name))
      } else {
        return AST.createIdentifier(expression.name)
      }
    }

    return nil
  }

  fn _generateLiteral (mut self: ref Codegen, item: ref Parser.Expression) AST.CExpression? {
    if item.isBooleanLiteral() {
      expression := item.asBooleanLiteral()
      return AST.createLiteral(self._(expression.value))
    } elif item.isCharacterLiteral() {
      expression := item.asCharacterLiteral()
      return AST.createLiteral("L'" + expression.value + "'")
    } elif item.isFloatingPointLiteral() {
      expression := item.asFloatingPointLiteral()
      return AST.createLiteral(expression.value)
    } elif item.isIntegerLiteral() {
      expression := item.asIntegerLiteral()
      rawValue := expression.value.replace("O", "").replace("o", "")

      if !rawValue.contains("b") && !rawValue.contains("B") && !rawValue.contains("x") && !rawValue.contains("X") {
        numValue := rawValue.toU64()
        return AST.createLiteral(rawValue + (numValue > 9223372036854775807 ? "U" : ""))
      }

      return AST.createLiteral(rawValue)
    } elif item.isNilLiteral() {
      expression := item.asNilLiteral()
      return AST.createIdentifier(self._("NULL"))
    } elif item.isStringLiteral() {
      expression := item.asStringLiteral()
      sanitizedValue := expression.value
        .replace(os_EOL, "\" " + self._("THE_EOL") + " \"")
        .replace("\n", "\" " + self._("THE_EOL") + " \"")
      rawValue := "L\"" + sanitizedValue + "\""

      if !item.hasParent() && item.hasParentNode() {
        node := item.parentNode()

        if node.isVariableDeclaration() {
          return AST.createCallExpression(
            AST.createIdentifier(self._("the_str_alloc")),
            [AST.createLiteral(rawValue)]
          )
        }
      }

      return AST.createLiteral(rawValue)
    }

    return nil
  }

  fn _generateArrayExpression (mut self: ref Codegen, item: ref Parser.Expression) AST.CExpression? {
    if item.isArray() {
      expression := item.asArray()
      validateContext(item.context is Analyzer.ArrayExpressionContext)
      context := item.context as Analyzer.ArrayExpressionContext
      typeName := self._typeName(context.t)
      mut arguments: (AST.CExpression | AST.CType)[] = [AST.createLiteral(expression.elements.len)]

      loop i := 0; i < expression.elements.len; i++ {
        element := expression.elements[i]
        arguments.push(self._generateExpression(element))
      }

      result := AST.createCallExpression(AST.createIdentifier(self._("the_" + typeName + "_alloc")), arguments)
      mut wrapWithFree := false

      if !item.hasParent() {
        if item.hasParentNode() {
          parentNode := item.parentNode()
          wrapWithFree = !parentNode.isVariableDeclaration()
        } else {
          wrapWithFree = true
        }
      }

      return wrapWithFree ? self._functionFree(context.t, result) : result
    }

    return nil
  }

  fn _generateAssignmentExpression (mut self: ref Codegen, item: ref Parser.Expression) AST.CExpression? {
    if item.isAssignment() {
      expression := item.asAssignment()
      validateContext(item.context is Analyzer.AssignmentExpressionContext)
      context := item.context as Analyzer.AssignmentExpressionContext
      leftType := Analyzer.unwrap(context.leftType, withReference: false)
      rightType := Analyzer.unwrap(context.rightType, withReference: false)
      left := self._generateExpression(ref expression.left)
      mut right := self._generateExpression(ref expression.right)

      if expression.operator.t == .OpPlusEq && (leftType.name == "str" || rightType.name == "str") {
        return AST.createAssignmentExpression(
          left,
          "=",
          AST.createCallExpression(AST.createIdentifier(self._("the_str_realloc")), [
            left,
            AST.createCallExpression(AST.createIdentifier(self._("the_str_concat")), [left, right])
          ])
        )
      } elif !typePrimitive(leftType) || !typePrimitive(rightType) {
        result := self._functionRealloc(leftType, left, right)
        return item.hasParent() ? result : self._functionCopy(leftType, result)
      } elif expression.operator.t == .OpAmpAmp || expression.operator.t == .OpPipePipe {
        right = AST.createBinaryExpression(left, expression.operator.val, right)
        return AST.createAssignmentExpression(left, "=", right)
      }

      return AST.createAssignmentExpression(left, expression.operator.val, right)
    }

    return nil
  }

  fn _generateBinaryExpression (mut self: ref Codegen, item: ref Parser.Expression) AST.CExpression? {
    if item.isBinary() {
      expression := item.asBinary()
      validateContext(item.context is Analyzer.BinaryExpressionContext)
      context := item.context as Analyzer.BinaryExpressionContext
      leftType := Analyzer.unwrap(context.leftType, withReference: false)
      rightType := Analyzer.unwrap(context.rightType, withReference: false)
      left := self._generateExpression(ref expression.left)
      mut right := self._generateExpression(ref expression.right)

      if (
        (expression.operator.t == .OpEqEq || expression.operator.t == .OpExclEq) &&
        (!typePrimitive(context.leftType) || !typePrimitive(context.rightType))
      ) {
        return expression.operator.t == .OpEqEq
          ? self._functionEq(leftType, left, right)
          : self._functionEq(leftType, left, right, reverse: true)
      } elif leftType.name == "str" && rightType.name == "str" && (
        expression.operator.t == .OpLt ||
        expression.operator.t == .OpLtEq ||
        expression.operator.t == .OpGt ||
        expression.operator.t == .OpGtEq
      ) {
        direction := expression.operator.t == .OpLt
          ? "lt"
          : expression.operator.t == .OpLtEq
            ? "le"
            : expression.operator.t == .OpGt
              ? "gt"
              : "ge"

        return AST.createCallExpression(AST.createIdentifier(self._("the_str_" + direction)), [left, right])
      } elif expression.operator.t == .OpPlus && leftType.name == "str" && rightType.name == "str" {
        result := AST.createCallExpression(AST.createIdentifier(self._("the_str_concat")), [left, right])
        return item.hasParent() ? result : self._functionFree(leftType, result)
      }

      return AST.createBinaryExpression(left, expression.operator.val, right)
    }

    return nil
  }

  // todo finish and test
  fn _generateCallExpression (mut self: ref Codegen, item: ref Parser.Expression) AST.CExpression? {
    if item.isCall() {
      expression := item.asCall()
      return AST.createCallExpression(self._generateExpression(ref expression.callee))
    }

    return nil
  }

  fn _generateConditionalExpression (mut self: ref Codegen, item: ref Parser.Expression) AST.CExpression? {
    if item.isConditional() {
      expression := item.asConditional()
      validateContext(item.context is Analyzer.ConditionalExpressionContext)
      context := item.context as Analyzer.ConditionalExpressionContext
      alternateType := Analyzer.unwrap(context.alternateType, withReference: false)
      mut alternate := self._generateExpression(ref expression.alternate)

      if expression.alternate.isAssignment() && !typeSafeForTernaryAlternate(alternateType) {
        alternate = alternate.wrap()
      }

      return AST.createConditionalExpression(
        self._generateExpression(ref expression.condition),
        self._generateExpression(ref expression.consequent),
        alternate
      )
    }

    return nil
  }

  fn _generateIsExpression (mut self: ref Codegen, item: ref Parser.Expression) AST.CExpression? {
    if item.isIs() {
      expression := item.asIs()
      validateContext(item.context is Analyzer.IsExpressionContext)
      context := item.context as Analyzer.IsExpressionContext
      left := AST.createPropertyAccessExpression(self._generateExpression(ref expression.expression), "t")
      right := AST.createIdentifier(self._typeDef(context.rightType))

      return AST.createBinaryExpression(left, "==", right)
    }

    return nil
  }

  fn _generateParenthesizedExpression (mut self: ref Codegen, item: ref Parser.Expression) AST.CExpression? {
    if item.isParenthesized() {
      expression := item.asParenthesized()
      result := self._generateExpression(ref expression.expression)
      return result.wrap()
    }

    return nil
  }

  fn _generateReferenceExpression (mut self: ref Codegen, item: ref Parser.Expression) AST.CExpression? {
    if item.isReference() {
      expression := item.asReference()
      return AST.createUnaryExpression("&", self._generateExpression(ref expression.expression))
    }

    return nil
  }

  fn _generateUnaryExpression (mut self: ref Codegen, item: ref Parser.Expression) AST.CExpression? {
    if item.isUnary() {
      expression := item.asUnary()
      validateContext(item.context is Analyzer.UnaryExpressionContext)
      context := item.context as Analyzer.UnaryExpressionContext

      if context.operandType.isFloat() {
        castExpression := AST.createCastExpression(AST.createType(self._("bool")), self._generateExpression(ref expression.operand))

        return AST.createUnaryExpression(
          expression.operator.val,
          castExpression.wrap(),
          postfix: !expression.prefix
        )
      }

      return AST.createUnaryExpression(
        expression.operator.val,
        self._generateExpression(ref expression.operand),
        postfix: !expression.prefix
      )
    }

    return nil
  }

  fn _generateBlockStatement (mut self: ref Codegen, item: ref Parser.Statement) AST.CStatement? {
    if item.isBlock() {
      statement := item.asBlock()
      return AST.createCompoundStatement(self._generateBlock(ref statement.body))
    }

    return nil
  }

  fn _generateBreakStatement (mut self: ref Codegen, item: ref Parser.Statement) AST.CStatement? {
    if item.isBreak() {
      statement := item.asBreak()

      if self.blockData.hasCleanup() { // todo check specifically for loop
        //(*c)->append(
        //  CodegenASTExprAssign::create(
        //    CodegenASTExprAccess::create(this->state.cleanUp.currentBreakVar()),
        //    "=",
        //    CodegenASTExprLiteral::create("1")
        //  )->stmt()
        //);
        //if (!ASTChecker(node).isLast(this->state.fnDeclBody)) {
        //  (*c)->append(CodegenASTStmtGoto::create(this->state.cleanUp.currentLabel()));
        //}
      }

      return AST.createContinueStatement()
    }

    return nil
  }

  fn _generateContinueStatement (mut self: ref Codegen, item: ref Parser.Statement) AST.CStatement? {
    if item.isContinue() {
      statement := item.asContinue()

      if self.blockData.hasCleanup() { // todo check specifically for loop
        //if (!ASTChecker(node.parent).is<ASTNodeLoop>()) {
        //  (*c)->append(
        //    CodegenASTExprAssign::create(
        //      CodegenASTExprAccess::create(this->state.cleanUp.currentContinueVar()),
        //      "=",
        //      CodegenASTExprLiteral::create("1")
        //    )->stmt()
        //  );
        //}
        //if (!ASTChecker(node).isLast(this->state.fnDeclBody)) {
        //  (*c)->append(CodegenASTStmtGoto::create(this->state.cleanUp.currentLabel()));
        //}
      }

      return AST.createContinueStatement()
    }

    return nil
  }

  fn _generateEnumDeclaration (mut self: ref Codegen, item: ref Parser.Statement) AST.CStatement? {
    if item.isEnumDeclaration() {
      statement := item.asEnumDeclaration()

      // todo
      // auto nodeEnumDecl = std::get<ASTNodeEnumDecl>(*node.body);
      // auto members = nodeEnumDecl.members;
      // auto typeName = Codegen::typeName(nodeEnumDecl.type->codeName);
      // auto enumType = std::get<TypeEnum>(nodeEnumDecl.type->body);
      // if (phase != CODEGEN_PHASE_ALLOC && phase != CODEGEN_PHASE_FULL) {
      //   return;
      // }
      // auto cDecl = CodegenASTStmtCompound::create();
      // this->_apiEntity(typeName, CODEGEN_ENTITY_ENUM, [&] (auto &decl, [[maybe_unused]] auto &def) {
      //   auto membersCode = std::string();
      //   for (auto i = static_cast<std::size_t>(0); i < enumType.members.size(); i++) {
      //     auto typeMember = enumType.members[i];
      //     auto member = std::find_if(members.begin(), members.end(), [&] (const auto &it) -> bool {
      //       return it.id == typeMember->name;
      //     });
      //     if (member != members.end()) {
      //       membersCode += "  " + Codegen::name(typeMember->codeName);
      //       if (member->init != std::nullopt) {
      //         auto cInit = this->_nodeExpr(*member->init, member->init->type, node, &cDecl, true);
      //         membersCode += " = " + cInit->str();
      //       }
      //       membersCode += i == enumType.members.size() - 1 ? EOL : "," EOL;
      //     }
      //   }
      //   decl += "enum " + typeName + " {" EOL;
      //   decl += membersCode;
      //   decl += "};";
      //   return 0;
      // });
      // this->_apiEntity(typeName + "_rawValue", CODEGEN_ENTITY_FN, [&] (auto &decl, auto &def) {
      //   auto typeInfo = this->_typeInfo(nodeEnumDecl.type);
      //   decl += "_{struct str} " + typeName + "_rawValue (" + typeInfo.typeCodeTrimmed + ");";
      //   def += "_{struct str} " + typeName + "_rawValue (" + typeInfo.typeCode + "n) {" EOL;
      //   for (const auto &member : enumType.members) {
      //     def += "  if (n == " + Codegen::name(member->codeName) + ")" R"( return _{str_alloc}(")" + member->name + R"(");)" EOL;
      //   }
      //   def += "}";
      //   return 0;
      // });
    }

    return nil
  }

  fn _generateExportDeclaration (mut self: ref Codegen, item: ref Parser.Statement) AST.CStatement? {
    if item.isExportDeclaration() {
      statement := item.asExportDeclaration()

      // todo
      // if (
      //   nodeExportDecl.declaration != std::nullopt &&
      //   !std::holds_alternative<ASTNodeExpr>(*nodeExportDecl.declaration->body)
      // ) {
      //   return this->_node(c, *nodeExportDecl.declaration, phase);
      // }
    }

    return nil
  }

  fn _generateExpressionStatement (mut self: ref Codegen, item: ref Parser.Statement) AST.CStatement? {
    if item.isExpression() {
      statement := item.asExpression()
      return AST.createExpressionStatement(self._generateExpression(ref statement.expression))
    }

    return nil
  }

  fn _generateFunctionDeclaration (mut self: ref Codegen, item: ref Parser.Statement) AST.CStatement? {
    if item.isFunctionDeclaration() {
      statement := item.asFunctionDeclaration()
      // todo
    }

    return nil
  }

  fn _generateIfStatement (mut self: ref Codegen, item: ref Parser.Statement) AST.CStatement? {
    if item.isIf() {
      statement := item.asIf()
      condition := self._generateExpression(ref statement.condition)
      consequent := self._generateStatement(ref statement.consequent)
      mut alternate: AST.CStatement?

      if statement.alternate != nil {
        statementAlternate := statement.alternate
        alternate = self._generateStatement(ref statementAlternate)
      }

      return AST.createIfStatement(condition, consequent, alternate)
    }

    return nil
  }

  fn _generateLoopStatement (mut self: ref Codegen, item: ref Parser.Statement) AST.CStatement? {
    if item.isLoop() {
      statement := item.asLoop()

      // todo
      // auto nodeLoop = std::get<ASTNodeLoop>(*node.body);
      // auto initialStateCleanUp = this->state.cleanUp;
      // this->varMap.save();
      // this->state.cleanUp = CodegenCleanUp(CODEGEN_CLEANUP_BLOCK, &initialStateCleanUp);
      // this->state.cleanUp.breakVarIdx += 1;
      // this->state.cleanUp.continueVarIdx += 1;
      // auto cBody = CodegenASTStmtCompound::create();
      // if (nodeLoop.init == std::nullopt && nodeLoop.upd == std::nullopt) {
      //   auto cCond = nodeLoop.cond == std::nullopt
      //     ? CodegenASTExprLiteral::create("1")
      //     : this->_nodeExpr(*nodeLoop.cond, this->ast->typeMap.get("bool"), node, c, true);
      //   (*c)->append(CodegenASTStmtWhile::create(cCond, cBody));
      //   *c = cBody;
      // } else {
      //   auto cInit = CodegenASTStmtNull::create();
      //   auto cCond = CodegenASTExprNull::create();
      //   auto cUpd = CodegenASTExprNull::create();
      //   if (nodeLoop.init != std::nullopt) {
      //     auto cCompound = CodegenASTStmtCompound::create();
      //     this->_node(&cCompound, *nodeLoop.init);
      //     if (!this->state.cleanUp.empty()) {
      //       *c = (*c)->append(cCompound);
      //     } else {
      //       cInit = cCompound->asCompound().body[0];
      //     }
      //   }
      //   if (nodeLoop.cond != std::nullopt) {
      //     cCond = this->_nodeExpr(*nodeLoop.cond, this->ast->typeMap.get("bool"), node, c, true);
      //   }
      //   if (nodeLoop.upd != std::nullopt) {
      //     cUpd = this->_nodeExpr(*nodeLoop.upd, nodeLoop.upd->type, node, c, true);
      //   }
      //   (*c)->append(CodegenASTStmtFor::create(cInit, cCond, cUpd, cBody));
      //   *c = cBody;
      // }
      // auto saveStateCleanUp = this->state.cleanUp;
      // this->state.cleanUp = CodegenCleanUp(CODEGEN_CLEANUP_LOOP, &saveStateCleanUp);
      // this->_block(c, nodeLoop.body);
      // if (this->state.cleanUp.continueVarUsed) {
      //   (*c)->prepend(
      //     CodegenASTStmtVarDecl::create(
      //       CodegenASTType::create("unsigned char"),
      //       CodegenASTExprAccess::create(this->state.cleanUp.currentContinueVar()),
      //       CodegenASTExprLiteral::create("0")
      //     )
      //   );
      // }
      // if (this->state.cleanUp.breakVarUsed) {
      //   (*c)->prepend(
      //     CodegenASTStmtVarDecl::create(
      //       CodegenASTType::create("unsigned char"),
      //       CodegenASTExprAccess::create(this->state.cleanUp.currentBreakVar()),
      //       CodegenASTExprLiteral::create("0")
      //     )
      //   );
      // }
      // *c = (*c)->exit()->exit();
      // if (!saveStateCleanUp.empty()) {
      //   saveStateCleanUp.gen(c);
      //   if (saveStateCleanUp.returnVarUsed) {
      //     (*c)->append(
      //       CodegenASTStmtIf::create(
      //         CodegenASTExprBinary::create(CodegenASTExprAccess::create("r"), "==", CodegenASTExprLiteral::create("1")),
      //         initialStateCleanUp.hasCleanUp(CODEGEN_CLEANUP_FN)
      //           ? CodegenASTStmtGoto::create(initialStateCleanUp.currentLabel())
      //           : this->state.returnType->isVoid()
      //             ? CodegenASTStmtReturn::create()
      //             : CodegenASTStmtReturn::create(CodegenASTExprAccess::create(this->state.cleanUp.currentValueVar()))
      //       )
      //     );
      //   }
      //   *c = (*c)->exit();
      // }
      // this->state.cleanUp.breakVarIdx -= 1;
      // this->state.cleanUp.continueVarIdx -= 1;
      // this->state.cleanUp = initialStateCleanUp;
      // this->varMap.restore();
    }

    return nil
  }

  fn _generateMainDeclaration (mut self: ref Codegen, item: ref Parser.Statement) AST.CStatement? {
    if item.isMainDeclaration() {
      statement := item.asMainDeclaration()
      statementBody := statement.body.asBlock()

      self.mainStatements = self._generateBlock(ref statementBody.body)
      self.mainStatements.merge(self.blockData.getCleanup())

      return AST.createEmptyStatement()
    }

    return nil
  }

  fn _generateObjectDeclaration (mut self: ref Codegen, item: ref Parser.Statement) AST.CStatement? {
    if item.isObjectDeclaration() {
      statement := item.asObjectDeclaration()
      // todo
    }

    return nil
  }

  fn _generateReturnStatement (mut self: ref Codegen, item: ref Parser.Statement) AST.CStatement? {
    if item.isReturn() {
      statement := item.asReturn()

      // todo
      // if (this->state.cleanUp.hasCleanUp(CODEGEN_CLEANUP_FN) || this->state.cleanUp.returnVarUsed) {
      //   auto parentNotRoot = this->state.cleanUp.parent != nullptr && this->state.cleanUp.parent->type != CODEGEN_CLEANUP_ROOT;
      //   if (parentNotRoot && this->state.cleanUp.hasCleanUp(CODEGEN_CLEANUP_FN)) {
      //     (*c)->append(
      //       CodegenASTExprAssign::create(
      //         CodegenASTExprAccess::create(this->state.cleanUp.currentReturnVar()),
      //         "=",
      //         CodegenASTExprLiteral::create("1")
      //       )->stmt()
      //     );
      //   }
      //   if (nodeReturn.body != std::nullopt) {
      //     (*c)->append(
      //       CodegenASTExprAssign::create(
      //         CodegenASTExprAccess::create(this->state.cleanUp.currentValueVar()),
      //         "=",
      //         this->_nodeExpr(*nodeReturn.body, this->state.returnType, node, c)
      //       )->stmt()
      //     );
      //   }
      //   auto nodeParentFunction = ASTChecker(node.parent).is<ASTNodeFnDecl>() || ASTChecker(node.parent).is<ASTNodeObjDecl>();
      //   auto nodeIsLast = node.parent != nullptr && ASTChecker(node).isLast(this->state.fnDeclBody);
      //   if ((!nodeParentFunction && this->state.cleanUp.empty()) || !nodeIsLast) {
      //     (*c)->append(CodegenASTStmtGoto::create(this->state.cleanUp.currentLabel()));
      //   }
      // } else if (nodeReturn.body != std::nullopt) {
      //   auto cArg = this->_nodeExpr(*nodeReturn.body, this->state.returnType, node, c);
      //   (*c)->append(CodegenASTStmtReturn::create(cArg));
      // } else {
      //   (*c)->append(
      //     ASTChecker(node).insideMain()
      //       ? CodegenASTStmtReturn::create(CodegenASTExprLiteral::create("0"))
      //       : CodegenASTStmtReturn::create()
      //   );
      // }
    }

    return nil
  }

  fn _generateThrowStatement (mut self: ref Codegen, item: ref Parser.Statement) AST.CStatement? {
    if item.isThrow() {
      statement := item.asThrow()

      // todo
      // auto argTypeInfo = this->_typeInfo(nodeThrow.arg.type);
      // auto cArg = this->_nodeExpr(nodeThrow.arg, argTypeInfo.type, node, c);
      // auto argNodeExprDef = this->_typeDef(argTypeInfo.type);
      // (*c)->append(
      //   CodegenASTExprCall::create(
      //     CodegenASTExprAccess::create(this->_("error_assign")),
      //     {
      //       this->_genErrState(ASTChecker(node).insideMain(), false),
      //       CodegenASTExprAccess::create(this->_(argNodeExprDef)),
      //       CodegenASTExprCast::create(CodegenASTType::create("void *"), cArg),
      //       CodegenASTExprCast::create(
      //         CodegenASTType::create("void (*) (void *)"),
      //         CodegenASTExprUnary::create("&", CodegenASTExprAccess::create(this->_(argTypeInfo.typeName + "_free")))
      //       ),
      //       CodegenASTExprLiteral::create(std::to_string(node.start.line)),
      //       CodegenASTExprLiteral::create(std::to_string(node.start.col + 1))
      //     }
      //   )->stmt()
      // );
      // (*c)->append(CodegenASTStmtGoto::create(this->state.cleanUp.currentLabel()));
    }

    return nil
  }

  fn _generateTryStatement (mut self: ref Codegen, item: ref Parser.Statement) AST.CStatement? {
    if item.isTry() {
      statement := item.asTry()

      // todo
      // auto nodeTry = std::get<ASTNodeTry>(*node.body);
      // auto initialStateCleanUp = this->state.cleanUp;
      // this->state.cleanUp = CodegenCleanUp(CODEGEN_CLEANUP_BLOCK, &initialStateCleanUp);

      // *c = (*c)->append(
      //   CodegenASTStmtSwitch::create(
      //     CodegenASTExprCall::create(
      //       CodegenASTExprAccess::create(this->_("setjmp")),
      //       {
      //         CodegenASTExprAccess::create(
      //           CodegenASTExprCall::create(
      //             CodegenASTExprAccess::create(this->_("error_buf_increase")),
      //             {this->_genErrState(ASTChecker(node).insideMain(), false)}
      //           ),
      //           "buf",
      //           true
      //         )
      //       }
      //     )
      //   )
      // );

      // *c = (*c)->append(
      //   CodegenASTStmtCase::create(CodegenASTExprLiteral::create("0"), CodegenASTStmtCompound::create())
      // );

      // this->varMap.save();

      // auto blockCleanUp = CodegenASTStmtCompound::create({
      //   CodegenASTStmtIf::create(
      //     CodegenASTExprBinary::create(
      //       this->_genErrState(ASTChecker(node).insideMain(), false, "id"),
      //       "!=",
      //       CodegenASTExprLiteral::create("-1")
      //     ),
      //     CodegenASTExprCall::create(
      //       CodegenASTExprAccess::create(this->_("longjmp")),
      //       {
      //         CodegenASTExprAccess::create(
      //           this->_genErrState(ASTChecker(node).insideMain(), false, "buf_last"),
      //           "buf",
      //           true
      //         ),
      //         this->_genErrState(ASTChecker(node).insideMain(), false, "id")
      //       }
      //     )->stmt()
      //   ),
      //   CodegenASTExprCall::create(
      //     CodegenASTExprAccess::create(this->_("error_buf_decrease")),
      //     {this->_genErrState(ASTChecker(node).insideMain(), false)}
      //   )->stmt()
      // });

      // this->_block(c, nodeTry.body, true, blockCleanUp, true);
      // (*c)->append(CodegenASTStmtBreak::create());
      // *c = (*c)->exit()->exit();
      // this->varMap.restore();
      // this->state.cleanUp = initialStateCleanUp;

      // for (const auto &handler : nodeTry.handlers) {
      //   auto handlerVarDecl = std::get<ASTNodeVarDecl>(*handler.param.body);
      //   auto handlerTypeInfo = this->_typeInfo(handlerVarDecl.var->type);
      //   auto handlerDef = this->_typeDef(handlerVarDecl.var->type);
      //   auto handleCodeName = Codegen::name(handlerVarDecl.var->codeName);

      //   *c = (*c)->append(
      //     CodegenASTStmtCase::create(
      //       CodegenASTExprAccess::create(this->_(handlerDef)),
      //       CodegenASTStmtCompound::create()
      //     )
      //   );

      //   (*c)->append(
      //     CodegenASTExprCall::create(
      //       CodegenASTExprAccess::create(this->_("error_buf_decrease")),
      //       {this->_genErrState(ASTChecker(node).insideMain(), false)}
      //     )->stmt()
      //   );

      //   (*c)->append(
      //     CodegenASTExprCall::create(
      //       CodegenASTExprAccess::create(this->_("error_unset")),
      //       {this->_genErrState(ASTChecker(node).insideMain(), false)}
      //     )->stmt()
      //   );

      //   (*c)->append(
      //     CodegenASTStmtVarDecl::create(
      //       CodegenASTType::create(handlerTypeInfo.typeCodeConst),
      //       CodegenASTExprAccess::create(handleCodeName),
      //       CodegenASTExprCast::create(
      //         CodegenASTType::create(handlerTypeInfo.typeCodeTrimmed),
      //         this->_genErrState(ASTChecker(node).insideMain(), false, "ctx")
      //       )
      //     )
      //   );

      //   this->varMap.save();

      //   this->_block(
      //     c,
      //     handler.body,
      //     true,
      //     this->_genFreeFn(handlerTypeInfo.type, CodegenASTExprAccess::create(handleCodeName))->stmt()
      //   );

      //   (*c)->append(CodegenASTStmtBreak::create());
      //   *c = (*c)->exit()->exit();
      //   this->varMap.restore();
      // }

      // *c = (*c)->append(CodegenASTStmtCase::create(nullptr, CodegenASTStmtCompound::create()));

      // (*c)->append(
      //   CodegenASTExprCall::create(
      //     CodegenASTExprAccess::create(this->_("error_buf_decrease")),
      //     {this->_genErrState(ASTChecker(node).insideMain(), false)}
      //   )->stmt()
      // );

      // (*c)->append(CodegenASTStmtGoto::create(this->state.cleanUp.currentLabel()));
      // *c = (*c)->exit()->exit()->exit();
    }

    return nil
  }

  fn _generateVariableDeclaration (mut self: ref Codegen, item: ref Parser.Statement) AST.CStatement? {
    if item.isVariableDeclaration() {
      statement := item.asVariableDeclaration()
      validateContext(item.context is Analyzer.VariableDeclarationContext)
      context := item.context as Analyzer.VariableDeclarationContext
      typeName := self._typeName(context.varType)
      t := AST.createType(self._type(context.varType))

      if typeShouldBeFreed(context.varType) {
        self.blockData.addCleanup(
          AST.createExpressionStatement(
            self._functionFree(context.varType, AST.createIdentifier(statement.name.name))
          )
        )
      }

      initializer := statement.initializer == nil
        ? self._defaultInitializerVariableDeclaration(context.varType)
        : self._generateExpression(ref statement.initializer)

      return AST.createVariableDeclaration(t, statement.name.name, initializer)
    }

    return nil
  }

  fn _generateArrayType (mut self: ref Codegen, item: ref Analyzer.Type) str {
    typeName := "the_" + self._typeName(item)
    name := typeName + "_t"

    if self._hasEntity(name) {
      return name
    }

    self.entities.push(CodegenEntity{
      name: name,
      codeName: name,
      context: item,
      generate: (mut self: ref Codegen, mut tm: ref Analyzer.TypeMap, entity: ref CodegenEntity) -> AST.CStatement | AST.CStatement[] {
        it := entity.context as ref Analyzer.Type
        t := it.asArray()
        elementTypeName := self._typeName(t.elementType)

        return [
          AST.createExpressionStatement(AST.createMacroInvocation(self._("THE_ARRAY_DECLARE"), [
            AST.createIdentifier(elementTypeName),
            AST.createType(self._type(t.elementType))
          ]), terminated: false),
          AST.createExpressionStatement(AST.createMacroInvocation(self._("THE_ARRAY_DEFINE"), [
            AST.createIdentifier(elementTypeName),
            AST.createType(self._type(t.elementType)),
            AST.createType(self._type(typeSafeForVaArg(tm, t.elementType))),
            self._functionCopy(t.elementType, AST.createIdentifier("element")),
            self._functionEq(t.elementType, AST.createIdentifier("lhs_element"), AST.createIdentifier("rhs_element")),
            self._functionFree(t.elementType, AST.createIdentifier("element")),
            self._functionStr(t.elementType, AST.createIdentifier("element"))
          ]), terminated: false)
        ]
      }
    })

    methods := [
      "alloc",
      "at",
      "clear",
      "concat",
      "contains",
      "copy",
      "empty",
      "eq",
      "filter",
      "first",
      "forEach",
      "free",
      "join",
      "last",
      "merge",
      "pop",
      "push",
      "realloc",
      "remove",
      "reverse",
      "slice",
      "sort",
      "str"
    ]

    entityCallee := (mut self: ref Codegen, mut tm: ref Analyzer.TypeMap, entity: ref CodegenEntity) -> AST.CStatement | AST.CStatement[] {
      self._(entity.context as str)
      return AST.createEmptyStatement()
    }

    loop i := 0; i < methods.len; i++ {
      methodName := methods[i] as str

      self.entities.push(CodegenEntity{
        name: typeName + "_" + methodName,
        codeName: typeName + "_" + methodName,
        context: name,
        generate: entityCallee
      })
    }

    return name
  }

  fn _generateFunctionType (mut self: ref Codegen, item: ref Analyzer.Type) str {
    typeName := "the_" + self._typeName(item)
    name := typeName + "_t"

    if self._hasEntity(name) {
      return name
    }

    itemType := item.asFunction()
    hasParams := !itemType.parameters.empty

    if hasParams {
      self.entities.push(CodegenEntity{
        name: name,
        codeName: name,
        context: item,
        generate: (mut self: ref Codegen, mut tm: ref Analyzer.TypeMap, entity: ref CodegenEntity) -> AST.CStatement | AST.CStatement[] {
          it := entity.context as ref Analyzer.Type
          t := it.asFunction()
          mut parametersTypeName := ""
          mut parametersDefinition: AST.CStatement[]

          loop i := 0; i < t.parameters.len; i++ {
            parameter := t.parameters[i]
            parametersTypeName += typeParameterId(parameter) + self._typeName(parameter.t)

            parametersDefinition.push(AST.createStructureMemberDeclaration(
              AST.createType(self._type(parameter.t)),
              "n" + i.str()
            ))
          }

          return AST.createExpressionStatement(AST.createMacroInvocation(self._("THE_FUNCTION_DECLARE_WITH_PARAMS"), [
            AST.createIdentifier(t.asynchronous ? "s" : "a"),
            AST.createType(self._type(t.returnType)),
            AST.createIdentifier(parametersTypeName),
            AST.createCompoundStatement(parametersDefinition)
          ]), terminated: false)
        }
      })
    } else {
      self.entities.push(CodegenEntity{
        name: name,
        codeName: name,
        context: item,
        generate: (mut self: ref Codegen, mut tm: ref Analyzer.TypeMap, entity: ref CodegenEntity) -> AST.CStatement | AST.CStatement[] {
          it := entity.context as ref Analyzer.Type
          t := it.asFunction()

          return [
            AST.createExpressionStatement(AST.createMacroInvocation(self._("THE_FUNCTION_DECLARE"), [
              AST.createIdentifier(t.asynchronous ? "s" : "a"),
              AST.createType(self._type(t.returnType))
            ]), terminated: false),
            AST.createExpressionStatement(AST.createMacroInvocation(self._("THE_FUNCTION_DEFINE"), [
              AST.createIdentifier(t.asynchronous ? "s" : "a"),
              AST.createType(self._type(t.returnType))
            ]), terminated: false),
          ]
        }
      })
    }

    methods := ["alloc", "copy", "eq", "free", "realloc", "str"]

    entityCallee := (mut self: ref Codegen, mut tm: ref Analyzer.TypeMap, entity: ref CodegenEntity) -> AST.CStatement | AST.CStatement[] {
      self._(entity.context as str)
      return AST.createEmptyStatement()
    }

    loop i := 0; i < methods.len; i++ {
      methodName := methods[i] as str

      self.entities.push(CodegenEntity{
        name: typeName + "_" + methodName,
        codeName: typeName + "_" + methodName,
        context: name,
        generate: entityCallee
      })
    }

    return name
  }

  fn _generateOptionalType (mut self: ref Codegen, item: ref Analyzer.Type) str {
    typeName := "the_" + self._typeName(item)
    name := typeName + "_t"

    if self._hasEntity(name) {
      return name
    }

    self.entities.push(CodegenEntity{
      name: name,
      codeName: name,
      context: item,
      generate: (mut self: ref Codegen, mut tm: ref Analyzer.TypeMap, entity: ref CodegenEntity) -> AST.CStatement | AST.CStatement[] {
        it := entity.context as ref Analyzer.Type
        t := it.asOptional()
        underlyingType := self._type(t.t)
        underlyingTypeName := self._typeName(t.t)

        return [
          AST.createExpressionStatement(AST.createMacroInvocation(self._("THE_OPTIONAL_DECLARE"), [
            AST.createIdentifier(underlyingTypeName),
            AST.createType(underlyingType)
          ]), terminated: false),
          AST.createExpressionStatement(AST.createMacroInvocation(self._("THE_OPTIONAL_DEFINE"), [
            AST.createIdentifier(underlyingTypeName),
            AST.createType(underlyingType),
            self._functionCopy(t.t, AST.createIdentifier("val")),
            self._functionEq(t.t, AST.createIdentifier("lhs_val"), AST.createIdentifier("rhs_val")),
            self._functionFree(t.t, AST.createIdentifier("val")),
            self._functionStr(t.t, AST.createIdentifier("val"))
          ]), terminated: false),
        ]
      }
    })

    methods := ["alloc", "copy", "eq", "free", "realloc", "str"]

    entityCallee := (mut self: ref Codegen, mut tm: ref Analyzer.TypeMap, entity: ref CodegenEntity) -> AST.CStatement | AST.CStatement[] {
      self._(entity.context as str)
      return AST.createEmptyStatement()
    }

    loop i := 0; i < methods.len; i++ {
      methodName := methods[i] as str

      self.entities.push(CodegenEntity{
        name: typeName + "_" + methodName,
        codeName: typeName + "_" + methodName,
        context: name,
        generate: entityCallee
      })
    }

    return name
  }

  fn _generateReferenceType (mut self: ref Codegen, item: ref Analyzer.Type) str {
    typeName := "the_" + self._typeName(item)
    name := typeName + "_t"

    if self._hasEntity(name) {
      return name
    }

    self.entities.push(CodegenEntity{
      name: name,
      codeName: name,
      context: item,
      generate: (mut self: ref Codegen, mut tm: ref Analyzer.TypeMap, entity: ref CodegenEntity) -> AST.CStatement | AST.CStatement[] {
        it := entity.context as ref Analyzer.Type
        t := it.asReference()

        return AST.createExpressionStatement(AST.createMacroInvocation(self._("THE_REFERENCE_DECLARE"), [
          AST.createIdentifier(self._typeName(t.t)),
          AST.createType(self._type(t.t))
        ]), terminated: false)
      }
    })

    return name
  }

  fn _generateUnionType (mut self: ref Codegen, item: ref Analyzer.Type) str {
    typeName := "the_" + self._typeName(item)
    name := typeName + "_t"

    if self._hasEntity(name) {
      return name
    }

    self.entities.push(CodegenEntity{
      name: name,
      codeName: name,
      context: item,
      generate: (mut self: ref Codegen, mut tm: ref Analyzer.TypeMap, entity: ref CodegenEntity) -> AST.CStatement | AST.CStatement[] {
        it := entity.context as ref Analyzer.Type
        t := it.asUnion()

        mut allocBlock: AST.CStatement[]
        mut copyBlock: AST.CStatement[]
        mut eqBlock: AST.CStatement[]
        mut freeBlock: AST.CStatement[]
        mut strBlock: AST.CStatement[]

        loop i := 0; i < t.types.len; i++ {
          subType := t.types[i]
          typeDef := self._typeDef(subType)
          typeDefIdx := self.typeDefs.get(typeDef)

          allocBlock.push(
            AST.createIfStatement(
              AST.createBinaryExpression(
                AST.createPropertyAccessExpression(AST.createIdentifier("self"), "type"),
                "==",
                AST.createIdentifier(self._(typeDef))
              ),
              AST.createExpressionStatement(
                AST.createAssignmentExpression(
                  AST.createPropertyAccessExpression(
                    AST.createPropertyAccessExpression(
                      AST.createIdentifier("self"),
                      "data"
                    ),
                    "v" + typeDefIdx.str()
                  ),
                  "=",
                  self._functionCopy(
                    subType,
                    AST.createCallExpression(AST.createIdentifier(self._("va_arg")), [
                      AST.createIdentifier("args"),
                      AST.createType(self._type(subType))
                    ])
                  )
                )
              )
            )
          )
        }

        return AST.createExpressionStatement(AST.createMacroInvocation(self._("THE_UNION_DECLARE"), [
          AST.createIdentifier(entity.codeName.slice(10, -2)),
          AST.createCompoundStatement(allocBlock),
          AST.createCompoundStatement(copyBlock),
          AST.createCompoundStatement(eqBlock),
          AST.createCompoundStatement(freeBlock),
          AST.createCompoundStatement(strBlock)
        ]), terminated: false)
      }
    })

    methods := ["alloc", "copy", "eq", "free", "realloc", "str"]

    entityCallee := (mut self: ref Codegen, mut tm: ref Analyzer.TypeMap, entity: ref CodegenEntity) -> AST.CStatement | AST.CStatement[] {
      self._(entity.context as str)
      return AST.createEmptyStatement()
    }

    loop i := 0; i < methods.len; i++ {
      methodName := methods[i] as str

      self.entities.push(CodegenEntity{
        name: typeName + "_" + methodName,
        codeName: typeName + "_" + methodName,
        context: name,
        generate: entityCallee
      })
    }

    return name
  }

  fn _getEntity (self: ref Self, name: str) ref CodegenEntity {
    loop i := self.entities.len - 1; i >= 0; i-- {
      entity := self.entities[i]

      if entity.name == name {
        return entity
      }
    }

    throw error_NewError("Entity with name '" + name + "' doesn't exists")
  }

  fn _hasEntity (self: ref Self, name: str) bool {
    loop i := self.entities.len - 1; i >= 0; i-- {
      entity := self.entities[i]

      if entity.name == name {
        return true
      }
    }

    return false
  }

  fn _type (mut self: ref Self, it: ref Analyzer.Type) str {
    if it.isAlias() {
      t := it.asAlias()
      return self._type(t.t)
    } elif it.name == "any" {
      return self._("the_any_t") + " "
    } elif it.name == "bool" {
      return self._("bool") + " "
    } elif it.name == "byte" {
      return "unsigned char "
    } elif it.name == "char" {
      return "char "
    } elif it.name == "f32" {
      return "float "
    } elif it.name == "f64" || it.name == "float" {
      return "double "
    } elif it.name == "i8" {
      return self._("int8_t") + " "
    } elif it.name == "i16" {
      return self._("int16_t") + " "
    } elif it.name == "i32" || it.name == "int" {
      return self._("int32_t") + " "
    } elif it.name == "i64" {
      return self._("int64_t") + " "
    } elif it.name == "isize" {
      return self._("ptrdiff_t") + " "
    } elif it.name == "rune" {
      return self._("wchar_t") + " "
    } elif it.name == "str" {
      return self._("the_str_t") + " "
    } elif it.name == "u8" {
      return self._("uint8_t") + " "
    } elif it.name == "u16" {
      return self._("uint16_t") + " "
    } elif it.name == "u32" {
      return self._("uint32_t") + " "
    } elif it.name == "u64" {
      return self._("uint64_t") + " "
    } elif it.name == "usize" {
      return self._("size_t") + " "
    } elif it.name == "void" {
      return "void "
    } elif it.isArray() {
      name := self._generateArrayType(it)
      return self._(name) + " "
    } elif it.isFunction() {
      name := self._generateFunctionType(it)
      return self._(name) + " "
    } elif it.isOptional() {
      name := self._generateOptionalType(it)
      return self._(name) + " "
    } elif it.isReference() {
      name := self._generateReferenceType(it)
      return self._(name) + " "
    } elif it.isUnion() {
      name := self._generateUnionType(it)
      return self._(name) + " "
    } elif (
      it.isEnum() ||
      it.isMap()
      // todo
      // it.isObject()
    ) {
      return self._(self._typeName(it) + "_t") + " "
    }

    throw error_NewError("Failed to generate type for '" + it.name + "'")
  }

  fn _typeDef (mut self: ref Self, it: ref Analyzer.Type) str {
    typeName := "TYPE_" + self._typeName(it)

    if self._hasEntity(typeName) {
      return typeName
    }

    lastTypeId := ++self.lastTypeId
    self.typeDefs.set(typeName, lastTypeId)

    self.entities.push(CodegenEntity{
      name: typeName,
      codeName: typeName,
      context: it,
      generate: (mut self: ref Codegen, mut tm: ref Analyzer.TypeMap, entity: ref CodegenEntity) -> AST.CStatement | AST.CStatement[] {
        typeDefIdx := self.typeDefs.get(entity.codeName)
        return AST.createDefineDirective(entity.codeName, nil, lastTypeId.str())
      }
    })

    return typeName
  }

  fn _typeName (mut self: ref Self, it: ref Analyzer.Type) str {
    if it.isAlias() {
      t := it.asAlias()
      return self._typeName(t.t)
    } elif it.isArray() {
      t := it.asArray()
      return "arr_" + self._typeName(t.elementType)
    } elif it.isEnum() || it.isObject() {
      return it.name
    } elif it.isFunction() {
      t := it.asFunction()
      mut name := "fn_" + (t.asynchronous ? "a" : "s")

      loop i := 0; i < t.parameters.len; i++ {
        parameter := t.parameters[i]
        name += typeParameterId(parameter) + self._typeName(parameter.t)
      }

      return name + "FR" + self._typeName(t.returnType) + "FE"
    } elif it.isMap() {
      t := it.asMap()
      return "map_" + self._typeName(t.keyType) + "MS" + self._typeName(t.valueType) + "ME"
    } elif it.isMethod() {
      t := it.asMethod()
      mut name := "fn_" + (t.asynchronous ? "a" : "s")

      if t.withSelf {
        name += "FS" + self._typeName(t.selfType)
      }

      loop i := 0; i < t.parameters.len; i++ {
        parameter := t.parameters[i]
        name += typeParameterId(parameter) + self._typeName(parameter.t)
      }

      return name + "FR" + self._typeName(t.returnType) + "FE"
    } elif it.isOptional() {
      t := it.asOptional()
      return "opt_" + self._typeName(t.t)
    } elif it.isReference() {
      t := it.asReference()
      return "ref_" + self._typeName(t.t)
    } elif it.isUnion() {
      t := it.asUnion()
      mut name := ""

      loop i := 0; i < t.types.len; i++ {
        subType := t.types[i] as ref Analyzer.Type
        name += i == 0 ? "" : "US"
        name += self._typeName(subType)
      }

      return "union_" + name + "UE"
    }

    throw error_NewError("Failed to generate type name for '" + it.name + "'")
  }
}

export fn compile (analyzer: ref Analyzer.Analyzer, executablePath: str) {
  mut generator := Codegen{analyzer: analyzer}
  generator.init()
  generator.generate()

  codePath := executablePath + ".c"

  fs_writeFileSync(codePath, generator.stringify().toBuffer())
  process_runSync("clang '" + codePath + "' -o '" + executablePath + "' " + generator.getFlags())
  fs_rmSync(codePath)
}
