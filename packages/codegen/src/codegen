/*!
 * Copyright (c) Aaron Delasy
 * Licensed under the MIT License
 */

import * as Analyzer from "the/analyzer"
import * as AST from "the/c"
import * as Parser from "the/parser"
import BUILTIN_ENTITIES from "./builtin-entities"
import BlockData, BlockDataContext from "./block-data"
import
  createASTPropertyAccess,
  declarationByDependency,
  expressionIsBuiltinMethod,
  expressionResolve,
  expressionShouldBeAllocated,
  expressionShouldBeCopied,
  expressionShouldBeFreed,
  statementHasPrecedingNonDeclaration,
  statementIsMacroInvocation,
  statementIsMacroInvocationDeclare,
  statementIsMacroInvocationForwardDeclare,
  statementMacroInvocationCallee,
  typeIsSimple,
  typeParameterId,
  typeSafeForTernaryAlternate,
  typeSafeForVaArg,
  typeShouldBeAllocated,
  typeShouldBeFreed
from "./helpers"
import sortStrAsc from "./utils"

// TODO: implement EnumDeclaration statement
// TODO: implement TypeAliasDeclaration statement

// TODO: test VariableDeclaration statement
// TODO: test expressions with types other than primitive
// TODO: test If statement
// TODO: add more tests for Loop statement with other types

// TODO: implement Throw statement
// TODO: implement Try statement
// TODO: error object needs to move message and stack properties upfront

// TODO: implement ImportDeclaration statement
// TODO: implement ExportDeclaration statement
// TODO: implement ExportNamedDeclaration statement
// TODO: implement Member type

// TODO: implement async functions
// TODO: implement await expression

// TODO: automatic reference counter and object reference cycles
// TODO: check whether all tests are transferred from old codegen

export obj CodegenAPIBuiltin {
  mut d4Any: bool
  mut d4Array: bool
  mut d4Bool: bool
  mut d4Byte: bool
  mut d4Char: bool
  mut d4Error: bool
  mut d4Fn: bool
  mut d4Globals: bool
  mut d4Macro: bool
  mut d4Map: bool
  mut d4Number: bool
  mut d4Object: bool
  mut d4Optional: bool
  mut d4Reference: bool
  mut d4Rune: bool
  mut d4Safe: bool
  mut d4String: bool
  mut d4Union: bool
  mut stdarg: bool
  mut stdbool: bool
  mut stddef: bool
  mut stdint: bool
  mut stdio: bool
  mut stdlib: bool
  mut wchar: bool
}

export type GenerateReturnType = AST.CStatement | AST.CStatement[]

export obj CodegenEntity {
  mut active: bool
  mut name: str
  mut codeName: str
  mut context: any
  mut generate: (mut self: ref Codegen, entity: ref CodegenEntity) -> GenerateReturnType
}

export obj Codegen {
  mut analyzer: ref Analyzer.Analyzer
  mut builtin: CodegenAPIBuiltin
  mut blockData: BlockData
  mut entities: CodegenEntity[]
  mut flags: str[]
  mut insideLoopHeader: bool
  mut lastTypeId: int
  mut lastVarId: int
  mut mainStatements: AST.CStatement[]
  mut globalStatements: AST.CStatement[]
  mut returnType: (ref Analyzer.Type)?
  mut statements: AST.CStatement[]
  mut typeDefs: int[str]

  fn init (mut self: ref Self) {
    self.blockData.init()
  }

  fn generate (mut self: ref Self) {
    mut file := self.analyzer.files.last()
    self.blockData.increase()
    statements := self._generateBlockBody(ref file.f.program.body)
    statements.merge(self.mainStatements)
    self.mainStatements = statements
    self._assemble()
  }

  fn getFlags (self: ref Self) str {
    mut extraFlags: str[]

    if (
      self.builtin.d4Any ||
      self.builtin.d4Array ||
      self.builtin.d4Bool ||
      self.builtin.d4Byte ||
      self.builtin.d4Char ||
      self.builtin.d4Error ||
      self.builtin.d4Fn ||
      self.builtin.d4Globals ||
      self.builtin.d4Macro ||
      self.builtin.d4Map ||
      self.builtin.d4Number ||
      self.builtin.d4Object ||
      self.builtin.d4Optional ||
      self.builtin.d4Reference ||
      self.builtin.d4Rune ||
      self.builtin.d4Safe ||
      self.builtin.d4String ||
      self.builtin.d4Union
    ) {
      extraFlags.push("-ld4")
    }

    result := [
      "-O0",
      "-W" + "all",
      "-W" + "error",
      "-W" + "extra",
      "-pedantic-errors",
      "-Wno-gnu-binary-literal",
      "-Wno-strict-prototypes",
      "-Wno-unused-but-set-variable",
      "-Wno-unused-value",
      "-Wno-unused-variable",
    ].concat(extraFlags).join(" ")

    return result.empty ? "" : (" " + result)
  }

  fn stringify (self: ref Self) str {
    mut result := ""
    l := self.statements.len

    loop i := 0; i < l; i++ {
      result += self.statements[i].stringify()
    }

    return result
  }

  fn _ (mut self: ref Self, name: str) str {
    if self._hasEntity(name, withBuiltin: false) {
      mut item := self._getEntity(name)

      if !item.active {
        item.active = true
      }

      return item.codeName
    } elif BUILTIN_ENTITIES.get("stdarg").contains(name) {
      self.builtin.stdarg = true
    } elif BUILTIN_ENTITIES.get("stdbool").contains(name) {
      self.builtin.stdbool = true
    } elif BUILTIN_ENTITIES.get("stddef").contains(name) {
      self.builtin.stddef = true
    } elif BUILTIN_ENTITIES.get("stdio").contains(name) {
      self.builtin.stdio = true
    } elif BUILTIN_ENTITIES.get("stdint").contains(name) {
      self.builtin.stdint = true
    } elif BUILTIN_ENTITIES.get("wchar").contains(name) {
      self.builtin.wchar = true
    } elif BUILTIN_ENTITIES.get("d4Any").contains(name) {
      self.builtin.d4Any = true
    } elif BUILTIN_ENTITIES.get("d4Array").contains(name) {
      self.builtin.d4Array = true
    } elif BUILTIN_ENTITIES.get("d4Bool").contains(name) {
      self.builtin.d4Bool = true
    } elif BUILTIN_ENTITIES.get("d4Byte").contains(name) {
      self.builtin.d4Byte = true
    } elif BUILTIN_ENTITIES.get("d4Char").contains(name) {
      self.builtin.d4Char = true
    } elif BUILTIN_ENTITIES.get("d4Error").contains(name) {
      self.builtin.d4Error = true
    } elif BUILTIN_ENTITIES.get("d4Fn").contains(name) {
      self.builtin.d4Fn = true
    } elif BUILTIN_ENTITIES.get("d4Globals").contains(name) {
      self.builtin.d4Globals = true
    } elif BUILTIN_ENTITIES.get("d4Macro").contains(name) {
      self.builtin.d4Macro = true
    } elif BUILTIN_ENTITIES.get("d4Map").contains(name) {
      self.builtin.d4Map = true
    } elif BUILTIN_ENTITIES.get("d4Number").contains(name) {
      self.builtin.d4Number = true
    } elif BUILTIN_ENTITIES.get("d4Object").contains(name) {
      self.builtin.d4Object = true
    } elif BUILTIN_ENTITIES.get("d4Optional").contains(name) {
      self.builtin.d4Optional = true
    } elif BUILTIN_ENTITIES.get("d4Reference").contains(name) {
      self.builtin.d4Reference = true
    } elif BUILTIN_ENTITIES.get("d4Rune").contains(name) {
      self.builtin.d4Rune = true
    } elif BUILTIN_ENTITIES.get("d4Safe").contains(name) {
      self.builtin.d4Safe = true
    } elif BUILTIN_ENTITIES.get("d4String").contains(name) {
      self.builtin.d4String = true
    } elif BUILTIN_ENTITIES.get("d4Union").contains(name) {
      self.builtin.d4Union = true
    } else {
      throw error_NewError("Tried activating unknown entity '" + name + "'")
    }

    return name
  }

  fn _allocateExpression (mut self: ref Self, t: ref Analyzer.Type, expression: AST.CExpression) AST.CExpression {
    tmpVar := self._tmpVar()
    tmpVarId := AST.createIdentifier(tmpVar)

    self.blockData.addSetup(
      AST.createVariableDeclaration(
        AST.createType(self._type(t)),
        tmpVar,
        self._defaultInitializerExpression(t),
      ),
    )

    self.blockData.addTeardown(
      AST.createExpressionStatement(self._functionFree(t, tmpVarId)),
    )

    return AST.createAssignmentExpression(tmpVarId, "=", expression)
  }

  fn _assemble (mut self: ref Self) {
    mut prevActive := 0

    loop {
      mut currentActive := 0

      loop i := 0; i < self.entities.len; i++ {
        entity := self.entities[i]

        if !entity.active {
          continue
        }

        entity.generate(self, entity)
        currentActive++
      }

      if prevActive == currentActive {
        break
      }

      prevActive = currentActive
    }

    mut defineStatements: AST.CStatement[]
    mut macroInvocationDeclareStatements: AST.CStatement[]
    mut macroInvocationForwardDeclareStatements: AST.CStatement[]
    mut macroInvocationDefineStatements: AST.CStatement[]
    mut statements: AST.CStatement[]

    loop i := 0; i < self.entities.len; i++ {
      entity := self.entities[i]

      if !entity.active {
        continue
      }

      result := entity.generate(self, entity)
      resultStatements := (result is AST.CStatement) ? [result] : result

      loop j := 0; j < resultStatements.len; j++ {
        item := resultStatements[j]

        if item.isDefineDirective() {
          defineStatements.push(item)
        } elif statementIsMacroInvocation(item) {
          if statementIsMacroInvocationForwardDeclare(item) {
            macroInvocationForwardDeclareStatements.push(item)
          } elif statementIsMacroInvocationDeclare(item) {
            macroInvocationDeclareStatements.push(item)
          } else {
            macroInvocationDefineStatements.push(item)
          }
        } else {
          statements.push(item)
        }
      }
    }

    if self.builtin.d4Any { self.statements.push(AST.createIncludeDirective("d4/any.h")) }
    if self.builtin.d4Array { self.statements.push(AST.createIncludeDirective("d4/array.h")) }
    if self.builtin.d4Bool { self.statements.push(AST.createIncludeDirective("d4/bool.h")) }
    if self.builtin.d4Byte { self.statements.push(AST.createIncludeDirective("d4/byte.h")) }
    if self.builtin.d4Char { self.statements.push(AST.createIncludeDirective("d4/char.h")) }
    if self.builtin.d4Error { self.statements.push(AST.createIncludeDirective("d4/error.h")) }
    if self.builtin.d4Fn { self.statements.push(AST.createIncludeDirective("d4/fn.h")) }
    if self.builtin.d4Globals { self.statements.push(AST.createIncludeDirective("d4/globals.h")) }
    if self.builtin.d4Macro { self.statements.push(AST.createIncludeDirective("d4/macro.h")) }
    if self.builtin.d4Map { self.statements.push(AST.createIncludeDirective("d4/map.h")) }
    if self.builtin.d4Number { self.statements.push(AST.createIncludeDirective("d4/number.h")) }
    if self.builtin.d4Object { self.statements.push(AST.createIncludeDirective("d4/object.h")) }
    if self.builtin.d4Optional { self.statements.push(AST.createIncludeDirective("d4/optional.h")) }
    if self.builtin.d4Reference { self.statements.push(AST.createIncludeDirective("d4/reference.h")) }
    if self.builtin.d4Rune { self.statements.push(AST.createIncludeDirective("d4/rune.h")) }
    if self.builtin.d4Safe { self.statements.push(AST.createIncludeDirective("d4/safe.h")) }
    if self.builtin.d4String { self.statements.push(AST.createIncludeDirective("d4/string.h")) }
    if self.builtin.d4Union { self.statements.push(AST.createIncludeDirective("d4/union.h")) }

    if self.builtin.stdarg { self.statements.push(AST.createIncludeDirective("stdarg.h")) }
    if self.builtin.stdbool { self.statements.push(AST.createIncludeDirective("stdbool.h")) }
    if self.builtin.stddef { self.statements.push(AST.createIncludeDirective("stddef.h")) }
    if self.builtin.stdio { self.statements.push(AST.createIncludeDirective("stdio.h")) }
    if self.builtin.stdint { self.statements.push(AST.createIncludeDirective("stdint.h")) }
    if self.builtin.stdlib { self.statements.push(AST.createIncludeDirective("stdlib.h")) }
    if self.builtin.wchar { self.statements.push(AST.createIncludeDirective("wchar.h")) }

    self.statements.merge(defineStatements)
    self.statements.merge(macroInvocationForwardDeclareStatements)
    self.statements.merge(macroInvocationDeclareStatements)
    self.statements.merge(macroInvocationDefineStatements)
    self.statements.merge(statements)
    self.statements.merge(self.globalStatements)

    dataContextBlock := self.blockData.decrease()
    mut finalMainStatements: AST.CStatement[]

    finalMainStatements.merge(dataContextBlock.setup)
    finalMainStatements.merge(self.mainStatements)
    finalMainStatements.merge(dataContextBlock.teardown)

    self.statements.push(
      AST.createFunctionDeclaration(
        AST.createType("int"),
        "main",
        [AST.createFunctionParameter(AST.createType("void"))],
        AST.createCompoundStatement(finalMainStatements),
      ),
    )
  }

  fn _declareStatement (mut self: ref Self, item: ref Parser.Statement) bool {
    if item.isFunctionDeclaration() {
      self._declareFunction(item)
    } elif item.isMainDeclaration() {
      self._declareMain(item)
    } elif item.isObjectDeclaration() {
      self._declareObject(item)
    }
  }

  fn _declareMain (mut self: ref Codegen, item: ref Parser.Statement) void {
    statement := item.asMainDeclaration()
    statementBody := statement.body.asBlock()

    self.blockData.increase()
    self.mainStatements = self._generateBlockBody(ref statementBody.body)
    dataContextBlock := self.blockData.decrease()
    self.blockData.currentMerge(dataContextBlock.setup, dataContextBlock.teardown)
  }

  fn _declareFunction (mut self: ref Codegen, item: ref Parser.Statement) void {
    statement := item.asFunctionDeclaration()

    if !(item.context is Analyzer.FunctionDeclarationContext) {
      throw error_NewError("Expected FunctionDeclaration context")
    }

    context := item.context as Analyzer.FunctionDeclarationContext
    self._generateFunctionType(context.selfType)

    self.blockData.setVariable(statement.name.name)
  }

  fn _declareObject (mut self: ref Codegen, item: ref Parser.Statement) void {
    statement := item.asObjectDeclaration()

    if !(item.context is Analyzer.ObjectDeclarationContext) {
      throw error_NewError("Expected ObjectDeclaration context")
    }

    context := item.context as Analyzer.ObjectDeclarationContext
    self._generateObjectType(context.selfType)
  }

  fn _defaultInitializerExpression (mut self: ref Self, it: ref Analyzer.Type) AST.CExpression {
    if it.isAlias() {
      t := it.asAlias()
      return self._defaultInitializerExpression(t.t)
    } elif it.name == "any" {
      return AST.createInitializerListExpression([
        AST.createLiteral("-1"),
        AST.createIdentifier(self._("NULL")),
        AST.createIdentifier(self._("NULL")),
        AST.createIdentifier(self._("NULL")),
        AST.createIdentifier(self._("NULL")),
        AST.createIdentifier(self._("NULL")),
      ])
    }

    return self._defaultInitializerDeclaration(it)
  }

  fn _defaultInitializerDeclaration (mut self: ref Self, it: ref Analyzer.Type) AST.CExpression {
    if it.isAlias () {
      t := it.asAlias()
      return self._defaultInitializerDeclaration(t.t)
    } elif it.name == "any" {
      return AST.createCastExpression(AST.createType(self._("d4_any_t")), AST.createInitializerListExpression([
        AST.createLiteral("-1"),
        AST.createIdentifier(self._("NULL")),
        AST.createIdentifier(self._("NULL")),
        AST.createIdentifier(self._("NULL")),
        AST.createIdentifier(self._("NULL")),
        AST.createIdentifier(self._("NULL")),
      ]))
    } elif it.name == "bool" {
      return AST.createIdentifier(self._("false"))
    } elif it.name == "char" {
      return AST.createLiteral("'\\0'")
    } elif it.name == "rune" {
      return AST.createLiteral("L'\\0'")
    } elif it.name == "str" {
      return AST.createIdentifier(self._("d4_str_empty_val"))
    } elif it.isArray() || it.isMap() {
      return AST.createCallExpression(AST.createIdentifier(self._type(it, "_alloc")), [
        AST.createLiteral("0"),
      ])
    } elif it.isFunction() || it.isMethod() {
      // TODO: test
      return AST.createCallExpression(AST.createIdentifier(self._type(it, "_alloc")), [
        AST.createIdentifier(self._("d4_str_empty_val")),
        AST.createIdentifier(self._("NULL")),
        AST.createIdentifier(self._("NULL")),
        AST.createIdentifier(self._("NULL")),
        AST.createIdentifier(self._("NULL")),
      ])
    } elif it.isCustomObject() {
      // TODO: test
      mut args: (AST.CExpression | AST.CType)[]
      loop i := 0; i < it.properties.len; i++ {
        property := it.properties[i]
        if property.builtin || property.t.isMethod() {
          continue
        }
        args.push(self._defaultInitializerDeclaration(property.t))
      }
      return AST.createCallExpression(AST.createIdentifier(self._type(it, "_alloc")), args)
    } elif it.isOptional() || it.isReference() {
      return AST.createIdentifier(self._("NULL"))
    } elif it.isUnion() {
      return AST.createCallExpression(AST.createIdentifier(self._type(it, "_alloc")), [
        AST.createLiteral("-1"),
      ])
    } elif it.isNumber() {
      return AST.createLiteral("0")
    }

    throw error_NewError("Tried default initializer variable declaration on unknown type '" + it.toString() + "'")
  }

  fn _defineFunction (
    mut self: ref Codegen,
    name: Parser.Identifier,
    parameters: Parser.FunctionParameter[],
    body: Parser.Statement,
    t: ref Analyzer.Type,
  ) AST.CStatement {
    variableName := self.blockData.getVariable(name.name)
    cType := AST.createType(self._type(t))

    self.globalStatements.push(AST.createVariableDeclaration(cType, variableName))

    self.blockData.addTeardown(
      AST.createExpressionStatement(
        self._functionFree(t, AST.createIdentifier(variableName)),
      ),
    )

    allocTypeName := self._type(t, "_alloc")

    return AST.createExpressionStatement(
      AST.createAssignmentExpression(
        AST.createIdentifier(variableName),
        "=",
        AST.createCallExpression(AST.createIdentifier(allocTypeName), [
          self._str(name.name),
          AST.createIdentifier(self._("NULL")), // ctx
          AST.createIdentifier(self._("NULL")), // ctx copy
          AST.createIdentifier(self._("NULL")), // ctx free
          AST.createIdentifier(self._("NULL")), // fn
        ]),
      ),
    )

    // auto initialStateCleanUp = this->state.cleanUp;
    // auto initialStateReturnType = this->state.returnType;
    // this->state.cleanUp = CodegenCleanUp(CODEGEN_CLEANUP_FN, &initialStateCleanUp);
    // this->_apiEntity(typeName, CODEGEN_ENTITY_FN, [&] (auto &decl, auto &def) {
    //   this->varMap.save();
    //   if (hasParams) {
    //     body += Params *p = pp;
    //     cleanUp += free(pp);
    //   }
    //   if (hasSelfParam) {
    //     body += mut? selfName: SelfType = p->self;
    //   }
    //   if (!params.empty()) {
    //     for (param, paramIdx) : params {
    //       body += mut? ParamName: ParamType = init == nil
    //         ? p->[n + paramIdx]
    //         : p->[o + paramIdx] == 1
    //           ? p->[n + paramIdxStr]
    //           : init
    //       cleanUp += free(ParamName);
    //     }
    //   }
    //   if (hasSelfParam && fnType.callInfo.selfType->shouldBeFreed()) {
    //     cleanUp += free(selfName);
    //   }
    //   this->state.returnType = fnType.returnType;
    //   this->_block(&cBody, *body, false);
    //   this->varMap.restore();
    //   if (!fnType.returnType->isVoid() && this->state.cleanUp.valueVarUsed) {
    //     body >>= ReturnType v;
    //   }
    //   if (!fnType.returnType->isVoid() this->state.cleanUp.valueVarUsed) {
    //     body += return v;
    //   }
    //   decl += "void *);";
    //   def += "void *px) " + body->str(0, false);
    //   return 0;
    // });
    // this->state.cleanUp = initialStateCleanUp;
    // this->state.returnType = initialStateReturnType;
  }

  fn _functionCopy (mut self: ref Self, it: ref Analyzer.Type, expression: AST.CExpression) AST.CExpression {
    t := Analyzer.unwrap(it, withReference: false)

    if (
      t.name == "any" ||
      t.name == "str" ||
      t.isArray() ||
      t.isFunction() ||
      t.isMap() ||
      // TODO: test
      t.isMethod() ||
      // TODO: test
      t.isCustomObject() ||
      t.isOptional() ||
      t.isUnion()
    ) {
      return AST.createCallExpression(AST.createIdentifier(self._type(t, "_copy")), [expression])
    }

    return expression
  }

  fn _functionEq (mut self: ref Self, it: ref Analyzer.Type, left: AST.CExpression, right: AST.CExpression, reverse := false) AST.CExpression {
    t := Analyzer.unwrap(it, withReference: false)

    if (
      t.name == "any" ||
      t.name == "str" ||
      t.isArray() ||
      // TODO: test
      t.isFunction() ||
      t.isMap() ||
      // TODO: test
      t.isMethod() ||
      // TODO: test
      t.isCustomObject() ||
      t.isOptional() ||
      t.isUnion()
    ) {
      result := AST.createCallExpression(AST.createIdentifier(self._type(t, "_eq")), [left, right])
      return reverse ? AST.createUnaryExpression("!", result) : result
    }

    return AST.createAssignmentExpression(left, reverse ? "!=" : "==", right)
  }

  fn _functionFree (mut self: ref Self, it: ref Analyzer.Type, expression: AST.CExpression) AST.CExpression {
    t := Analyzer.unwrap(it, withReference: false)

    if (
      t.name == "any" ||
      t.name == "str" ||
      t.isArray() ||
      t.isFunction() ||
      t.isMap() ||
      // TODO: test
      t.isMethod() ||
      // TODO: test
      t.isCustomObject() ||
      t.isOptional() ||
      t.isUnion()
    ) {
      return AST.createCallExpression(AST.createIdentifier(self._type(t, "_free")), [expression])
    }

    return AST.createCastExpression(AST.createType("void"), expression)
  }

  fn _functionRealloc (mut self: ref Self, it: ref Analyzer.Type, left: AST.CExpression, right: AST.CExpression) AST.CExpression {
    t := Analyzer.unwrap(it, withReference: false)

    if (
      t.name == "any" ||
      t.name == "str" ||
      t.isArray() ||
      t.isFunction() ||
      t.isMap() ||
      // TODO: test
      t.isMethod() ||
      // TODO: test
      t.isCustomObject() ||
      t.isOptional() ||
      t.isUnion()
    ) {
      return AST.createAssignmentExpression(
        left,
        "=",
        AST.createCallExpression(
          AST.createIdentifier(self._type(t, "_realloc")),
          [left, right]
        ),
      )
    }

    throw error_NewError("Tried re-allocating unknown type '" + t.toString() + "'")
  }

  fn _functionStr (mut self: ref Self, it: ref Analyzer.Type, expression: AST.CExpression, quote := false) AST.CExpression {
    if it.isAlias() {
      t := it.asAlias()
      return self._functionStr(t.t, expression, quote: quote)
    } elif it.name == "any" {
      return AST.createCallExpression(AST.createIdentifier(self._("d4_any_str")), [expression])
    } elif it.name == "str" && quote {
      return AST.createCallExpression(AST.createIdentifier(self._("d4_str_quoted_escape")), [expression])
    } elif it.name == "str" {
      return AST.createCallExpression(AST.createIdentifier(self._("d4_str_copy")), [expression])
    } elif it.isEnum() {
      return AST.createCallExpression(AST.createIdentifier(self._("d4_enum_str")), [expression])
    } elif it.isReference() {
      t := it.asReference()
      return self._functionStr(t.t, AST.createUnaryExpression("*", expression), quote: quote)
    } elif (
      it.name == "bool" ||
      it.name == "byte" ||
      it.name == "char" ||
      it.name == "rune" ||
      it.isNumber()
    ) {
      typeName := self._typeName(it)
      return AST.createCallExpression(AST.createIdentifier(self._("d4_" + typeName + "_str")), [expression])
    } elif (
      it.isArray() ||
      // TODO: test
      it.isEnum() ||
      // TODO: test
      it.isFunction() ||
      it.isMap() ||
      // TODO: test
      it.isMethod() ||
      // TODO: test
      it.isCustomObject() ||
      it.isOptional() ||
      it.isUnion()
    ) {
      return AST.createCallExpression(AST.createIdentifier(self._type(it, "_str")), [expression])
    }

    throw error_NewError("Tried stringifying unknown type '" + it.toString() + "'")
  }

  fn _generateBlock (mut self: ref Self, items: ref Parser.Statement[]) AST.CStatement[] {
    if items.empty {
      return []
    }

    self.blockData.increase()
    result := self._generateBlockBody(items)
    blockData := self.blockData.decrease()

    return self._generateBlockTail(result, items.first.parentMaybe(), ref blockData)
  }

  fn _generateBlockBody (mut self: ref Self, items: ref Parser.Statement[]) AST.CStatement[] {
    mut result: AST.CStatement[]
    l := items.len
    mut mainDeclaration: (ref Parser.Statement)?
    mut declarations: (ref Parser.Statement)[]

    loop i := 0; i < l; i++ {
      item := items[i]

      if item.isMainDeclaration() {
        mainDeclaration = item
      } elif item.isDeclaration() {
        declarations.push(item)
      }
    }

    declarations.sort(declarationByDependency)
    dl := declarations.len

    loop i := 0; i < dl; i++ {
      declaration := declarations[i] as ref Parser.Statement
      self._declareStatement(declaration)
    }

    loop i := 0; i < l; i++ {
      item := items[i]
      declarationAsStatement := item.isFunctionDeclaration()

      if !(item.isDeclaration() && !declarationAsStatement) {
        result.push(self._generateStatement(item))
      }

      // if !hasNextItem || !items[i + 1].isDeclaration() {
      //   self._generateStatement(item, .Alloc)
      //   result.push(self._generateStatement(item, .Init))
      //   continue
      // }
      // loop j := i; j < l && items[j].isDeclaration(); j++ {
      //   self._generateStatement(items[j], .Alloc)
      // }
      // result.push(self._generateStatement(item, .Init))
      // loop ; i + 1 < l && items[i + 1].isDeclaration(); i++ {
      //   result.push(self._generateStatement(items[i + 1], .Init))
      // }
    }

    if mainDeclaration != nil {
      self._declareStatement(mainDeclaration)
    }

    return result
  }

  fn _generateBlockTail (mut self: ref Self, result: AST.CStatement[], parent: (ref Parser.Statement)?, blockData: ref BlockDataContext) AST.CStatement[] {
    mut finalResult: AST.CStatement[]
    finalResult.merge(blockData.setup)
    finalResult.merge(result)
    finalResult.merge(blockData.teardown)

    mut parentIsLoop := false

    if parent != nil {
      parentIsLoop = parent.isLoopDeep()
    }

    if !parentIsLoop && blockData.usedContinueVariable {
      finalResult.push(
        AST.createIfStatement(
          AST.createBinaryExpression(
            AST.createIdentifier(blockData.continueVariable()),
            "==",
            AST.createLiteral("1"),
          ),
          self.blockData.hasUntil(.Loop)
            ? AST.createGotoStatement(self.blockData.getLabel())
            : AST.createContinueStatement(),
        )
      )
    }

    if blockData.usedBreakVariable {
      finalResult.push(
        AST.createIfStatement(
          AST.createBinaryExpression(
            AST.createIdentifier(blockData.breakVariable()),
            "==",
            AST.createLiteral("1"),
          ),
          !parentIsLoop && self.blockData.hasUntil(.Loop)
            ? AST.createGotoStatement(self.blockData.getLabel())
            : AST.createBreakStatement(),
        )
      )
    }

    if blockData.usedReturnVariable { // TODO: !this->state.cleanUp.empty()
      //(*c)->append(
      //  CodegenASTStmtIf::create(
      //    CodegenASTExprBinary::create(
      //      CodegenASTExprAccess::create("r"),
      //      "==",
      //      CodegenASTExprLiteral::create("1")
      //    ),
      //    initialStateCleanUp.hasCleanUp(CODEGEN_CLEANUP_FN)
      //      ? CodegenASTStmtGoto::create(initialStateCleanUp.currentLabel())
      //      : CodegenASTStmtReturn::create()
      //  )
      //);
    }

    return finalResult
  }

  fn _generateExpression (mut self: ref Self, item: ref Parser.Expression, transform := true) AST.CExpression {
    mut result: AST.CExpression?

    if (
      (result = self._generateIdentifier(item)) != nil ||
      (result = self._generateCallExpression(item)) != nil ||
      (result = self._generateLiteral(item)) != nil ||
      (result = self._generateParenthesizedExpression(item)) != nil ||
      (result = self._generateArrayExpression(item)) != nil ||
      (result = self._generateAsExpression(item)) != nil ||
      (result = self._generateAssignmentExpression(item)) != nil ||
      (result = self._generateBinaryExpression(item)) != nil ||
      (result = self._generateConditionalExpression(item)) != nil ||
      (result = self._generateElementAccessExpression(item)) != nil ||
      (result = self._generateIsExpression(item)) != nil ||
      (result = self._generateMapExpression(item)) != nil ||
      (result = self._generateObjectExpression(item)) != nil ||
      (result = self._generatePropertyAccessExpression(item)) != nil ||
      (result = self._generateReferenceExpression(item)) != nil ||
      (result = self._generateUnaryExpression(item)) != nil
    ) {
      initialType := Analyzer.contextInitial(item)
      targetType := Analyzer.contextTarget(item)

      return self._wrap(result, item, initialType, targetType, transform: transform)
    }

    throw error_NewError("Tried code generation for unknown expression '" + Parser.stringifyExpression(item) + "'")
  }

  fn _generateStatement (mut self: ref Self, item: ref Parser.Statement) AST.CStatement {
    mut result: AST.CStatement?

    if (
      (result = self._generateBlockStatement(item)) != nil ||
      (result = self._generateBreakStatement(item)) != nil ||
      (result = self._generateContinueStatement(item)) != nil ||
      (result = self._generateExpressionStatement(item)) != nil ||
      (result = self._generateFunctionDeclaration(item)) != nil ||
      (result = self._generateIfStatement(item)) != nil ||
      (result = self._generateLoopStatement(item)) != nil ||
      (result = self._generateReturnStatement(item)) != nil ||
      (result = self._generateThrowStatement(item)) != nil ||
      (result = self._generateTryStatement(item)) != nil ||
      (result = self._generateVariableDeclaration(item)) != nil
    ) {
      return result
    }

    throw error_NewError("Tried code generation for unknown statement '" + Parser.stringifyStatement(item) + "'")
  }

  fn _generateIdentifier (mut self: ref Codegen, item: ref Parser.Expression) AST.CExpression? {
    if !item.isIdentifier() {
      return nil
    }

    expression := item.asIdentifier()
    mut name := expression.name

    if name == "print" {
      name = self._("d4_print")
    } elif self._hasEntity(name) {
      name = self._(name)
    } else {
      name = self.blockData.getVariable(name)
    }

    return AST.createIdentifier(name)
  }

  fn _generateLiteral (mut self: ref Codegen, item: ref Parser.Expression) AST.CExpression? {
    mut tm := self._tm()

    if item.isBooleanLiteral() {
      expression := item.asBooleanLiteral()
      return AST.createLiteral(self._(expression.value))
    } elif item.isCharacterLiteral() {
      expression := item.asCharacterLiteral()
      return AST.createLiteral("L'" + expression.value + "'")
    } elif item.isFloatingPointLiteral() {
      expression := item.asFloatingPointLiteral()
      return AST.createLiteral(expression.value)
    } elif item.isIntegerLiteral() {
      expression := item.asIntegerLiteral()
      rawValue := expression.value.replace("O", "").replace("o", "")

      if !rawValue.contains("b") && !rawValue.contains("B") && !rawValue.contains("x") && !rawValue.contains("X") {
        numValue := rawValue.toU64()
        return AST.createLiteral(rawValue + (numValue > 9223372036854775807 ? "U" : ""))
      }

      return AST.createLiteral(rawValue)
    } elif item.isNilLiteral() {
      expression := item.asNilLiteral()
      return AST.createIdentifier(self._("NULL"))
    } elif item.isStringLiteral() {
      expression := item.asStringLiteral()
      sanitizedValue := expression.value
        .replace(os_EOL, "\" " + self._("D4_EOL") + " \"")
        .replace("\n", "\" " + self._("D4_EOL") + " \"")
      rawValue := "L\"" + sanitizedValue + "\""

      return AST.createCallExpression(
        AST.createIdentifier(self._("d4_str_alloc")),
        [AST.createLiteral(rawValue)],
      )
    }

    return nil
  }

  fn _generateArrayExpression (mut self: ref Codegen, item: ref Parser.Expression) AST.CExpression? {
    if !item.isArray() {
      return nil
    }

    expression := item.asArray()
    targetType := Analyzer.contextTarget(item)
    mut arguments: (AST.CExpression | AST.CType)[] = [AST.createLiteral(expression.elements.len.str())]

    loop i := 0; i < expression.elements.len; i++ {
      element := expression.elements[i]
      arguments.push(self._generateExpression(element))
    }

    return AST.createCallExpression(AST.createIdentifier(self._type(targetType, "_alloc")), arguments)
  }

  fn _generateAsExpression (mut self: ref Codegen, item: ref Parser.Expression) AST.CExpression? {
    if !item.isAs() {
      return nil
    }

    expression := item.asAs()

    if !(item.contextExtra is Analyzer.AsExpressionContextExtra) {
      throw error_NewError("Expected AsExpression context extra")
    }

    initialType := Analyzer.contextInitial(item)
    contextExtra := item.contextExtra as Analyzer.AsExpressionContextExtra
    result := self._generateExpression(ref expression.expression)

    if Analyzer.match(contextExtra.fromType, initialType) {
      return result
    }

    return self._wrap(result, item, contextExtra.fromType, initialType)
  }

  fn _generateAssignmentExpression (mut self: ref Codegen, item: ref Parser.Expression) AST.CExpression? {
    if !item.isAssignment() {
      return nil
    }

    expression := item.asAssignment()
    leftType := Analyzer.unwrap(Analyzer.contextTarget(ref expression.left), withReference: false)
    rightType := Analyzer.unwrap(Analyzer.contextTarget(ref expression.right), withReference: false)
    left := self._generateExpression(ref expression.left, transform: false)
    mut right := self._generateExpression(ref expression.right)

    if expression.operator.t == .OpPlusEq && (leftType.name == "str" || rightType.name == "str") {
      return self._functionRealloc(
        leftType,
        left,
        self._allocateExpression(
          leftType,
          AST.createCallExpression(AST.createIdentifier(self._("d4_str_concat")), [left, right]),
        ),
      )
    } elif !typeIsSimple(leftType) || !typeIsSimple(rightType) {
      return self._functionRealloc(leftType, left, right)
    } elif expression.operator.t == .OpAmpAmp || expression.operator.t == .OpPipePipe {
      right = AST.createBinaryExpression(left, expression.operator.val, right)
      return AST.createAssignmentExpression(left, "=", right)
    }

    return AST.createAssignmentExpression(left, expression.operator.val, right)
  }

  fn _generateBinaryExpression (mut self: ref Codegen, item: ref Parser.Expression) AST.CExpression? {
    if !item.isBinary() {
      return nil
    }

    expression := item.asBinary()
    wrappedLeftType := Analyzer.unwrap(Analyzer.contextTarget(ref expression.left), withReference: false)
    leftType := Analyzer.unwrap(wrappedLeftType)
    wrappedRightType := Analyzer.unwrap(Analyzer.contextTarget(ref expression.right), withReference: false)
    rightType := Analyzer.unwrap(wrappedRightType)
    mut left := self._generateExpression(ref expression.left)
    mut right := self._generateExpression(ref expression.right)
    operatorSafeForRef := expression.operator.t == .OpEqEq || expression.operator.t == .OpExclEq

    if !operatorSafeForRef && wrappedLeftType.isReference() {
      left = self._wrap(left, ref expression.left, wrappedLeftType, leftType)
    }

    if !operatorSafeForRef && wrappedRightType.isReference() {
      right = self._wrap(right, ref expression.right, wrappedRightType, rightType)
    }

    if (
      (expression.operator.t == .OpEqEq || expression.operator.t == .OpExclEq) &&
      (!typeIsSimple(leftType) || !typeIsSimple(rightType))
    ) {
      return self._functionEq(leftType, left, right, reverse: expression.operator.t == .OpExclEq)
    } elif leftType.name == "str" && rightType.name == "str" && (
      expression.operator.t == .OpLt ||
      expression.operator.t == .OpLtEq ||
      expression.operator.t == .OpGt ||
      expression.operator.t == .OpGtEq
    ) {
      operator := expression.operator.t == .OpLt
        ? "lt"
        : expression.operator.t == .OpLtEq
          ? "le"
          : expression.operator.t == .OpGt
            ? "gt"
            : "ge"

      return AST.createCallExpression(AST.createIdentifier(self._("d4_str_" + operator)), [left, right])
    } elif expression.operator.t == .OpPlus && leftType.name == "str" && rightType.name == "str" {
      return AST.createCallExpression(AST.createIdentifier(self._("d4_str_concat")), [left, right])
    }

    return AST.createBinaryExpression(left, expression.operator.val, right)
  }

  fn _generateCallExpression (mut self: ref Codegen, item: ref Parser.Expression) AST.CExpression? {
    if !item.isCall() {
      return nil
    }

    expression := item.asCall()

    if !(item.contextExtra is Analyzer.CallExpressionContextExtra) {
      throw error_NewError("Expected CallExpression context extra")
    }

    contextExtra := item.contextExtra as Analyzer.CallExpressionContextExtra
    isBuiltinMethod := expressionIsBuiltinMethod(ref expression.callee)
    calleeTargetType := Analyzer.contextTarget(ref expression.callee)
    cCalleeExpression := self._generateExpression(ref expression.callee)
    mut paramsArgs: AST.CExpression[]

    if !isBuiltinMethod && calleeTargetType.hasSelfParam() {
      paramsArgs.push(cCalleeExpression)
    } elif calleeTargetType.hasSelfParam() {
      calleeBody := expression.callee.asPropertyAccess()
      paramsArgs.push(self._generateExpression(ref calleeBody.expression))
    }

    loop i := 0; i < contextExtra.parameters.len; i++ {
      param := contextExtra.parameters[i]

      if param.variadic {
        mut variadicArgs: (AST.CExpression | AST.CType)[]

        loop j := 0; j < contextExtra.arguments.len; j++ {
          arg := contextExtra.arguments[j]
          if arg.parameterIdx != i { continue }
          variadicArgs.push(self._generateExpression(ref arg.argument.expression))
        }

        mut variadicAllocArgs: (AST.CExpression | AST.CType)[] = [AST.createLiteral(variadicArgs.len.str())]
        variadicAllocArgs.merge(variadicArgs)
        variadicAllocType := self._type(param.t, "_alloc")
        paramsArgs.push(AST.createCallExpression(AST.createIdentifier(variadicAllocType), variadicAllocArgs))

        continue
      }

      mut argIdx := -1

      loop j := 0; j < contextExtra.arguments.len; j++ {
        arg := contextExtra.arguments[j]

        if arg.parameterIdx == i {
          argIdx = j
          break
        }
      }

      if !param.required {
        paramsArgs.push(AST.createLiteral(argIdx == -1 ? "0" : "1"))
      }

      if argIdx != -1 {
        arg := contextExtra.arguments[argIdx]
        paramsArgs.push(self._generateExpression(ref arg.argument.expression))
      } else {
        paramsArgs.push(self._defaultInitializerDeclaration(param.t))
      }
    }

    mut args: (AST.CExpression | AST.CType)[] = []

    if isBuiltinMethod {
      calleeBody := expression.callee.asPropertyAccess()
      calleeBodyTargetType := Analyzer.unwrap(Analyzer.contextTarget(ref calleeBody.expression))

      if !paramsArgs.empty {
        loop i := 0; i < paramsArgs.len; i++ {
          paramsArg := paramsArgs[i] as AST.CExpression
          args.push(paramsArg)
        }
      }

      return AST.createCallExpression(
        AST.createIdentifier(self._type(calleeBodyTargetType, "_" + calleeBody.name.name)),
        args,
      )
    }

    args.push(createASTPropertyAccess(cCalleeExpression, "ctx"))

    if paramsArgs.empty {
      args.push(AST.createIdentifier(self._("NULL")))
    } else {
      tmpVar := self._tmpVar()
      cTmpVar := AST.createIdentifier(tmpVar)
      paramsName := self._type(calleeTargetType, "_params_t")

      self.blockData.addSetup(
        AST.createVariableDeclaration(AST.createType("void *"), tmpVar),
      )

      args.push(
        AST.createAssignmentExpression(
          cTmpVar,
          "=",
          AST.createCallExpression(AST.createIdentifier(self._("d4_safe_calloc")), [
        AST.createUnaryExpression("&", AST.createCastExpression(
          AST.createType(paramsName),
          AST.createInitializerListExpression(paramsArgs),
        )),
        AST.createCallExpression(AST.createIdentifier("sizeof"), [
          AST.createType(paramsName),
        ]),
          ]),
        ),
      )

      self.blockData.addTeardown(
        AST.createExpressionStatement(
          AST.createCallExpression(AST.createIdentifier(self._("d4_safe_free")), [cTmpVar]),
        ),
      )
    }

    return AST.createCallExpression(createASTPropertyAccess(cCalleeExpression, "func"), args)
  }

  fn _generateConditionalExpression (mut self: ref Codegen, item: ref Parser.Expression) AST.CExpression? {
    if !item.isConditional() {
      return nil
    }

    expression := item.asConditional()
    alternateType := Analyzer.unwrap(Analyzer.contextTarget(ref expression.alternate), withReference: false)
    mut alternate := self._generateExpression(ref expression.alternate, transform: false)

    if alternate.isAssignmentExpression() && !typeSafeForTernaryAlternate(alternateType) {
      alternate = alternate.wrap()
    }

    return AST.createConditionalExpression(
      self._generateExpression(ref expression.condition),
      self._generateExpression(ref expression.consequent, transform: false),
      alternate,
    )
  }

  fn _generateElementAccessExpression (mut self: ref Codegen, item: ref Parser.Expression) AST.CExpression? {
    if !item.isElementAccess() {
      return nil
    }

    expression := item.asElementAccess()

    if !(item.contextExtra is Analyzer.ElementAccessExpressionContextExtra) {
      throw error_NewError("Expected ElementAccessExpression context extra")
    }

    contextExtra := item.contextExtra as Analyzer.ElementAccessExpressionContextExtra
    startLoc := Parser.Reader_locate(self._r(), item.start)

    return AST.createCallExpression(AST.createIdentifier(self._type(contextExtra.selfType, "_at")), [
      AST.createUnaryExpression("&", AST.createIdentifier(self._("d4_err_state"))),
      AST.createLiteral(startLoc.line.str()),
      AST.createLiteral(startLoc.col.str()),
      self._generateExpression(ref expression.expression),
      self._generateExpression(ref expression.argument),
    ])
  }

  fn _generateIsExpression (mut self: ref Codegen, item: ref Parser.Expression) AST.CExpression? {
    if !item.isIs() {
      return nil
    }

    expression := item.asIs()

    if !(item.contextExtra is Analyzer.IsExpressionContextExtra) {
      throw error_NewError("Expected IsExpression context extra")
    }

    contextExtra := item.contextExtra as Analyzer.IsExpressionContextExtra
    mut left := self._generateExpression(ref expression.expression)
    leftType := Analyzer.contextTarget(ref expression.expression)
    right := AST.createIdentifier(self._typeDef(contextExtra.t))

    if Analyzer.match(contextExtra.t, leftType) {
      result := AST.createCommaExpression(left, AST.createIdentifier(self._("true")))
      return result.wrap()
    }

    left = createASTPropertyAccess(left, "type")
    return AST.createBinaryExpression(left, "==", right)
  }

  fn _generateMapExpression (mut self: ref Codegen, item: ref Parser.Expression) AST.CExpression? {
    if !item.isMap() {
      return nil
    }

    expression := item.asMap()
    targetType := Analyzer.contextTarget(item)
    mut arguments: (AST.CExpression | AST.CType)[] = [AST.createLiteral(expression.elements.len.str())]

    loop i := 0; i < expression.elements.len; i++ {
      element := expression.elements[i]
      arguments.push(self._generateExpression(ref element.key))
      arguments.push(self._generateExpression(ref element.value))
    }

    return AST.createCallExpression(AST.createIdentifier(self._type(targetType, "_alloc")), arguments)
  }

  fn _generateObjectExpression (mut self: ref Codegen, item: ref Parser.Expression) AST.CExpression? {
    if !item.isObject() {
      return nil
    }

    expression := item.asObject()
    targetType := Analyzer.contextTarget(item)

    mut fields: (AST.CExpression | AST.CType)[]

    loop i := 0; i < targetType.properties.len; i++ {
      property := targetType.properties[i]

      if property.builtin || property.t.isMethod() {
        continue
      }

      mut propertyValue: (ref Parser.Expression)?

      loop j := 0; j < expression.properties.len; j++ {
        expressionProperty := expression.properties[j]

        if expressionProperty.name.name == property.name {
          propertyValue = ref expressionProperty.value
          break
        }
      }

      fields.push(
        propertyValue == nil
          ? self._defaultInitializerDeclaration(property.t)
          : self._generateExpression(propertyValue)
      )
    }

    return AST.createCallExpression(AST.createIdentifier(self._type(targetType, "_alloc")), fields)
  }

  fn _generateParenthesizedExpression (mut self: ref Codegen, item: ref Parser.Expression) AST.CExpression? {
    if !item.isParenthesized() {
      return nil
    }

    expression := item.asParenthesized()
    result := self._generateExpression(ref expression.expression)
    return result.wrap()
  }

  fn _generatePropertyAccessExpression (mut self: ref Codegen, item: ref Parser.Expression) AST.CExpression? {
    if !item.isPropertyAccess() {
      return nil
    }

    expression := item.asPropertyAccess()

    return createASTPropertyAccess(
      self._generateExpression(ref expression.expression),
      expression.name.name,
    )
  }

  fn _generateReferenceExpression (mut self: ref Codegen, item: ref Parser.Expression) AST.CExpression? {
    if !item.isReference() {
      return nil
    }

    expression := item.asReference()
    return AST.createUnaryExpression("&", self._generateExpression(ref expression.expression))
  }

  fn _generateUnaryExpression (mut self: ref Codegen, item: ref Parser.Expression) AST.CExpression? {
    if !item.isUnary() {
      return nil
    }

    expression := item.asUnary()
    wrappedOperandType := Analyzer.contextTarget(ref expression.operand)
    operandType := Analyzer.unwrap(wrappedOperandType)
    mut operand := self._generateExpression(ref expression.operand)

    if wrappedOperandType.isReference() {
      operand = self._wrap(operand, ref expression.operand, wrappedOperandType, operandType)
    }

    if operandType.isFloat() {
      operand = AST.createCastExpression(AST.createType(self._("bool")), operand)
      operand = operand.wrap()
    }

    return AST.createUnaryExpression(
      expression.operator.val,
      operand,
      postfix: !expression.prefix,
    )
  }

  fn _generateBlockStatement (mut self: ref Codegen, item: ref Parser.Statement) AST.CStatement? {
    if !item.isBlock() {
      return nil
    }

    statement := item.asBlock()
    return AST.createCompoundStatement(self._generateBlock(ref statement.body))
  }

  fn _generateBreakStatement (mut self: ref Codegen, item: ref Parser.Statement) AST.CStatement? {
    if !item.isBreak() {
      return nil
    }

    statement := item.asBreak()

    if !self.blockData.hasUntil(.Loop) {
      return AST.createBreakStatement()
    }

    mut result := AST.createExpressionStatement(
      AST.createAssignmentExpression(
        AST.createIdentifier(self.blockData.getBreakVariable()),
        "=",
        AST.createLiteral("1"),
      )
    )

    if item.hasNext() {
      jumpStatement := AST.createGotoStatement(self.blockData.getLabel())
      result = AST.createCompoundStatement([result, jumpStatement])
    }

    return result
  }

  fn _generateContinueStatement (mut self: ref Codegen, item: ref Parser.Statement) AST.CStatement? {
    if !item.isContinue() {
      return nil
    }

    statement := item.asContinue()

    if !self.blockData.hasUntil(.Loop) {
      return AST.createContinueStatement()
    }

    mut result := AST.createExpressionStatement(
      AST.createAssignmentExpression(
        AST.createIdentifier(self.blockData.getContinueVariable()),
        "=",
        AST.createLiteral("1"),
      )
    )

    if item.hasNext() {
      jumpStatement := AST.createGotoStatement(self.blockData.getLabel())
      result = AST.createCompoundStatement([result, jumpStatement])
    }

    return result
  }

  fn _generateExpressionStatement (mut self: ref Codegen, item: ref Parser.Statement) AST.CStatement? {
    if !item.isExpression() {
      return nil
    }

    statement := item.asExpression()
    return AST.createExpressionStatement(self._generateExpression(ref statement.expression))
  }

  fn _generateFunctionDeclaration (mut self: ref Codegen, item: ref Parser.Statement) AST.CStatement? {
    if !item.isFunctionDeclaration() {
      return nil
    }

    statement := item.asFunctionDeclaration()

    if !(item.context is Analyzer.FunctionDeclarationContext) {
      throw error_NewError("Expected FunctionDeclaration context")
    }

    context := item.context as Analyzer.FunctionDeclarationContext

    if statement.body == nil {
      return nil
    }

    return self._defineFunction(
      statement.name,
      statement.parameters,
      statement.body as Parser.Statement,
      context.selfType,
    )
  }

  fn _generateIfStatement (mut self: ref Codegen, item: ref Parser.Statement) AST.CStatement? {
    if !item.isIf() {
      return nil
    }

    statement := item.asIf()
    condition := self._generateExpression(ref statement.condition)
    consequent := self._generateStatement(ref statement.consequent)
    mut alternate: AST.CStatement?

    if statement.alternate != nil {
      statementAlternate := statement.alternate
      alternate = self._generateStatement(ref statementAlternate)
    }

    return AST.createIfStatement(condition, consequent, alternate)
  }

  fn _generateLoopStatement (mut self: ref Codegen, item: ref Parser.Statement) AST.CStatement? {
    if !item.isLoop() {
      return nil
    }

    statement := item.asLoop()
    mut initializer: AST.CStatement?
    mut condition: AST.CExpression?
    mut update: AST.CExpression?
    bodyIsBlock := statement.body.isBlock()
    mut body: AST.CStatement[]

    self.blockData.increase()

    if statement.initializer != nil {
      initializerStatement := self._generateStatement(ref statement.initializer)

      if !self.blockData.currentEmpty() {
        self.blockData.addSetup(initializerStatement)
      } else {
        // TODO: problem on this line or when accessing initializer
        initializer = initializerStatement
      }
    }

    self.blockData.increase(.Loop)
    self.blockData.increaseVariableIndexes()

    if statement.condition != nil {
      self.blockData.increase()
      conditionExpression := self._generateExpression(ref statement.condition, transform: false)
      blockData := self.blockData.decrease()

      if !blockData.empty() {
        self.blockData.currentMerge(blockData.setup, blockData.teardown)

        body.push(
          AST.createIfStatement(
            AST.createUnaryExpression("!", conditionExpression.wrap()),
            AST.createCompoundStatement([
              AST.createExpressionStatement(
                AST.createAssignmentExpression(
                  AST.createIdentifier(self.blockData.getBreakVariable()),
                  "=",
                  AST.createLiteral("1"),
                ),
              ),
              AST.createGotoStatement(self.blockData.getLabel()),
            ]),
          ),
        )
      } else {
        condition = conditionExpression
      }
    }

    if statement.update != nil {
      self.blockData.increase()
      updateExpression := self._generateExpression(ref statement.update, transform: false)
      blockData := self.blockData.decrease()

      if !blockData.empty() {
        self.blockData.currentMerge(blockData.setup, blockData.teardown)
        self.blockData.addTeardown(AST.createExpressionStatement(updateExpression))
      } else {
        update = updateExpression
      }
    }

    mut bodyItems: Parser.Statement[]

    if bodyIsBlock {
      blockStatement := statement.body.asBlock()
      bodyItems.merge(blockStatement.body)
    } else {
      bodyItems.push(statement.body)
    }

    body.merge(self._generateBlockBody(ref bodyItems))
    self.blockData.decreaseVariableIndexes()
    blockDataLoop := self.blockData.decrease()
    optItem: (ref Parser.Statement)? = item // TODO: delete after v1
    body = self._generateBlockTail(body, optItem, ref blockDataLoop)

    if blockDataLoop.usedContinueVariable {
      body = [
        AST.createVariableDeclaration(
          AST.createType("unsigned char"),
          blockDataLoop.continueVariable(),
          AST.createLiteral("0"),
        )
      ].concat(body)
    }

    if blockDataLoop.usedBreakVariable {
      body = [
        AST.createVariableDeclaration(
          AST.createType("unsigned char"),
          blockDataLoop.breakVariable(),
          AST.createLiteral("0"),
        )
      ].concat(body)
    }

    statementBody := !bodyIsBlock && body.len == 1 ? body[0] : AST.createCompoundStatement(body)

    if initializer == nil && condition == nil && update == nil {
      condition = AST.createLiteral("1")
    }

    mut result := AST.createForStatement(initializer, condition, update, statementBody)

    if initializer == nil && condition != nil && update == nil {
      result = AST.createWhileStatement(condition, statementBody)
    }

    blockDataBlock := self.blockData.decrease()

    if !blockDataBlock.empty() {
      mut newStatementBody := blockDataBlock.setup
      newStatementBody.push(result)
      newStatementBody.merge(blockDataBlock.teardown)

      if blockDataBlock.usedReturnVariable {
        returnTypeName := self.returnType == nil ? "" : self.returnType.name

        newStatementBody.push(
          AST.createIfStatement(
            AST.createBinaryExpression(
              AST.createIdentifier(self.blockData.getReturnVariable()),
              "==",
              AST.createLiteral("1"),
            ),
            self.blockData.hasUntil(.Fn)
              ? AST.createGotoStatement(self.blockData.getLabel())
              : returnTypeName == "void"
                ? AST.createReturnStatement()
                : AST.createReturnStatement(AST.createIdentifier(self.blockData.getValueVariable())),
          ),
        )
      }

      result = AST.createCompoundStatement(newStatementBody)
    }

    return result
  }

  fn _generateReturnStatement (mut self: ref Codegen, item: ref Parser.Statement) AST.CStatement? {
    if !item.isReturn() {
      return nil
    }

    statement := item.asReturn()

    // TODO: implement
    // if (this->state.cleanUp.hasCleanUp(CODEGEN_CLEANUP_FN) || this->state.cleanUp.returnVarUsed) {
    //   auto parentNotRoot = this->state.cleanUp.parent != nullptr && this->state.cleanUp.parent->type != CODEGEN_CLEANUP_ROOT;
    //   if (parentNotRoot && this->state.cleanUp.hasCleanUp(CODEGEN_CLEANUP_FN)) {
    //     (*c)->append(
    //       CodegenASTExprAssign::create(
    //         CodegenASTExprAccess::create(this->state.cleanUp.currentReturnVar()),
    //         "=",
    //         CodegenASTExprLiteral::create("1")
    //       )->stmt()
    //     );
    //   }
    //   if (nodeReturn.body != std::nullopt) {
    //     (*c)->append(
    //       CodegenASTExprAssign::create(
    //         CodegenASTExprAccess::create(this->state.cleanUp.currentValueVar()),
    //         "=",
    //         this->_nodeExpr(*nodeReturn.body, this->state.returnType, node, c)
    //       )->stmt()
    //     );
    //   }
    //   auto nodeParentFunction = ASTChecker(node.parent).is<ASTNodeFnDecl>() || ASTChecker(node.parent).is<ASTNodeObjDecl>();
    //   auto nodeIsLast = node.parent != nullptr && ASTChecker(node).isLast(this->state.fnDeclBody);
    //   if ((!nodeParentFunction && this->state.cleanUp.empty()) || !nodeIsLast) {
    //     (*c)->append(CodegenASTStmtGoto::create(this->state.cleanUp.currentLabel()));
    //   }
    // } else if (nodeReturn.body != std::nullopt) {
    //   auto cArg = this->_nodeExpr(*nodeReturn.body, this->state.returnType, node, c);
    //   (*c)->append(CodegenASTStmtReturn::create(cArg));
    // } else {
    //   (*c)->append(
    //     ASTChecker(node).insideMain()
    //       ? CodegenASTStmtReturn::create(CodegenASTExprLiteral::create("0"))
    //       : CodegenASTStmtReturn::create()
    //   );
    // }

    return nil
  }

  fn _generateThrowStatement (mut self: ref Codegen, item: ref Parser.Statement) AST.CStatement? {
    if !item.isThrow() {
      return nil
    }

    statement := item.asThrow()

    // TODO: implement
    // auto argTypeInfo = this->_typeInfo(nodeThrow.arg.type);
    // auto cArg = this->_nodeExpr(nodeThrow.arg, argTypeInfo.type, node, c);
    // auto argNodeExprDef = this->_typeDef(argTypeInfo.type);
    // (*c)->append(
    //   CodegenASTExprCall::create(
    //     CodegenASTExprAccess::create(this->_("error_assign")),
    //     {
    //       this->_genErrState(ASTChecker(node).insideMain(), false),
    //       CodegenASTExprAccess::create(this->_(argNodeExprDef)),
    //       CodegenASTExprCast::create(CodegenASTType::create("void *"), cArg),
    //       CodegenASTExprCast::create(
    //         CodegenASTType::create("void (*) (void *)"),
    //         CodegenASTExprUnary::create("&", CodegenASTExprAccess::create(this->_(argTypeInfo.typeName + "_free")))
    //       ),
    //       CodegenASTExprLiteral::create(std::to_string(node.start.line)),
    //       CodegenASTExprLiteral::create(std::to_string(node.start.col + 1))
    //     }
    //   )->stmt()
    // );
    // (*c)->append(CodegenASTStmtGoto::create(this->state.cleanUp.currentLabel()));

    return nil
  }

  fn _generateTryStatement (mut self: ref Codegen, item: ref Parser.Statement) AST.CStatement? {
    if !item.isTry() {
      return nil
    }

    statement := item.asTry()

    // TODO: implement
    // auto nodeTry = std::get<ASTNodeTry>(*node.body);
    // auto initialStateCleanUp = this->state.cleanUp;
    // this->state.cleanUp = CodegenCleanUp(CODEGEN_CLEANUP_BLOCK, &initialStateCleanUp);

    // *c = (*c)->append(
    //   CodegenASTStmtSwitch::create(
    //     CodegenASTExprCall::create(
    //       CodegenASTExprAccess::create(this->_("setjmp")),
    //       {
    //         CodegenASTExprAccess::create(
    //           CodegenASTExprCall::create(
    //             CodegenASTExprAccess::create(this->_("error_buf_increase")),
    //             {this->_genErrState(ASTChecker(node).insideMain(), false)}
    //           ),
    //           "buf",
    //           true
    //         )
    //       }
    //     )
    //   )
    // );

    // *c = (*c)->append(
    //   CodegenASTStmtCase::create(CodegenASTExprLiteral::create("0"), CodegenASTStmtCompound::create())
    // );

    // this->varMap.save();

    // auto blockCleanUp = CodegenASTStmtCompound::create({
    //   CodegenASTStmtIf::create(
    //     CodegenASTExprBinary::create(
    //       this->_genErrState(ASTChecker(node).insideMain(), false, "id"),
    //       "!=",
    //       CodegenASTExprLiteral::create("-1")
    //     ),
    //     CodegenASTExprCall::create(
    //       CodegenASTExprAccess::create(this->_("longjmp")),
    //       {
    //         CodegenASTExprAccess::create(
    //           this->_genErrState(ASTChecker(node).insideMain(), false, "buf_last"),
    //           "buf",
    //           true
    //         ),
    //         this->_genErrState(ASTChecker(node).insideMain(), false, "id")
    //       }
    //     )->stmt()
    //   ),
    //   CodegenASTExprCall::create(
    //     CodegenASTExprAccess::create(this->_("error_buf_decrease")),
    //     {this->_genErrState(ASTChecker(node).insideMain(), false)}
    //   )->stmt()
    // });

    // this->_block(c, nodeTry.body, true, blockCleanUp, true);
    // (*c)->append(CodegenASTStmtBreak::create());
    // *c = (*c)->exit()->exit();
    // this->varMap.restore();
    // this->state.cleanUp = initialStateCleanUp;

    // for (const auto &handler : nodeTry.handlers) {
    //   auto handlerVarDecl = std::get<ASTNodeVarDecl>(*handler.param.body);
    //   auto handlerTypeInfo = this->_typeInfo(handlerVarDecl.var->type);
    //   auto handlerDef = this->_typeDef(handlerVarDecl.var->type);
    //   auto handleCodeName = Codegen::name(handlerVarDecl.var->codeName);

    //   *c = (*c)->append(
    //     CodegenASTStmtCase::create(
    //       CodegenASTExprAccess::create(this->_(handlerDef)),
    //       CodegenASTStmtCompound::create()
    //     )
    //   );

    //   (*c)->append(
    //     CodegenASTExprCall::create(
    //       CodegenASTExprAccess::create(this->_("error_buf_decrease")),
    //       {this->_genErrState(ASTChecker(node).insideMain(), false)}
    //     )->stmt()
    //   );

    //   (*c)->append(
    //     CodegenASTExprCall::create(
    //       CodegenASTExprAccess::create(this->_("error_unset")),
    //       {this->_genErrState(ASTChecker(node).insideMain(), false)}
    //     )->stmt()
    //   );

    //   (*c)->append(
    //     CodegenASTStmtVarDecl::create(
    //       CodegenASTType::create(handlerTypeInfo.typeCodeConst),
    //       CodegenASTExprAccess::create(handleCodeName),
    //       CodegenASTExprCast::create(
    //         CodegenASTType::create(handlerTypeInfo.typeCodeTrimmed),
    //         this->_genErrState(ASTChecker(node).insideMain(), false, "ctx")
    //       )
    //     )
    //   );

    //   this->varMap.save();

    //   this->_block(
    //     c,
    //     handler.body,
    //     true,
    //     this->_genFreeFn(handlerTypeInfo.type, CodegenASTExprAccess::create(handleCodeName))->stmt()
    //   );

    //   (*c)->append(CodegenASTStmtBreak::create());
    //   *c = (*c)->exit()->exit();
    //   this->varMap.restore();
    // }

    // *c = (*c)->append(CodegenASTStmtCase::create(nullptr, CodegenASTStmtCompound::create()));

    // (*c)->append(
    //   CodegenASTExprCall::create(
    //     CodegenASTExprAccess::create(this->_("error_buf_decrease")),
    //     {this->_genErrState(ASTChecker(node).insideMain(), false)}
    //   )->stmt()
    // );

    // (*c)->append(CodegenASTStmtGoto::create(this->state.cleanUp.currentLabel()));
    // *c = (*c)->exit()->exit()->exit();

    return nil
  }

  fn _generateVariableDeclaration (mut self: ref Codegen, item: ref Parser.Statement) AST.CStatement? {
    if !item.isVariableDeclaration() {
      return nil
    }

    statement := item.asVariableDeclaration()

    if !(item.context is Analyzer.VariableDeclarationContext) {
      throw error_NewError("Expected VariableDeclaration context")
    }

    context := item.context as Analyzer.VariableDeclarationContext

    mut initializer := statement.initializer == nil
      ? self._defaultInitializerDeclaration(context.varType)
      : self._generateExpression(ref statement.initializer, transform: false)

    variableName := self.blockData.setVariable(statement.name.name)

    if statement.initializer != nil {
      statementInitializer := statement.initializer

      if typeShouldBeAllocated(context.varType) && expressionShouldBeCopied(ref statementInitializer) {
        initializer = self._functionCopy(context.varType, initializer)
      }
    }

    if typeShouldBeFreed(context.varType) {
      self.blockData.addTeardown(
        AST.createExpressionStatement(
          self._functionFree(context.varType, AST.createIdentifier(variableName)),
        ),
      )
    }

    cType := AST.createType(self._type(context.varType))

    if statementHasPrecedingNonDeclaration(item) {
      self.blockData.addSetup(
        AST.createVariableDeclaration(cType, variableName),
      )

      return AST.createExpressionStatement(
        AST.createAssignmentExpression(AST.createIdentifier(variableName), "=", initializer),
      )
    } else {
      return AST.createVariableDeclaration(cType, variableName, initializer)
    }
  }

  fn _generateAnyType (mut self: ref Codegen, item: ref Analyzer.Type) str {
    typeName := "d4_any_" + self._typeName(item)
    name := typeName + "_t"

    if self._hasEntity(name) {
      return name
    }

    self._typeGen(item)

    self.entities.push(CodegenEntity{
      name: name,
      codeName: name,
      context: item,
      generate: (mut self: ref Codegen, entity: ref CodegenEntity) -> GenerateReturnType {
        it := entity.context as ref Analyzer.Type
        t := self._type(it)
        typeDef := self._typeDef(it)
        typeName := self._typeName(it)

        return [
          AST.createExpressionStatement(AST.createMacroInvocation(self._("D4_ANY_DECLARE"), [
            AST.createIdentifier(typeName),
            AST.createType(t),
          ]), terminated: false),
          AST.createExpressionStatement(AST.createMacroInvocation(self._("D4_ANY_DEFINE"), [
            AST.createIdentifier(self._(typeDef)),
            AST.createIdentifier(typeName),
            AST.createType(self._type(it)),
            self._functionCopy(it, AST.createIdentifier("val")),
            self._functionEq(it, AST.createIdentifier("lhs_val"), AST.createIdentifier("rhs_val")),
            self._functionFree(it, AST.createIdentifier("val")),
            self._functionStr(it, AST.createIdentifier("val")),
          ]), terminated: false),
        ]
      }
    })

    methods := ["alloc", "copy", "eq", "free", "str"]

    entityCallee := (mut self: ref Codegen, entity: ref CodegenEntity) -> GenerateReturnType {
      self._(entity.context as str)
      return AST.createEmptyStatement()
    }

    loop i := 0; i < methods.len; i++ {
      methodName := methods[i] as str

      self.entities.push(CodegenEntity{
        name: typeName + "_" + methodName,
        codeName: typeName + "_" + methodName,
        context: name,
        generate: entityCallee,
      })
    }

    return name
  }

  fn _generateArrayType (mut self: ref Codegen, item: ref Analyzer.Type) str {
    typeName := "d4_" + self._typeName(item)
    name := typeName + "_t"

    if self._hasEntity(name) {
      return name
    }

    itemType := item.asArray()
    self._typeGen(itemType.elementType)

    self.entities.push(CodegenEntity{
      name: name,
      codeName: name,
      context: item,
      generate: (mut self: ref Codegen, entity: ref CodegenEntity) -> GenerateReturnType {
        it := entity.context as ref Analyzer.Type
        t := it.asArray()
        elementTypeName := self._typeName(t.elementType)

        return [
          AST.createExpressionStatement(AST.createMacroInvocation(self._("D4_ARRAY_DECLARE"), [
            AST.createIdentifier(elementTypeName),
            AST.createType(self._type(t.elementType)),
          ]), terminated: false),
          AST.createExpressionStatement(AST.createMacroInvocation(self._("D4_ARRAY_DEFINE"), [
            AST.createIdentifier(elementTypeName),
            AST.createType(self._type(t.elementType)),
            AST.createType(self._type(typeSafeForVaArg(self._tm(), t.elementType))),
            self._functionCopy(t.elementType, AST.createIdentifier("element")),
            self._functionEq(t.elementType, AST.createIdentifier("lhs_element"), AST.createIdentifier("rhs_element")),
            self._functionFree(t.elementType, AST.createIdentifier("element")),
            self._functionStr(t.elementType, AST.createIdentifier("element"), quote: true),
          ]), terminated: false),
        ]
      }
    })

    methods := [
      "alloc",
      "at",
      "clear",
      "concat",
      "contains",
      "copy",
      "empty",
      "eq",
      "filter",
      "first",
      "forEach",
      "free",
      "join",
      "last",
      "merge",
      "pop",
      "push",
      "realloc",
      "remove",
      "reverse",
      "slice",
      "sort",
      "str"
    ]

    entityCallee := (mut self: ref Codegen, entity: ref CodegenEntity) -> GenerateReturnType {
      self._(entity.context as str)
      return AST.createEmptyStatement()
    }

    loop i := 0; i < methods.len; i++ {
      methodName := methods[i] as str

      self.entities.push(CodegenEntity{
        name: typeName + "_" + methodName,
        codeName: typeName + "_" + methodName,
        context: name,
        generate: entityCallee,
      })
    }

    return name
  }

  fn _generateFunctionType (mut self: ref Codegen, item: ref Analyzer.Type) str {
    typeName := "d4_" + self._typeName(item)
    name := typeName + "_t"

    if self._hasEntity(name) {
      return name
    }

    itemType := item.asFunction()
    hasParams := !itemType.parameters.empty
    self._typeGen(itemType.returnType)

    if hasParams {
      loop i := 0; i < itemType.parameters.len; i++ {
        self._typeGen(itemType.parameters[i].t)
      }

      self.entities.push(CodegenEntity{
        name: name,
        codeName: name,
        context: item,
        generate: (mut self: ref Codegen, entity: ref CodegenEntity) -> GenerateReturnType {
          it := entity.context as ref Analyzer.Type
          t := it.asFunction()
          returnType := self._type(t.returnType)
          returnTypeName := self._typeName(t.returnType)
          mut parametersTypeName := ""
          mut parametersDefinition: AST.CStatement[]

          loop i := 0; i < t.parameters.len; i++ {
            parameter := t.parameters[i]
            parametersTypeName += typeParameterId(parameter) + self._typeName(parameter.t)

            if !parameter.required && !parameter.variadic {
              parametersDefinition.push(AST.createStructureMemberDeclaration(
                AST.createType("unsigned char"),
                "o" + i.str(),
              ))
            }

            parametersDefinition.push(AST.createStructureMemberDeclaration(
              AST.createType(self._type(parameter.t)),
              "n" + i.str(),
            ))
          }

          return [
            AST.createExpressionStatement(AST.createMacroInvocation(self._("D4_FUNCTION_DECLARE_WITH_PARAMS"), [
              AST.createIdentifier(t.asynchronous ? "a" : "s"),
              AST.createIdentifier(returnTypeName),
              AST.createType(returnType),
              AST.createIdentifier(parametersTypeName),
              AST.createCompoundStatement(parametersDefinition),
            ]), terminated: false),
            AST.createExpressionStatement(AST.createMacroInvocation(self._("D4_FUNCTION_DEFINE_WITH_PARAMS"), [
              AST.createIdentifier(t.asynchronous ? "a" : "s"),
              AST.createIdentifier(returnTypeName),
              AST.createType(returnType),
              AST.createIdentifier(parametersTypeName),
            ]), terminated: false),
          ]
        }
      })
    } else {
      self.entities.push(CodegenEntity{
        name: name,
        codeName: name,
        context: item,
        generate: (mut self: ref Codegen, entity: ref CodegenEntity) -> GenerateReturnType {
          it := entity.context as ref Analyzer.Type
          t := it.asFunction()
          returnType := self._type(t.returnType)
          returnTypeName := self._typeName(t.returnType)

          return [
            AST.createExpressionStatement(AST.createMacroInvocation(self._("D4_FUNCTION_DECLARE"), [
              AST.createIdentifier(t.asynchronous ? "a" : "s"),
              AST.createIdentifier(returnTypeName),
              AST.createType(returnType),
            ]), terminated: false),
            AST.createExpressionStatement(AST.createMacroInvocation(self._("D4_FUNCTION_DEFINE"), [
              AST.createIdentifier(t.asynchronous ? "a" : "s"),
              AST.createIdentifier(returnTypeName),
              AST.createType(returnType),
            ]), terminated: false),
          ]
        }
      })
    }

    methods := ["alloc", "copy", "eq", "free", "realloc", "str"]

    entityCallee := (mut self: ref Codegen, entity: ref CodegenEntity) -> GenerateReturnType {
      self._(entity.context as str)
      return AST.createEmptyStatement()
    }

    loop i := 0; i < methods.len; i++ {
      methodName := methods[i] as str

      self.entities.push(CodegenEntity{
        name: typeName + "_" + methodName,
        codeName: typeName + "_" + methodName,
        context: name,
        generate: entityCallee,
      })
    }

    if hasParams {
      self.entities.push(CodegenEntity{
        name: typeName + "_params_t",
        codeName: typeName + "_params_t",
        context: name,
        generate: entityCallee
      })
    }

    return name
  }

  fn _generateMapType (mut self: ref Codegen, item: ref Analyzer.Type) str {
    typeName := "d4_" + self._typeName(item)
    name := typeName + "_t"

    if self._hasEntity(name) {
      return name
    }

    itemType := item.asMap()
    tm := self._tm()

    self._typeGen(itemType.keyType)
    self._typeGen(itemType.valueType)
    self._typeGen(tm.createArray(itemType.keyType))
    self._typeGen(tm.createArray(itemType.valueType))

    self.entities.push(CodegenEntity{
      name: name,
      codeName: name,
      context: item,
      generate: (mut self: ref Codegen, entity: ref CodegenEntity) -> GenerateReturnType {
        it := entity.context as ref Analyzer.Type
        t := it.asMap()
        tm := self._tm()

        self._type(tm.createArray(t.keyType))
        self._type(tm.createArray(t.valueType))

        keyType := self._type(t.keyType)
        valueType := self._type(t.valueType)

        keyTypeName := self._typeName(t.keyType)
        valueTypeName := self._typeName(t.valueType)

        return [
          AST.createExpressionStatement(AST.createMacroInvocation(self._("D4_MAP_DECLARE"), [
            AST.createIdentifier(keyTypeName),
            AST.createType(keyType),
            AST.createIdentifier(valueTypeName),
            AST.createType(valueType),
          ]), terminated: false),
          AST.createExpressionStatement(AST.createMacroInvocation(self._("D4_MAP_DEFINE"), [
            AST.createIdentifier(keyTypeName),
            AST.createType(keyType),
            AST.createType(self._type(typeSafeForVaArg(tm, t.keyType))),
            self._functionCopy(t.keyType, AST.createIdentifier("key")),
            self._functionEq(t.keyType, AST.createIdentifier("lhs_key"), AST.createIdentifier("rhs_key")),
            self._functionFree(t.keyType, AST.createIdentifier("key")),
            self._functionStr(t.keyType, AST.createIdentifier("key")),
            self._functionStr(t.keyType, AST.createIdentifier("key"), quote: true),
            AST.createIdentifier(valueTypeName),
            AST.createType(valueType),
            AST.createType(self._type(typeSafeForVaArg(tm, t.valueType))),
            self._functionCopy(t.valueType, AST.createIdentifier("val")),
            self._functionEq(t.valueType, AST.createIdentifier("lhs_val"), AST.createIdentifier("rhs_val")),
            self._functionFree(t.valueType, AST.createIdentifier("val")),
            self._functionStr(t.valueType, AST.createIdentifier("val"), quote: true),
          ]), terminated: false),
        ]
      }
    })

    methods := [
      "alloc",
      "clear",
      "copy",
      "empty",
      "eq",
      "free",
      "get",
      "has",
      "keys",
      "merge",
      "realloc",
      "remove",
      "reserve",
      "set",
      "shrink",
      "str",
      "values"
    ]

    entityCallee := (mut self: ref Codegen, entity: ref CodegenEntity) -> GenerateReturnType {
      self._(entity.context as str)
      return AST.createEmptyStatement()
    }

    loop i := 0; i < methods.len; i++ {
      methodName := methods[i] as str

      self.entities.push(CodegenEntity{
        name: typeName + "_" + methodName,
        codeName: typeName + "_" + methodName,
        context: name,
        generate: entityCallee,
      })
    }

    return name
  }

  fn _generateObjectType (mut self: ref Codegen, item: ref Analyzer.Type) str {
    typeName := "d4_" + self._typeName(item)
    name := typeName + "_t"

    if self._hasEntity(name) {
      return name
    }

    self.entities.push(CodegenEntity{
      name: name,
      codeName: name,
      context: item,
      generate: (mut self: ref Codegen, entity: ref CodegenEntity) -> GenerateReturnType {
        return AST.createEmptyStatement()
      }
    })

    loop i := 0; i < item.properties.len; i++ {
      property := item.properties[i]

      if property.builtin || property.t.isMethod() {
        continue
      }

      self._typeGen(property.t)
    }

    self._removeEntity(name)

    self.entities.push(CodegenEntity{
      name: name,
      codeName: name,
      context: item,
      generate: (mut self: ref Codegen, entity: ref CodegenEntity) -> GenerateReturnType {
        it := entity.context as ref Analyzer.Type

        mut extraDeclarationArguments: (AST.CExpression | AST.CStatement | AST.CType)[]
        mut structureBlock: AST.CStatement[]
        mut allocBlock: AST.CStatement[]
        mut copyBlock: AST.CStatement[]
        mut eqExpression := AST.createIdentifier(self._("true"))
        mut freeBlock: AST.CStatement[]
        mut strBlock: AST.CStatement[]
        mut propertyIdx := 0

        loop i := 0; i < it.properties.len; i++ {
          property := it.properties[i]

          if property.builtin || property.t.isMethod() {
            continue
          }

          cPropertyType := self._type(property.t)
          cSelfProperty := AST.createPropertyAccessExpression(AST.createIdentifier("self"), property.name)

          extraDeclarationArguments.push(
            AST.createVariableDeclaration(
              AST.createType(cPropertyType, constant: true),
              property.name,
              terminated: false,
            )
          )

          structureBlock.push(
            AST.createVariableDeclaration(AST.createType(cPropertyType), property.name)
          )

          allocBlock.push(
            AST.createExpressionStatement(
              AST.createAssignmentExpression(
                cSelfProperty,
                "=",
                self._functionCopy(property.t, AST.createIdentifier(property.name)),
              ),
            ),
          )

          copyBlock.push(
            AST.createExpressionStatement(
              AST.createAssignmentExpression(
                AST.createPropertyAccessExpression(AST.createIdentifier("result"), property.name),
                "=",
                self._functionCopy(property.t, cSelfProperty),
              ),
            ),
          )

          eqExpressionPiece := self._functionEq(
            property.t,
            cSelfProperty,
            AST.createPropertyAccessExpression(AST.createIdentifier("rhs"), property.name),
          )

          eqExpression = propertyIdx == 0
            ? eqExpressionPiece
            : AST.createBinaryExpression(eqExpression, "&&", eqExpressionPiece)

          if typeShouldBeFreed(property.t) {
            freeBlock.push(
              AST.createExpressionStatement(
                self._functionFree(property.t, cSelfProperty),
              ),
            )
          }

          strBlock.push(
            AST.createExpressionStatement(
              AST.createAssignmentExpression(
                AST.createIdentifier("result"),
                "=",
                AST.createCallExpression(AST.createIdentifier(self._("d4_obj_str_append")), [
                  AST.createIdentifier("result"),
                  AST.createCallExpression(AST.createIdentifier(self._("d4_str_alloc")), [
                    AST.createLiteral("L\"" + property.name + "\""),
                  ]),
                  self._functionStr(property.t, cSelfProperty, quote: true),
                ]),
              ),
            ),
          )

          propertyIdx++
        }

        if freeBlock.empty {
          freeBlock.push(
            AST.createExpressionStatement(
              AST.createCastExpression(AST.createType("void"), AST.createIdentifier("self")),
            ),
          )
        }

        mut eqBlock: AST.CStatement[]

        if propertyIdx == 0 {
          extraDeclarationArguments.push(AST.createType("void"))

          structureBlock.push(
            AST.createVariableDeclaration(AST.createType(self._("bool")), "_")
          )

          allocBlock.push(
            AST.createExpressionStatement(
              AST.createAssignmentExpression(
                AST.createPropertyAccessExpression(AST.createIdentifier("self"), "_"),
                "=",
                AST.createIdentifier(self._("false")),
              ),
            ),
          )

          copyBlock.push(
            AST.createExpressionStatement(
              AST.createAssignmentExpression(
                AST.createPropertyAccessExpression(AST.createIdentifier("result"), "_"),
                "=",
                AST.createPropertyAccessExpression(AST.createIdentifier("self"), "_"),
              ),
            ),
          )

          eqBlock.push(
            AST.createExpressionStatement(
              AST.createCastExpression(AST.createType("void"), AST.createIdentifier("self")),
            ),
          )

          eqBlock.push(
            AST.createExpressionStatement(
              AST.createCastExpression(AST.createType("void"), AST.createIdentifier("rhs")),
            ),
          )

          strBlock.push(
            AST.createExpressionStatement(
              AST.createCastExpression(AST.createType("void"), AST.createIdentifier("self")),
            ),
          )
        }

        eqBlock.push(AST.createReturnStatement(eqExpression))

        cNameIdentifier := AST.createIdentifier(it.name)

        forwardDeclarationArguments: (AST.CExpression | AST.CStatement | AST.CType)[] = [
          cNameIdentifier,
        ]

        mut declarationArguments: (AST.CExpression | AST.CStatement | AST.CType)[] = [
          cNameIdentifier,
          AST.createCompoundStatement(structureBlock),
        ]

        mut definitionArguments: (AST.CExpression | AST.CStatement | AST.CType)[] = [
          cNameIdentifier,
          cNameIdentifier,
          AST.createCompoundStatement(allocBlock),
          AST.createCompoundStatement(copyBlock),
          AST.createCompoundStatement(eqBlock),
          AST.createCompoundStatement(freeBlock),
          AST.createCompoundStatement(strBlock),
        ]

        declarationArguments.merge(extraDeclarationArguments)
        definitionArguments.merge(extraDeclarationArguments)

        return [
          AST.createExpressionStatement(
            AST.createMacroInvocation(self._("D4_OBJECT_FORWARD_DECLARE"), forwardDeclarationArguments),
            terminated: false,
          ),
          AST.createExpressionStatement(
            AST.createMacroInvocation(self._("D4_OBJECT_DECLARE"), declarationArguments),
            terminated: false,
          ),
          AST.createExpressionStatement(
            AST.createMacroInvocation(self._("D4_OBJECT_DEFINE"), definitionArguments),
            terminated: false,
          ),
        ]
      }
    })

    methods := ["alloc", "copy", "eq", "free", "realloc", "str"]

    entityCallee := (mut self: ref Codegen, entity: ref CodegenEntity) -> GenerateReturnType {
      self._(entity.context as str)
      return AST.createEmptyStatement()
    }

    loop i := 0; i < methods.len; i++ {
      methodName := methods[i] as str

      self.entities.push(CodegenEntity{
        name: typeName + "_" + methodName,
        codeName: typeName + "_" + methodName,
        context: name,
        generate: entityCallee,
      })
    }

    return name
  }

  fn _generateOptionalType (mut self: ref Codegen, item: ref Analyzer.Type) str {
    typeName := "d4_" + self._typeName(item)
    name := typeName + "_t"

    if self._hasEntity(name) {
      return name
    }

    itemType := item.asOptional()
    self._typeGen(itemType.t)

    self.entities.push(CodegenEntity{
      name: name,
      codeName: name,
      context: item,
      generate: (mut self: ref Codegen, entity: ref CodegenEntity) -> GenerateReturnType {
        it := entity.context as ref Analyzer.Type
        t := it.asOptional()
        underlyingType := self._type(t.t)
        underlyingTypeName := self._typeName(t.t)

        return [
          AST.createExpressionStatement(AST.createMacroInvocation(self._("D4_OPTIONAL_DECLARE"), [
            AST.createIdentifier(underlyingTypeName),
            AST.createType(underlyingType),
          ]), terminated: false),
          AST.createExpressionStatement(AST.createMacroInvocation(self._("D4_OPTIONAL_DEFINE"), [
            AST.createIdentifier(underlyingTypeName),
            AST.createType(underlyingType),
            self._functionCopy(t.t, AST.createIdentifier("val")),
            self._functionEq(t.t, AST.createIdentifier("lhs_val"), AST.createIdentifier("rhs_val")),
            self._functionFree(t.t, AST.createIdentifier("val")),
            self._functionStr(t.t, AST.createIdentifier("val")),
          ]), terminated: false),
        ]
      }
    })

    methods := ["alloc", "copy", "eq", "free", "realloc", "str"]

    entityCallee := (mut self: ref Codegen, entity: ref CodegenEntity) -> GenerateReturnType {
      self._(entity.context as str)
      return AST.createEmptyStatement()
    }

    loop i := 0; i < methods.len; i++ {
      methodName := methods[i] as str

      self.entities.push(CodegenEntity{
        name: typeName + "_" + methodName,
        codeName: typeName + "_" + methodName,
        context: name,
        generate: entityCallee,
      })
    }

    return name
  }

  fn _generateReferenceType (mut self: ref Codegen, item: ref Analyzer.Type) str {
    typeName := "d4_" + self._typeName(item)
    name := typeName + "_t"

    if self._hasEntity(name) {
      return name
    }

    itemType := item.asReference()
    self._typeGen(itemType.t)

    self.entities.push(CodegenEntity{
      name: name,
      codeName: name,
      context: item,
      generate: (mut self: ref Codegen, entity: ref CodegenEntity) -> GenerateReturnType {
        it := entity.context as ref Analyzer.Type
        t := it.asReference()

        return AST.createExpressionStatement(AST.createMacroInvocation(self._("D4_REFERENCE_DECLARE"), [
          AST.createIdentifier(self._typeName(t.t)),
          AST.createType(self._type(t.t)),
        ]), terminated: false)
      }
    })

    return name
  }

  fn _generateUnionType (mut self: ref Codegen, item: ref Analyzer.Type) str {
    typeName := "d4_" + self._typeName(item)
    name := typeName + "_t"

    if self._hasEntity(name) {
      return name
    }

    itemType := item.asUnion()
    subtypesLen := itemType.types.len

    loop i := 0; i < subtypesLen; i++ {
      subtype := itemType.types[i] as ref Analyzer.Type
      self._typeGen(subtype)
    }

    self.entities.push(CodegenEntity{
      name: name,
      codeName: name,
      context: item,
      generate: (mut self: ref Codegen, entity: ref CodegenEntity) -> GenerateReturnType {
        it := entity.context as ref Analyzer.Type
        t := it.asUnion()
        unionName := entity.codeName.slice("d4_union_".len, "UE_t".len * -1)

        mut structureBlock: AST.CStatement[]
        mut allocBlock: AST.CStatement[]
        mut copyBlock: AST.CStatement[]
        mut eqBlock: AST.CStatement[]
        mut freeBlock: AST.CStatement[]
        mut strBlock: AST.CStatement[]

        loop i := 0; i < t.types.len; i++ {
          subType := t.types[i] as ref Analyzer.Type
          typeDecl := self._type(subType)
          typeDef := self._typeDef(subType)
          typeDefIdx := self.typeDefs.get(typeDef)
          typeProperty := "v" + typeDefIdx.str()

          structureBlock.push(
            AST.createVariableDeclaration(AST.createType(typeDecl), typeProperty),
          )

          allocBlock.push(
            AST.createIfStatement(
              AST.createBinaryExpression(
                AST.createPropertyAccessExpression(AST.createIdentifier("self"), "type"),
                "==",
                AST.createIdentifier(self._(typeDef)),
              ),
              AST.createExpressionStatement(
                AST.createAssignmentExpression(
                  AST.createPropertyAccessExpression(
                    AST.createPropertyAccessExpression(
                      AST.createIdentifier("self"),
                      "data",
                    ),
                    typeProperty,
                  ),
                  "=",
                  self._functionCopy(
                    subType,
                    AST.createCallExpression(AST.createIdentifier(self._("va_arg")), [
                      AST.createIdentifier("args"),
                      AST.createType(typeDecl),
                    ]),
                  ),
                ),
              ),
            ),
          )

          copyBlock.push(
            AST.createIfStatement(
              AST.createBinaryExpression(
                AST.createPropertyAccessExpression(AST.createIdentifier("self"), "type"),
                "==",
                AST.createIdentifier(self._(typeDef)),
              ),
              AST.createExpressionStatement(
                AST.createAssignmentExpression(
                  AST.createPropertyAccessExpression(
                    AST.createPropertyAccessExpression(AST.createIdentifier("result"), "data"),
                    typeProperty,
                  ),
                  "=",
                  self._functionCopy(
                    subType,
                    AST.createPropertyAccessExpression(
                      AST.createPropertyAccessExpression(AST.createIdentifier("self"), "data"),
                      typeProperty,
                    ),
                  ),
                ),
              ),
            ),
          )

          eqBlock.push(
            AST.createIfStatement(
              AST.createBinaryExpression(
                AST.createPropertyAccessExpression(AST.createIdentifier("self"), "type"),
                "==",
                AST.createIdentifier(self._(typeDef)),
              ),
              AST.createReturnStatement(
                self._functionEq(
                  subType,
                  AST.createPropertyAccessExpression(
                    AST.createPropertyAccessExpression(AST.createIdentifier("self"), "data"),
                    typeProperty,
                  ),
                  AST.createPropertyAccessExpression(
                    AST.createPropertyAccessExpression(AST.createIdentifier("rhs"), "data"),
                    typeProperty,
                  ),
                ),
              ),
            ),
          )

          if typeShouldBeFreed(subType) {
            freeBlock.push(
              AST.createIfStatement(
                AST.createBinaryExpression(
                  AST.createPropertyAccessExpression(AST.createIdentifier("self"), "type"),
                  "==",
                  AST.createIdentifier(self._(typeDef)),
                ),
                AST.createExpressionStatement(
                  self._functionFree(
                    subType,
                    AST.createPropertyAccessExpression(
                      AST.createPropertyAccessExpression(AST.createIdentifier("self"), "data"),
                      typeProperty,
                    ),
                  ),
                ),
              ),
            )
          }

          strBlock.push(
            AST.createIfStatement(
              AST.createBinaryExpression(
                AST.createPropertyAccessExpression(AST.createIdentifier("self"), "type"),
                "==",
                AST.createIdentifier(self._(typeDef)),
              ),
              AST.createReturnStatement(
                self._functionStr(
                  subType,
                  AST.createPropertyAccessExpression(
                    AST.createPropertyAccessExpression(AST.createIdentifier("self"), "data"),
                    typeProperty,
                  ),
                ),
              ),
            ),
          )
        }

        if freeBlock.empty {
          freeBlock.push(
            AST.createExpressionStatement(
              AST.createCastExpression(AST.createType("void"), AST.createIdentifier("self")),
            ),
          )
        }

        return [
          AST.createExpressionStatement(AST.createMacroInvocation(self._("D4_UNION_DECLARE"), [
            AST.createIdentifier(unionName),
            AST.createCompoundStatement(structureBlock),
          ]), terminated: false),
          AST.createExpressionStatement(AST.createMacroInvocation(self._("D4_UNION_DEFINE"), [
            AST.createIdentifier(unionName),
            AST.createCompoundStatement(allocBlock),
            AST.createCompoundStatement(copyBlock),
            AST.createCompoundStatement(eqBlock),
            AST.createCompoundStatement(freeBlock),
            AST.createCompoundStatement(strBlock),
          ]), terminated: false),
        ]
      }
    })

    methods := ["alloc", "copy", "eq", "free", "realloc", "str"]

    entityCallee := (mut self: ref Codegen, entity: ref CodegenEntity) -> GenerateReturnType {
      self._(entity.context as str)
      return AST.createEmptyStatement()
    }

    loop i := 0; i < methods.len; i++ {
      methodName := methods[i] as str

      self.entities.push(CodegenEntity{
        name: typeName + "_" + methodName,
        codeName: typeName + "_" + methodName,
        context: name,
        generate: entityCallee,
      })
    }

    return name
  }

  fn _getEntity (self: ref Self, name: str) ref CodegenEntity {
    loop i := self.entities.len - 1; i >= 0; i-- {
      entity := self.entities[i]

      if entity.name == name {
        return entity
      }
    }

    throw error_NewError("Entity with name '" + name + "' doesn't exists")
  }

  fn _hasEntity (self: ref Self, name: str, withBuiltin := true) bool {
    loop i := self.entities.len - 1; i >= 0; i-- {
      entity := self.entities[i]

      if entity.name == name {
        return true
      }
    }

    if withBuiltin {
      builtinEntitiesValues := BUILTIN_ENTITIES.values

      loop i := builtinEntitiesValues.len - 1; i >= 0; i-- {
        entityValues := builtinEntitiesValues[i]

        if entityValues.contains(name) {
          return true
        }
      }
    }

    return false
  }

  fn _r (mut self: ref Self) ref Parser.Reader {
    mut file := self.analyzer.files.last()
    return ref file.reader
  }

  fn _removeEntity (mut self: ref Self, name: str) void {
    loop i := self.entities.len - 1; i >= 0; i-- {
      entity := self.entities[i]

      if entity.name == name {
        self.entities.remove(i)
        return
      }
    }

    throw error_NewError("Entity '" + name + "' can't be removed")
  }

  fn _str (mut self: ref Self, content: str) AST.CExpression {
    escapedContent := content.replace("\\", "\\\\").replace("\"", "\\\"")

    return AST.createCastExpression(
      AST.createType(self._("d4_str_t")),
      AST.createInitializerListExpression([
        AST.createLiteral("L\"" + escapedContent + "\""),
        AST.createLiteral(escapedContent.len.str()),
        AST.createIdentifier(self._("true")),
      ]),
    )
  }

  fn _tm (mut self: ref Self) ref Analyzer.TypeMap {
    mut file := self.analyzer.files.last()
    return ref file.tm
  }

  fn _tmpVar (mut self: ref Self) str {
    self.lastVarId++
    return "__THE_" + self.lastVarId.str()
  }

  fn _type (mut self: ref Self, it: ref Analyzer.Type, postfix := "_t") str {
    if it.isAlias() {
      t := it.asAlias()
      return self._type(t.t)
    } elif it.name == "any" {
      return self._("d4_any" + postfix) + (postfix.slice(-3) == "_t" ? " " : "")
    } elif it.name == "bool" {
      if postfix == "_t" {
        return self._("bool") + " "
      } else {
        return self._("d4_bool" + postfix) + (postfix.slice(-3) == "_t" ? " " : "")
      }
    } elif it.name == "byte" {
      if postfix == "_t" {
        return "unsigned char "
      } else {
        return self._("d4_byte" + postfix) + (postfix.slice(-3) == "_t" ? " " : "")
      }
    } elif it.name == "char" {
      if postfix == "_t" {
        return "char "
      } else {
        return self._("d4_char" + postfix) + (postfix.slice(-3) == "_t" ? " " : "")
      }
    } elif it.name == "f32" {
      if postfix == "_t" {
        return "float "
      } else {
        return self._("d4_f32" + postfix) + (postfix.slice(-3) == "_t" ? " " : "")
      }
    } elif it.name == "f64" {
      if postfix == "_t" {
        return "double "
      } else {
        return self._("d4_f64" + postfix) + (postfix.slice(-3) == "_t" ? " " : "")
      }
    } elif it.name == "float" {
      if postfix == "_t" {
        return "double "
      } else {
        return self._("d4_float" + postfix) + (postfix.slice(-3) == "_t" ? " " : "")
      }
    } elif it.name == "i8" {
      if postfix == "_t" {
        return self._("int8_t") + " "
      } else {
        return self._("d4_i8" + postfix) + (postfix.slice(-3) == "_t" ? " " : "")
      }
    } elif it.name == "i16" {
      if postfix == "_t" {
        return self._("int16_t") + " "
      } else {
        return self._("d4_i16" + postfix) + (postfix.slice(-3) == "_t" ? " " : "")
      }
    } elif it.name == "i32" {
      if postfix == "_t" {
        return self._("int32_t") + " "
      } else {
        return self._("d4_i32" + postfix) + (postfix.slice(-3) == "_t" ? " " : "")
      }
    } elif it.name == "int" {
      if postfix == "_t" {
        return self._("int32_t") + " "
      } else {
        return self._("d4_int" + postfix) + (postfix.slice(-3) == "_t" ? " " : "")
      }
    } elif it.name == "i64" {
      if postfix == "_t" {
        return self._("int64_t") + " "
      } else {
        return self._("d4_i64" + postfix) + (postfix.slice(-3) == "_t" ? " " : "")
      }
    } elif it.name == "isize" {
      if postfix == "_t" {
        return self._("ptrdiff_t") + " "
      } else {
        return self._("d4_isize" + postfix) + (postfix.slice(-3) == "_t" ? " " : "")
      }
    } elif it.name == "rune" {
      if postfix == "_t" {
        return self._("wchar_t") + " "
      } else {
        return self._("d4_rune" + postfix) + (postfix.slice(-3) == "_t" ? " " : "")
      }
    } elif it.name == "str" {
      return self._("d4_str" + postfix) + (postfix.slice(-3) == "_t" ? " " : "")
    } elif it.name == "u8" {
      if postfix == "_t" {
        return self._("uint8_t") + " "
      } else {
        return self._("d4_u8" + postfix) + (postfix.slice(-3) == "_t" ? " " : "")
      }
    } elif it.name == "u16" {
      if postfix == "_t" {
        return self._("uint16_t") + " "
      } else {
        return self._("d4_u16" + postfix) + (postfix.slice(-3) == "_t" ? " " : "")
      }
    } elif it.name == "u32" {
      if postfix == "_t" {
        return self._("uint32_t") + " "
      } else {
        return self._("d4_u32" + postfix) + (postfix.slice(-3) == "_t" ? " " : "")
      }
    } elif it.name == "u64" {
      if postfix == "_t" {
        return self._("uint64_t") + " "
      } else {
        return self._("d4_u64" + postfix) + (postfix.slice(-3) == "_t" ? " " : "")
      }
    } elif it.name == "usize" {
      if postfix == "_t" {
        return self._("size_t") + " "
      } else {
        return self._("d4_usize" + postfix) + (postfix.slice(-3) == "_t" ? " " : "")
      }
    } elif it.name == "void" {
      return "void "
    } elif (
      it.isArray() ||
      it.isEnum() ||
      it.isFunction() ||
      it.isMap() ||
      // TODO: test
      it.isMethod() ||
      // TODO: test
      it.isCustomObject() ||
      it.isOptional() ||
      it.isReference() ||
      it.isUnion()
    ) {
      self._typeGen(it)
      return self._("d4_" + self._typeName(it) + postfix) + (postfix.slice(-3) == "_t" ? " " : "")
    }

    throw error_NewError("Failed to generate type for '" + it.toString() + "'")
  }

  fn _typeGen (mut self: ref Self, it: ref Analyzer.Type) {
    if it.isAlias() {
      t := it.asAlias()
      self._typeGen(t.t)
    } elif it.isArray() {
      self._generateArrayType(it)
    } elif it.isCustomObject() {
      // TODO: test
      self._generateObjectType(it)
    } elif it.isFunction() {
      self._generateFunctionType(it)
    } elif it.isMap() {
      self._generateMapType(it)
    } elif it.isMethod() {
      // TODO: test
      tm := self._tm()
      self._generateFunctionType(tm.convertMethod(it))
    } elif it.isOptional() {
      self._generateOptionalType(it)
    } elif it.isReference() {
      self._generateReferenceType(it)
    } elif it.isUnion() {
      self._generateUnionType(it)
    }
  }

  fn _typeDef (mut self: ref Self, it: ref Analyzer.Type) str {
    typeName := "TYPE_" + self._typeName(it)

    if self._hasEntity(typeName) {
      return typeName
    }

    lastTypeId := ++self.lastTypeId
    self.typeDefs.set(typeName, lastTypeId)

    self.entities.push(CodegenEntity{
      name: typeName,
      codeName: typeName,
      context: it,
      generate: (mut self: ref Codegen, entity: ref CodegenEntity) -> GenerateReturnType {
        typeDefIdx := self.typeDefs.get(entity.codeName)
        return AST.createDefineDirective(entity.codeName, nil, typeDefIdx.str())
      },
    })

    return typeName
  }

  fn _typeName (mut self: ref Self, it: ref Analyzer.Type) str {
    if it.isAlias() {
      t := it.asAlias()
      return self._typeName(t.t)
    } elif it.isArray() {
      t := it.asArray()
      return "arr_" + self._typeName(t.elementType)
    } elif it.isCustomObject() {
      return "obj_" + it.name
    } elif it.isEnum() || it.isObject() {
      return it.name
    } elif it.isFunction() {
      t := it.asFunction()
      mut name := "fn_" + (t.asynchronous ? "a" : "s")

      loop i := 0; i < t.parameters.len; i++ {
        parameter := t.parameters[i]
        name += typeParameterId(parameter) + self._typeName(parameter.t)
      }

      return name + "FR" + self._typeName(t.returnType) + "FE"
    } elif it.isMap() {
      t := it.asMap()
      return "map_" + self._typeName(t.keyType) + "MS" + self._typeName(t.valueType) + "ME"
    } elif it.isMethod() {
      // TODO: test
      tm := self._tm()
      return self._typeName(tm.convertMethod(it))
    } elif it.isOptional() {
      t := it.asOptional()
      return "opt_" + self._typeName(t.t)
    } elif it.isReference() {
      t := it.asReference()
      return "ref_" + self._typeName(t.t)
    } elif it.isUnion() {
      t := it.asUnion()
      mut names: str[]

      loop i := 0; i < t.types.len; i++ {
        subType := t.types[i] as ref Analyzer.Type
        names.push(self._typeName(subType))
      }

      namesSorted := names.sort(sortStrAsc)
      return "union_" + namesSorted.join("US") + "UE"
    }

    throw error_NewError("Failed to generate type name for '" + it.name + "'")
  }

  fn _wrap (mut self: ref Self, mut expression: AST.CExpression, item: ref Parser.Expression, t: ref Analyzer.Type, targetType: ref Analyzer.Type, transform := false) AST.CExpression {
    shouldFree := typeShouldBeFreed(targetType) && expressionShouldBeFreed(item)

    if transform && !shouldFree && typeShouldBeAllocated(t) && expressionShouldBeAllocated(item) {
      expression = self._allocateExpression(t, expression)
    }

    if targetType.name == "any" && t.name != "any" {
      allocAnyType := self._generateAnyType(t).slice(0, -2) + "_alloc"
      expression = AST.createCallExpression(AST.createIdentifier(self._(allocAnyType)), [expression])
    } elif targetType.name != "any" && t.name == "any" {
      typeName := self._generateAnyType(targetType)

      // TODO: throw runtime error if not possible to cast
      innerExpression := AST.createCastExpression(
        AST.createType(self._(typeName)),
        createASTPropertyAccess(expression, "ctx"),
      )

      expression = AST.createUnaryExpression("*", innerExpression.wrap())
    } elif targetType.isOptional() && !t.isOptional() {
      allocOptionalType := self._generateOptionalType(targetType).slice(0, -2) + "_alloc"
      expression = AST.createCallExpression(AST.createIdentifier(self._(allocOptionalType)), [expression])
    } elif !targetType.isReference() && t.isReference() {
      expression = AST.createUnaryExpression("*", expression)
    } elif targetType.isReference() && !t.isReference() {
      expression = AST.createUnaryExpression("&", expression)
    } elif targetType.isUnion() && !t.isUnion() {
      allocTargetType := self._type(targetType, "_alloc")
      typeDef := self._typeDef(t)

      expression = AST.createCallExpression(AST.createIdentifier(allocTargetType), [
        AST.createIdentifier(self._(typeDef)),
        expression,
      ])
    } elif !targetType.isUnion() && t.isUnion() {
      typeName := self._typeDef(targetType)
      typeDefIdx := self.typeDefs.get(typeName)

      // TODO: throw runtime error if not possible to cast
      expression = AST.createPropertyAccessExpression(
        createASTPropertyAccess(expression, "data"),
        "v" + typeDefIdx.str(),
      )
    } elif !Analyzer.match(t, targetType) && (
      targetType.name == "bool" ||
      targetType.name == "byte" ||
      targetType.name == "char" ||
      targetType.name == "rune" ||
      targetType.isNumber()
    ) {
      expression = AST.createCastExpression(AST.createType(self._type(targetType)), expression)
    }

    if !transform {
      return expression
    }

    typesMatch := Analyzer.match(t, targetType)

    if shouldFree {
      expression = self._functionFree(targetType, expression)
    } elif !typesMatch && typeShouldBeAllocated(targetType) && expressionShouldBeAllocated(item) {
      expression = self._allocateExpression(targetType, expression)
    }

    return expression
  }
}

export fn compile (analyzer: ref Analyzer.Analyzer, executablePath: str) {
  mut generator := Codegen{analyzer: analyzer}
  generator.init()
  generator.generate()

  codePath := executablePath + ".c"

  fs_writeFileSync(codePath, generator.stringify().toBuffer())
  process_runSync("clang '" + codePath + "' -o '" + executablePath + "' " + generator.getFlags())
  fs_rmSync(codePath)
}
