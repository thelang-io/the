======= stdin =======
const IGNORED_HEADERS := ["date", "connection", "keep-alive", "content-length", "server"]

fn ignoredHeadersIncludes (it: str) bool {
  loop i := 0; i < IGNORED_HEADERS.len; i++ {
    if IGNORED_HEADERS[i] == it {
      return true
    }
  }

  return false
}

fn requestWithPrint (
  method: str,
  url: str,
  data: buffer_Buffer,
  headers: request_Header[] = []
) {
  mut req := request_open(method, url, data: data, headers: headers)
  res := req.read()
  req.close()

  actualData := res.data.str()
  mut actualHeaders: request_Header[]

  loop i := 0; i < res.headers.len; i++ {
    header := res.headers[i]

    if !ignoredHeadersIncludes(header.name) {
      actualHeaders.push(header)
    }
  }

  print(method, url)
  print("status:", res.status)

  if actualHeaders.len > 0 {
    print("headers:", actualHeaders)
  }

  if actualData.len > 0 {
    print("data:", actualData)
  }
}

main {
  requestWithPrint(
    "GET",
    "https://ci.thelang.io/echo?status=200",
    data: "".toBuffer()
  )

  print()

  requestWithPrint(
    "GET",
    "https://ci.thelang.io/echo?status=400",
    data: "".toBuffer()
  )

  print()

  requestWithPrint(
    "GET",
    "https://ci.thelang.io/echo?status=500",
    data: "".toBuffer()
  )

  print()

  requestWithPrint(
    "POST",
    "https://ci.thelang.io/echo",
    data: "".toBuffer()
  )

  print()

  requestWithPrint(
    "POST",
    "https://ci.thelang.io/echo",
    data: "test".toBuffer()
  )

  print()

  requestWithPrint(
    "POST",
    "https://ci.thelang.io/echo",
    data: "test1=value1&test2=value2".toBuffer(),
    headers: [
      request_Header{name: "content-type", value: "application/x-www-form-urlencoded"},
      request_Header{name: "custom-header", value: "custom-value"}
    ]
  )
}
======= code =======
#if defined(WIN32) || defined(_WIN32) || defined(__WIN32) || defined(__WIN32__)
  #define THE_OS_WINDOWS
  #define THE_EOL "\r\n"
  #define THE_PATH_SEP "\\"
#else
  #if defined(__APPLE__)
    #define THE_OS_MACOS
  #elif defined(__linux__)
    #define THE_OS_LINUX
  #endif
  #define THE_EOL "\n"
  #define THE_PATH_SEP "/"
#endif

#include <ctype.h>
#include <inttypes.h>
#include <openssl/ssl.h>
#include <stdarg.h>
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#ifdef THE_OS_WINDOWS
  #include <winsock2.h>
  #include <ws2tcpip.h>
  #include <windows.h>
#endif
#ifndef THE_OS_WINDOWS
  #include <netdb.h>
  #include <netinet/in.h>
  #include <sys/socket.h>
  #include <unistd.h>
#endif

bool lib_openssl_init = false;
bool lib_ws2_init = false;

struct buffer {
  unsigned char *d;
  size_t l;
};
struct request {
  #ifdef THE_OS_WINDOWS
    SOCKET fd;
  #else
    int fd;
  #endif
  SSL_CTX *ctx;
  SSL *ssl;
};
struct str {
  char *d;
  size_t l;
};

struct __THE_1_array_str;
struct __THE_1_fn$0;
struct __THE_1_fn$0P;
struct request_Header;
struct request_Request;
struct __THE_1_array_request_Header;
struct request_Response;
struct url_URL;
struct __THE_1_ignoredHeadersIncludes_0X;
struct __THE_1_fn$1000;
struct __THE_1_fn$1000P;
struct __THE_1_requestWithPrint_0X;

struct __THE_1_array_str {
  struct str *d;
  size_t l;
};
struct __THE_1_fn$0 {
  bool (*f) (void *, struct __THE_1_fn$0P);
  void *x;
  size_t l;
};
struct __THE_1_fn$0P {
  struct str n0;
};
struct request_Header {
  const struct str __THE_0_name;
  const struct str __THE_0_value;
};
struct request_Request {
  void *_;
};
struct __THE_1_array_request_Header {
  struct request_Header **d;
  size_t l;
};
struct request_Response {
  const struct buffer __THE_0_data;
  const int32_t __THE_0_status;
  const struct __THE_1_array_request_Header __THE_0_headers;
};
struct url_URL {
  const struct str __THE_0_origin;
  const struct str __THE_0_protocol;
  const struct str __THE_0_host;
  const struct str __THE_0_hostname;
  const struct str __THE_0_port;
  const struct str __THE_0_path;
  const struct str __THE_0_pathname;
  const struct str __THE_0_search;
  const struct str __THE_0_hash;
};
struct __THE_1_ignoredHeadersIncludes_0X {
  const struct __THE_1_array_str *__THE_0_IGNORED_HEADERS_0;
};
struct __THE_1_fn$1000 {
  void (*f) (void *, struct __THE_1_fn$1000P);
  void *x;
  size_t l;
};
struct __THE_1_fn$1000P {
  struct str n0;
  struct str n1;
  struct buffer n2;
  unsigned char o3;
  struct __THE_1_array_request_Header n3;
};
struct __THE_1_requestWithPrint_0X {
  const struct __THE_1_fn$0 *__THE_0_ignoredHeadersIncludes_0;
};

void *alloc (size_t);
struct buffer buffer_copy (const struct buffer);
void buffer_free (struct buffer);
struct str buffer_to_str (struct buffer);
void print (FILE *, const char *, ...);
void *re_alloc (void *, size_t);
void request_close (struct request_Request **);
struct request_Request *request_open (struct str, struct str, unsigned char, struct buffer, unsigned char, struct __THE_1_array_request_Header);
struct request_Response *request_read (struct request_Request **);
char *request_stringifyHeaders (struct __THE_1_array_request_Header, struct url_URL *, struct buffer);
struct str str_alloc (const char *);
struct str str_concat_cstr (struct str, const char *);
struct str str_concat_str (struct str, struct str);
struct str str_copy (const struct str);
char *str_cstr (const struct str);
bool str_eq_str (struct str, struct str);
struct str str_escape (const struct str);
void str_free (struct str);
size_t str_len (struct str);
struct buffer str_toBuffer (struct str);
struct url_URL *url_parse (struct str);
struct __THE_1_array_str __THE_1_array_str_alloc (size_t, ...);
struct str *__THE_1_array_str_at (struct __THE_1_array_str, int32_t);
struct __THE_1_array_str __THE_1_array_str_copy (const struct __THE_1_array_str);
void __THE_1_array_str_free (struct __THE_1_array_str);
void __THE_1_fn$0_free (struct __THE_1_fn$0);
size_t __THE_1_array_str_len (struct __THE_1_array_str);
struct request_Header *request_Header_alloc (struct str, struct str);
struct request_Header *request_Header_copy (const struct request_Header *);
void request_Header_free (struct request_Header *);
struct str request_Header_str (struct request_Header *);
void request_Request_free (struct request_Request *);
struct __THE_1_array_request_Header __THE_1_array_request_Header_alloc (size_t, ...);
struct request_Header **__THE_1_array_request_Header_at (struct __THE_1_array_request_Header, int32_t);
struct __THE_1_array_request_Header __THE_1_array_request_Header_copy (const struct __THE_1_array_request_Header);
void __THE_1_array_request_Header_free (struct __THE_1_array_request_Header);
size_t __THE_1_array_request_Header_len (struct __THE_1_array_request_Header);
void __THE_1_array_request_Header_push (struct __THE_1_array_request_Header *, struct __THE_1_array_request_Header);
struct str __THE_1_array_request_Header_str (struct __THE_1_array_request_Header);
struct request_Response *request_Response_alloc (struct buffer, int32_t, struct __THE_1_array_request_Header);
void request_Response_free (struct request_Response *);
struct url_URL *url_URL_alloc (struct str, struct str, struct str, struct str, struct str, struct str, struct str, struct str, struct str);
void url_URL_free (struct url_URL *);
bool __THE_1_ignoredHeadersIncludes_0 (void *, struct __THE_1_fn$0P);
void __THE_1_ignoredHeadersIncludes_0_alloc (struct __THE_1_fn$0 *, struct __THE_1_ignoredHeadersIncludes_0X);
void __THE_1_fn$1000_free (struct __THE_1_fn$1000);
void __THE_1_requestWithPrint_0 (void *, struct __THE_1_fn$1000P);
void __THE_1_requestWithPrint_0_alloc (struct __THE_1_fn$1000 *, struct __THE_1_requestWithPrint_0X);

void *alloc (size_t l) {
  void *r = malloc(l);
  if (r == NULL) {
    fprintf(stderr, "Error: failed to allocate %zu bytes" THE_EOL, l);
    exit(EXIT_FAILURE);
  }
  return r;
}
struct buffer buffer_copy (const struct buffer o) {
  unsigned char *d = alloc(o.l);
  memcpy(d, o.d, o.l);
  return (struct buffer) {d, o.l};
}
void buffer_free (struct buffer o) {
  free(o.d);
}
struct str buffer_to_str (struct buffer b) {
  return (struct str) {(char *) b.d, b.l};
}
void print (FILE *stream, const char *fmt, ...) {
  va_list args;
  va_start(args, fmt);
  char buf[512];
  struct str s;
  while (*fmt) {
    switch (*fmt++) {
      case 't': fputs(va_arg(args, int) ? "true" : "false", stream); break;
      case 'b': sprintf(buf, "%u", va_arg(args, unsigned)); fputs(buf, stream); break;
      case 'c': fputc(va_arg(args, int), stream); break;
      case 'e':
      case 'f':
      case 'g': snprintf(buf, 512, "%f", va_arg(args, double)); fputs(buf, stream); break;
      case 'h':
      case 'j':
      case 'v':
      case 'w': sprintf(buf, "%d", va_arg(args, int)); fputs(buf, stream); break;
      case 'i':
      case 'k': sprintf(buf, "%" PRId32, va_arg(args, int32_t)); fputs(buf, stream); break;
      case 'l': sprintf(buf, "%" PRId64, va_arg(args, int64_t)); fputs(buf, stream); break;
      case 'p': sprintf(buf, "%p", va_arg(args, void *)); fputs(buf, stream); break;
      case 's': s = va_arg(args, struct str); fwrite(s.d, 1, s.l, stream); str_free(s); break;
      case 'u': sprintf(buf, "%" PRIu32, va_arg(args, uint32_t)); fputs(buf, stream); break;
      case 'y': sprintf(buf, "%" PRIu64, va_arg(args, uint64_t)); fputs(buf, stream); break;
      case 'z': fputs(va_arg(args, char *), stream); break;
    }
  }
  va_end(args);
}
void *re_alloc (void *d, size_t l) {
  void *r = realloc(d, l);
  if (r == NULL) {
    fprintf(stderr, "Error: failed to reallocate %zu bytes" THE_EOL, l);
    exit(EXIT_FAILURE);
  }
  return r;
}
void request_close (struct request_Request **r) {
  struct request *req = (void *) *r;
  if (req->ssl != NULL) {
    SSL_CTX_free(req->ctx);
    SSL_free(req->ssl);
  } else if (req->fd != 0) {
    #ifdef THE_OS_WINDOWS
      closesocket(req->fd);
    #else
      close(req->fd);
    #endif
  }
  req->fd = 0;
  req->ctx = NULL;
  req->ssl = NULL;
}
struct request_Request *request_open (struct str method, struct str u, unsigned char o1, struct buffer data, unsigned char o2, struct __THE_1_array_request_Header headers) {
  struct url_URL *url = url_parse(u);
  if (
    !(url->__THE_0_protocol.l == 5 && memcmp(url->__THE_0_protocol.d, "http:", 5) == 0) &&
    !(url->__THE_0_protocol.l == 6 && memcmp(url->__THE_0_protocol.d, "https:", 6) == 0)
  ) {
    char *protocol = str_cstr(url->__THE_0_protocol);
    fprintf(stderr, "Error: can't perform request with protocol `%s`" THE_EOL, protocol);
    exit(EXIT_FAILURE);
  } else if (url->__THE_0_port.l >= 6) {
    char *port = str_cstr(url->__THE_0_port);
    fprintf(stderr, "Error: invalid port `%s`" THE_EOL, port);
    exit(EXIT_FAILURE);
  }
  char port[6];
  if (url->__THE_0_port.l != 0) {
    memcpy(port, url->__THE_0_port.d, url->__THE_0_port.l);
    port[url->__THE_0_port.l] = '\0';
    unsigned long p = strtoul(port, NULL, 10);
    if (p > 65535) {
      fprintf(stderr, "Error: invalid port `%s`" THE_EOL, port);
      exit(EXIT_FAILURE);
    }
  } else {
    memcpy(port, url->__THE_0_protocol.l == 6 ? "443" : "80", url->__THE_0_protocol.l == 6 ? 3 : 2);
    port[url->__THE_0_protocol.l == 6 ? 3 : 2] = '\0';
  }
  #ifdef THE_OS_WINDOWS
    if (!lib_ws2_init) {
      WSADATA w;
      if (WSAStartup(MAKEWORD(2, 2), &w) != 0) {
        fprintf(stderr, "Error: failed to initialize use of Windows Sockets DLL" THE_EOL);
        exit(EXIT_FAILURE);
      }
      lib_ws2_init = true;
    }
  #endif
  char *hostname = str_cstr(url->__THE_0_hostname);
  struct addrinfo *addr = NULL;
  struct addrinfo hints;
  memset(&hints, 0, sizeof(hints));
  hints.ai_family = AF_INET;
  hints.ai_socktype = SOCK_STREAM;
  hints.ai_protocol = IPPROTO_TCP;
  if (getaddrinfo(hostname, port, &hints, &addr) != 0) {
    fprintf(stderr, "Error: failed to resolve hostname address" THE_EOL);
    exit(EXIT_FAILURE);
  }
  struct request *req = alloc(sizeof(struct request));
  req->fd = socket(addr->ai_family, addr->ai_socktype, addr->ai_protocol);
  req->ctx = NULL;
  req->ssl = NULL;
  #ifdef THE_OS_WINDOWS
    bool socket_res = req->fd != INVALID_SOCKET;
  #else
    bool socket_res = req->fd != -1;
  #endif
  if (!socket_res) {
    fprintf(stderr, "Error: failed to create socket" THE_EOL);
    exit(EXIT_FAILURE);
  }
  #ifdef THE_OS_WINDOWS
    bool connect_res = connect(req->fd, addr->ai_addr, (int) addr->ai_addrlen) != SOCKET_ERROR;
  #else
    bool connect_res = connect(req->fd, addr->ai_addr, addr->ai_addrlen) != -1;
  #endif
  if (!connect_res) {
    char *origin = str_cstr(url->__THE_0_origin);
    fprintf(stderr, "Error: failed to connect to `%s`" THE_EOL, origin);
    exit(EXIT_FAILURE);
  }
  freeaddrinfo(addr);
  if (strcmp(port, "443") == 0) {
    if (!lib_openssl_init) {
      SSL_library_init();
      lib_openssl_init = true;
    }
    req->ctx = SSL_CTX_new(TLS_client_method());
    if (req->ctx == NULL) {
      fprintf(stderr, "Error: failed to create SSL context" THE_EOL);
      exit(EXIT_FAILURE);
    }
    req->ssl = SSL_new(req->ctx);
    SSL_set_fd(req->ssl, (int) req->fd);
    SSL_set_tlsext_host_name(req->ssl, hostname);
    if (SSL_connect(req->ssl) != 1) {
      fprintf(stderr, "Error: failed to connect to socket with SSL" THE_EOL);
      exit(EXIT_FAILURE);
    }
  }
  free(hostname);
  char *req_headers = request_stringifyHeaders(headers, url, data);
  __THE_1_array_request_Header_free(headers);
  char *req_method = str_cstr(method);
  str_free(method);
  char *req_path = str_cstr(url->__THE_0_path);
  char *fmt = "%s %s HTTP/1.1\r\n%s\r\n";
  size_t req_len = snprintf(NULL, 0, fmt, req_method, req_path, req_headers);
  char *request = alloc(req_len + (data.l == 0 ? 0 : data.l + 2) + 1);
  sprintf(request, fmt, req_method, req_path, req_headers);
  free(req_path);
  free(req_method);
  free(req_headers);
  if (data.l != 0) {
    memcpy(&request[req_len], data.d, data.l);
    req_len += data.l;
    memcpy(&request[req_len], "\r\n", 3);
    req_len += 2;
  }
  buffer_free(data);
  size_t y = 0;
  while (y < req_len) {
    int z = req->ssl == NULL ? (int) send(req->fd, &request[y], req_len - y, 0) : SSL_write(req->ssl, &request[y], (int) (req_len - y));
    if (z < 0) {
      fprintf(stderr, "Error: failed to write to socket" THE_EOL);
      exit(EXIT_FAILURE);
    }
    y += (size_t) z;
  }
  free(request);
  url_URL_free(url);
  return (struct request_Request *) req;
}
struct request_Response *request_read (struct request_Request **r) {
  struct request *req = (void *) *r;
  unsigned char b[1024];
  struct buffer data = {NULL, 0};
  while (1) {
    int y = req->ssl == NULL ? (int) recv(req->fd, b, sizeof(b), 0) : SSL_read(req->ssl, b, sizeof(b));
    if (y < 0) {
      fprintf(stderr, "Error: failed to read from socket" THE_EOL);
      exit(EXIT_FAILURE);
    } else if (y == 0 && data.l != 0) {
      break;
    } else if (y == 0) {
      continue;
    } else if (data.l == 0) {
      (req->ssl == NULL ? shutdown(req->fd, 1) : SSL_shutdown(req->ssl));
    }
    data.d = re_alloc(data.d, data.l + y);
    memcpy(&data.d[data.l], b, y);
    data.l += y;
  }
  size_t i;
  if (data.l > 8 && (memcmp(data.d, "HTTP/1.0 ", 9) == 0 || memcmp(data.d, "HTTP/1.1 ", 9) == 0)) {
    i = 9;
  } else if (data.l > 6 && (memcmp(data.d, "HTTP/2 ", 7) == 0 || memcmp(data.d, "HTTP/3 ", 7) == 0)) {
    i = 7;
  } else {
    fprintf(stderr, "Error: invalid response HTTP version" THE_EOL);
    exit(EXIT_FAILURE);
  }
  size_t status_start = i;
  while (i < data.l && isdigit(data.d[i])) i++;
  if (status_start == i) {
    fprintf(stderr, "Error: invalid response HTTP status code" THE_EOL);
    exit(EXIT_FAILURE);
  }
  size_t status_len = i - status_start;
  char *status = alloc(status_len + 1);
  memcpy(status, &data.d[status_start], status_len);
  status[status_len] = '\0';
  int32_t status_code = (int32_t) strtoul(status, NULL, 10);
  free(status);
  while (i < data.l) {
    if (data.d[i] == '\r' && i + 1 < data.l && data.d[i + 1] == '\n') {
      i += 2;
      break;
    }
    i++;
  }
  struct __THE_1_array_request_Header headers = {NULL, 0};
  while (true) {
    if (data.d[i] == '\r' && i + 1 < data.l && data.d[i + 1] == '\n') {
      i += 2;
      break;
    }
    size_t header_name_start = i;
    size_t header_name_end = 0;
    size_t header_value_start = 0;
    size_t header_value_end = 0;
    while (i < data.l) {
      if (data.d[i] == '\r' && i + 1 < data.l && data.d[i + 1] == '\n') {
        header_value_end = i;
        i += 2;
        break;
      } else if (data.d[i] == ':' && header_name_end == 0) {
        header_name_end = i;
        i++;
        while (i < data.l && data.d[i] == ' ') i++;
        header_value_start = i;
      }
      i++;
    }
    struct str header_name;
    header_name.l = header_name_end - header_name_start;
    header_name.d = alloc(header_name.l);
    memcpy(header_name.d, &data.d[header_name_start], header_name.l);
    for (size_t j = 0; j < header_name.l; j++) header_name.d[j] = (char) tolower(header_name.d[j]);
    struct str header_value;
    header_value.l = header_value_end - header_value_start;
    header_value.d = alloc(header_value.l);
    memcpy(header_value.d, &data.d[header_value_start], header_value.l);
    headers.d = re_alloc(headers.d, (headers.l + 1) * sizeof(struct request_Header *));
    headers.d[headers.l] = request_Header_alloc(header_name, header_value);
    headers.l++;
  }
  for (size_t j = 0; j < headers.l; j++) {
    for (size_t k = j + 1; k < headers.l; k++) {
      size_t count = headers.d[j]->__THE_0_name.l > headers.d[k]->__THE_0_name.l ? headers.d[k]->__THE_0_name.l : headers.d[j]->__THE_0_name.l;
      if (memcmp(headers.d[j]->__THE_0_name.d, headers.d[k]->__THE_0_name.d, count) > 0) {
        struct request_Header *a = headers.d[j];
        headers.d[j] = headers.d[k];
        headers.d[k] = a;
      }
    }
  }
  if (data.l - i > 0) {
    data.l = data.l - i;
    memmove(data.d, &data.d[i], data.l);
    data.d = re_alloc(data.d, data.l);
  } else {
    free(data.d);
    data.d = NULL;
    data.l = 0;
  }
  return request_Response_alloc(data, status_code, headers);
}
char *request_stringifyHeaders (struct __THE_1_array_request_Header headers, struct url_URL *url, struct buffer data) {
  bool has_content_length = false;
  bool has_host = false;
  char *d = NULL;
  size_t l = 0;
  for (size_t i = 0; i < headers.l; i++) {
    struct request_Header *h = headers.d[i];
    char *name = str_cstr(h->__THE_0_name);
    for (size_t j = 0; j < h->__THE_0_name.l; j++) name[j] = (char) tolower(name[j]);
    if (strcmp(name, "content-length") == 0) has_content_length = true;
    else if (strcmp(name, "host") == 0) has_host = true;
    free(name);
    d = re_alloc(d, l + h->__THE_0_name.l + 2 + h->__THE_0_value.l + 3);
    memcpy(&d[l], h->__THE_0_name.d, h->__THE_0_name.l);
    memcpy(&d[l + h->__THE_0_name.l], ": ", 2);
    memcpy(&d[l + h->__THE_0_name.l + 2], h->__THE_0_value.d, h->__THE_0_value.l);
    memcpy(&d[l + h->__THE_0_name.l + 2 + h->__THE_0_value.l], "\r\n", 3);
    l += h->__THE_0_name.l + 2 + h->__THE_0_value.l + 2;
  }
  if (!has_host) {
    char *h = str_cstr(url->__THE_0_hostname);
    size_t z = snprintf(NULL, 0, "Host: %s\r\n", h);
    d = re_alloc(d, l + z + 1);
    sprintf(&d[l], "Host: %s\r\n", h);
    l += z;
    free(h);
  }
  if (!has_content_length) {
    size_t z = snprintf(NULL, 0, "Content-Length: %zu\r\n", data.l);
    d = re_alloc(d, l + z + 1);
    sprintf(&d[l], "Content-Length: %zu\r\n", data.l);
    l += z;
  }
  return d;
}
struct str str_alloc (const char *r) {
  size_t l = strlen(r);
  char *d = alloc(l);
  memcpy(d, r, l);
  return (struct str) {d, l};
}
struct str str_concat_cstr (struct str s, const char *r) {
  size_t l = s.l + strlen(r);
  char *d = alloc(l);
  memcpy(d, s.d, s.l);
  memcpy(&d[s.l], r, l - s.l);
  free(s.d);
  return (struct str) {d, l};
}
struct str str_concat_str (struct str s1, struct str s2) {
  size_t l = s1.l + s2.l;
  char *d = alloc(l);
  memcpy(d, s1.d, s1.l);
  memcpy(&d[s1.l], s2.d, s2.l);
  free(s1.d);
  free(s2.d);
  return (struct str) {d, l};
}
struct str str_copy (const struct str s) {
  char *d = alloc(s.l);
  memcpy(d, s.d, s.l);
  return (struct str) {d, s.l};
}
char *str_cstr (const struct str s) {
  char *d = alloc(s.l + 1);
  memcpy(d, s.d, s.l);
  d[s.l] = '\0';
  return d;
}
bool str_eq_str (struct str s1, struct str s2) {
  bool r = s1.l == s2.l && memcmp(s1.d, s2.d, s1.l) == 0;
  free(s1.d);
  free(s2.d);
  return r;
}
struct str str_escape (const struct str s) {
  char *d = alloc(s.l);
  size_t l = 0;
  for (size_t i = 0; i < s.l; i++) {
    char c = s.d[i];
    if (c == '\f' || c == '\n' || c == '\r' || c == '\t' || c == '\v' || c == '"') {
      if (l + 2 > s.l) d = re_alloc(d, l + 2);
      d[l++] = '\\';
      if (c == '\f') d[l++] = 'f';
      else if (c == '\n') d[l++] = 'n';
      else if (c == '\r') d[l++] = 'r';
      else if (c == '\t') d[l++] = 't';
      else if (c == '\v') d[l++] = 'v';
      else if (c == '"') d[l++] = '"';
      continue;
    }
    if (l + 1 > s.l) d = re_alloc(d, l + 1);
    d[l++] = c;
  }
  return (struct str) {d, l};
}
void str_free (struct str s) {
  free(s.d);
}
size_t str_len (struct str s) {
  size_t l = s.l;
  free(s.d);
  return l;
}
struct buffer str_toBuffer (struct str s) {
  return (struct buffer) {(unsigned char *) s.d, s.l};
}
struct url_URL *url_parse (struct str s) {
  if (s.l == 0) {
    fprintf(stderr, "Error: invalid URL" THE_EOL);
    exit(EXIT_FAILURE);
  }
  size_t i = 0;
  for (;; i++) {
    char ch = s.d[i];
    if (ch == ':' && i != 0) {
      i++;
      break;
    } else if (!isalnum(ch) && ch != '.' && ch != '-' && ch != '+') {
      fprintf(stderr, "Error: invalid URL protocol" THE_EOL);
      exit(EXIT_FAILURE);
    } else if (i == s.l - 1) {
      fprintf(stderr, "Error: invalid URL" THE_EOL);
      exit(EXIT_FAILURE);
    }
  }
  struct str protocol;
  protocol.l = i;
  protocol.d = alloc(protocol.l);
  memcpy(protocol.d, s.d, protocol.l);
  while (i < s.l && s.d[i] == '/') i++;
  if (i == s.l) {
    str_free(s);
    return url_URL_alloc(str_alloc(""), protocol, str_alloc(""), str_alloc(""), str_alloc(""), str_alloc(""), str_alloc(""), str_alloc(""), str_alloc(""));
  }
  size_t protocol_end = i;
  if ((protocol_end - protocol.l) < 2) {
    i = protocol.l;
    protocol_end = i;
  }
  size_t hostname_start = protocol.l == protocol_end ? 0 : i;
  size_t port_start = 0;
  size_t pathname_start = protocol.l == protocol_end ? i : 0;
  size_t search_start = 0;
  size_t hash_start = 0;
  for (;; i++) {
    char ch = s.d[i];
    if (ch == '@' && hostname_start != 0 && pathname_start == 0) {
      fprintf(stderr, "Error: URL auth is not supported" THE_EOL);
      exit(EXIT_FAILURE);
    } else if (ch == ':' && port_start != 0 && (pathname_start == 0 || search_start == 0 || hash_start == 0)) {
      fprintf(stderr, "Error: invalid URL port" THE_EOL);
      exit(EXIT_FAILURE);
    }
    if (ch == ':' && hostname_start != 0 && pathname_start == 0) port_start = i;
    else if (ch == '/' && pathname_start == 0) pathname_start = i;
    else if (ch == '?' && search_start == 0) search_start = i;
    else if (ch == '#' && hash_start == 0) hash_start = i;
    if (i == s.l - 1) break;
  }
  struct str hostname = str_alloc("");
  size_t hostname_end = port_start != 0 ? port_start : pathname_start != 0 ? pathname_start : search_start != 0 ? search_start : hash_start != 0 ? hash_start : s.l;
  if (hostname_start != 0 && hostname_start == hostname_end) {
    fprintf(stderr, "Error: invalid URL hostname" THE_EOL);
    exit(EXIT_FAILURE);
  } else if (hostname_start != 0 && hostname_start != hostname_end) {
    hostname.l = hostname_end - hostname_start;
    hostname.d = re_alloc(hostname.d, hostname.l);
    memcpy(hostname.d, &s.d[hostname_start], hostname.l);
  }
  struct str port = str_alloc("");
  size_t port_end = pathname_start != 0 ? pathname_start : search_start != 0 ? search_start : hash_start != 0 ? hash_start : s.l;
  if (port_start != 0 && port_start + 1 != port_end) {
    port.l = port_end - port_start - 1;
    port.d = re_alloc(port.d, port.l);
    memcpy(port.d, &s.d[port_start + 1], port.l);
  }
  struct str host = str_alloc("");
  if (hostname.l != 0) {
    host.l = hostname.l + (port.l == 0 ? 0 : port.l + 1);
    host.d = re_alloc(host.d, host.l);
    memcpy(host.d, hostname.d, hostname.l);
    if (port.l != 0) {
      memcpy(&host.d[hostname.l], ":", 1);
      memcpy(&host.d[hostname.l + 1], port.d, port.l);
    }
  }
  struct str origin = str_alloc("");
  if (memcmp(protocol.d, "ftp:", 4) == 0 || memcmp(protocol.d, "http:", 5) == 0 || memcmp(protocol.d, "https:", 6) == 0 || memcmp(protocol.d, "ws:", 3) == 0 || memcmp(protocol.d, "wss:", 4) == 0) {
    if (host.l == 0) {
      fprintf(stderr, "Error: URL origin is not present" THE_EOL);
      exit(EXIT_FAILURE);
    }
    origin.l = protocol.l + 2 + host.l;
    origin.d = re_alloc(origin.d, origin.l);
    memcpy(origin.d, protocol.d, protocol.l);
    memcpy(&origin.d[protocol.l], "//", 2);
    memcpy(&origin.d[protocol.l + 2], host.d, host.l);
  }
  struct str pathname = str_alloc("");
  size_t pathname_end = search_start != 0 ? search_start : hash_start != 0 ? hash_start : s.l;
  if (pathname_start != 0 && pathname_start != pathname_end) {
    pathname.l = pathname_end - pathname_start;
    pathname.d = re_alloc(pathname.d, pathname.l);
    memcpy(pathname.d, &s.d[pathname_start], pathname.l);
  } else if (memcmp(protocol.d, "ftp:", 4) == 0 || memcmp(protocol.d, "http:", 5) == 0 || memcmp(protocol.d, "https:", 6) == 0 || memcmp(protocol.d, "ws:", 3) == 0 || memcmp(protocol.d, "wss:", 4) == 0) {
    pathname.l = 1;
    pathname.d = re_alloc(pathname.d, pathname.l);
    memcpy(pathname.d, "/", pathname.l);
  }
  struct str search = str_alloc("");
  size_t search_end = hash_start != 0 ? hash_start : s.l;
  if (search_start != 0 && search_start != search_end) {
    search.l = search_end - search_start;
    search.d = re_alloc(search.d, search.l);
    memcpy(search.d, &s.d[search_start], search.l);
  }
  struct str path = str_alloc("");
  if (pathname.l != 0 || search.l != 0) {
    path.l = pathname.l + search.l;
    path.d = re_alloc(path.d, path.l);
    if (pathname.l != 0) {
      memcpy(path.d, pathname.d, pathname.l);
      if (search.l != 0) memcpy(&path.d[pathname.l], search.d, search.l);
    } else if (search.l != 0) {
      memcpy(path.d, search.d, search.l);
    }
  }
  struct str hash = str_alloc("");
  if (hash_start != 0) {
    hash.l = s.l - hash_start;
    hash.d = re_alloc(hash.d, hash.l);
    memcpy(hash.d, &s.d[hash_start], hash.l);
  }
  str_free(s);
  return url_URL_alloc(origin, protocol, host, hostname, port, path, pathname, search, hash);
}
struct __THE_1_array_str __THE_1_array_str_alloc (size_t x, ...) {
  if (x == 0) return (struct __THE_1_array_str) {NULL, 0};
  struct str *d = alloc(x * sizeof(struct str));
  va_list args;
  va_start(args, x);
  for (size_t i = 0; i < x; i++) d[i] = va_arg(args, struct str);
  va_end(args);
  return (struct __THE_1_array_str) {d, x};
}
struct str *__THE_1_array_str_at (struct __THE_1_array_str n, int32_t i) {
  if ((i >= 0 && i >= n.l) || (i < 0 && i < -((int32_t) n.l))) {
    fprintf(stderr, "Error: index %" PRId32 " out of array bounds" THE_EOL, i);
    exit(EXIT_FAILURE);
  }
  return i < 0 ? &n.d[n.l + i] : &n.d[i];
}
struct __THE_1_array_str __THE_1_array_str_copy (const struct __THE_1_array_str n) {
  if (n.l == 0) return (struct __THE_1_array_str) {NULL, 0};
  struct str *d = alloc(n.l * sizeof(struct str));
  for (size_t i = 0; i < n.l; i++) d[i] = str_copy(n.d[i]);
  return (struct __THE_1_array_str) {d, n.l};
}
void __THE_1_array_str_free (struct __THE_1_array_str n) {
  for (size_t i = 0; i < n.l; i++) str_free((struct str) n.d[i]);
  free(n.d);
}
void __THE_1_fn$0_free (struct __THE_1_fn$0 n) {
  if (n.x != NULL) free(n.x);
}
size_t __THE_1_array_str_len (struct __THE_1_array_str n) {
  size_t l = n.l;
  __THE_1_array_str_free((struct __THE_1_array_str) n);
  return l;
}
struct request_Header *request_Header_alloc (struct str __THE_0_name, struct str __THE_0_value) {
  struct request_Header *r = alloc(sizeof(struct request_Header));
  struct request_Header s = {__THE_0_name, __THE_0_value};
  memcpy(r, &s, sizeof(struct request_Header));
  return r;
}
struct request_Header *request_Header_copy (const struct request_Header *n) {
  struct request_Header *r = alloc(sizeof(struct request_Header));
  struct request_Header s = {str_copy(n->__THE_0_name), str_copy(n->__THE_0_value)};
  memcpy(r, &s, sizeof(struct request_Header));
  return r;
}
void request_Header_free (struct request_Header *n) {
  str_free((struct str) n->__THE_0_name);
  str_free((struct str) n->__THE_0_value);
  free(n);
}
struct str request_Header_str (struct request_Header *n) {
  struct str r = str_alloc("request_Header{");
  r = str_concat_cstr(r, "name: \"");
  r = str_concat_str(r, str_escape(n->__THE_0_name));
  r = str_concat_cstr(r, "\"");
  r = str_concat_cstr(r, ", value: \"");
  r = str_concat_str(r, str_escape(n->__THE_0_value));
  r = str_concat_cstr(r, "\"");
  request_Header_free((struct request_Header *) n);
  return str_concat_cstr(r, "}");
}
void request_Request_free (struct request_Request *n) {
  request_close(&n);
  free(n);
}
struct __THE_1_array_request_Header __THE_1_array_request_Header_alloc (size_t x, ...) {
  if (x == 0) return (struct __THE_1_array_request_Header) {NULL, 0};
  struct request_Header **d = alloc(x * sizeof(struct request_Header *));
  va_list args;
  va_start(args, x);
  for (size_t i = 0; i < x; i++) d[i] = va_arg(args, struct request_Header *);
  va_end(args);
  return (struct __THE_1_array_request_Header) {d, x};
}
struct request_Header **__THE_1_array_request_Header_at (struct __THE_1_array_request_Header n, int32_t i) {
  if ((i >= 0 && i >= n.l) || (i < 0 && i < -((int32_t) n.l))) {
    fprintf(stderr, "Error: index %" PRId32 " out of array bounds" THE_EOL, i);
    exit(EXIT_FAILURE);
  }
  return i < 0 ? &n.d[n.l + i] : &n.d[i];
}
struct __THE_1_array_request_Header __THE_1_array_request_Header_copy (const struct __THE_1_array_request_Header n) {
  if (n.l == 0) return (struct __THE_1_array_request_Header) {NULL, 0};
  struct request_Header **d = alloc(n.l * sizeof(struct request_Header *));
  for (size_t i = 0; i < n.l; i++) d[i] = request_Header_copy(n.d[i]);
  return (struct __THE_1_array_request_Header) {d, n.l};
}
void __THE_1_array_request_Header_free (struct __THE_1_array_request_Header n) {
  for (size_t i = 0; i < n.l; i++) request_Header_free((struct request_Header *) n.d[i]);
  free(n.d);
}
size_t __THE_1_array_request_Header_len (struct __THE_1_array_request_Header n) {
  size_t l = n.l;
  __THE_1_array_request_Header_free((struct __THE_1_array_request_Header) n);
  return l;
}
void __THE_1_array_request_Header_push (struct __THE_1_array_request_Header *n, struct __THE_1_array_request_Header m) {
  if (m.l == 0) return;
  n->l += m.l;
  n->d = re_alloc(n->d, n->l * sizeof(struct request_Header *));
  size_t k = 0;
  for (size_t i = n->l - m.l; i < n->l; i++) n->d[i] = m.d[k++];
  free(m.d);
}
struct str __THE_1_array_request_Header_str (struct __THE_1_array_request_Header n) {
  struct str r = str_alloc("[");
  for (size_t i = 0; i < n.l; i++) {
    if (i != 0) r = str_concat_cstr(r, ", ");
    r = str_concat_str(r, request_Header_str(request_Header_copy(n.d[i])));
  }
  __THE_1_array_request_Header_free((struct __THE_1_array_request_Header) n);
  return str_concat_cstr(r, "]");
}
struct request_Response *request_Response_alloc (struct buffer __THE_0_data, int32_t __THE_0_status, struct __THE_1_array_request_Header __THE_0_headers) {
  struct request_Response *r = alloc(sizeof(struct request_Response));
  struct request_Response s = {__THE_0_data, __THE_0_status, __THE_0_headers};
  memcpy(r, &s, sizeof(struct request_Response));
  return r;
}
void request_Response_free (struct request_Response *n) {
  buffer_free((struct buffer) n->__THE_0_data);
  __THE_1_array_request_Header_free((struct __THE_1_array_request_Header) n->__THE_0_headers);
  free(n);
}
struct url_URL *url_URL_alloc (struct str __THE_0_origin, struct str __THE_0_protocol, struct str __THE_0_host, struct str __THE_0_hostname, struct str __THE_0_port, struct str __THE_0_path, struct str __THE_0_pathname, struct str __THE_0_search, struct str __THE_0_hash) {
  struct url_URL *r = alloc(sizeof(struct url_URL));
  struct url_URL s = {__THE_0_origin, __THE_0_protocol, __THE_0_host, __THE_0_hostname, __THE_0_port, __THE_0_path, __THE_0_pathname, __THE_0_search, __THE_0_hash};
  memcpy(r, &s, sizeof(struct url_URL));
  return r;
}
void url_URL_free (struct url_URL *n) {
  str_free((struct str) n->__THE_0_origin);
  str_free((struct str) n->__THE_0_protocol);
  str_free((struct str) n->__THE_0_host);
  str_free((struct str) n->__THE_0_hostname);
  str_free((struct str) n->__THE_0_port);
  str_free((struct str) n->__THE_0_path);
  str_free((struct str) n->__THE_0_pathname);
  str_free((struct str) n->__THE_0_search);
  str_free((struct str) n->__THE_0_hash);
  free(n);
}
bool __THE_1_ignoredHeadersIncludes_0 (void *px, struct __THE_1_fn$0P p) {
  unsigned char r = 0;
  bool v;
  struct __THE_1_ignoredHeadersIncludes_0X *x = px;
  const struct __THE_1_array_str *__THE_0_IGNORED_HEADERS_0 = x->__THE_0_IGNORED_HEADERS_0;
  const struct str __THE_0_it_0 = p.n0;
  for (int32_t __THE_0_i_0 = 0; __THE_0_i_0 < __THE_1_array_str_len(__THE_1_array_str_copy(*__THE_0_IGNORED_HEADERS_0)); __THE_0_i_0++) {
    if (str_eq_str(str_copy(*__THE_1_array_str_at(*__THE_0_IGNORED_HEADERS_0, __THE_0_i_0)), str_copy(__THE_0_it_0))) {
      r = 1;
      v = true;
      goto L1;
    }
  }
  v = false;
L1:
  str_free((struct str) __THE_0_it_0);
  return v;
}
void __THE_1_ignoredHeadersIncludes_0_alloc (struct __THE_1_fn$0 *n, struct __THE_1_ignoredHeadersIncludes_0X x) {
  size_t l = sizeof(struct __THE_1_ignoredHeadersIncludes_0X);
  struct __THE_1_ignoredHeadersIncludes_0X *r = alloc(l);
  memcpy(r, &x, l);
  n->f = &__THE_1_ignoredHeadersIncludes_0;
  n->x = r;
  n->l = l;
}
void __THE_1_fn$1000_free (struct __THE_1_fn$1000 n) {
  if (n.x != NULL) free(n.x);
}
void __THE_1_requestWithPrint_0 (void *px, struct __THE_1_fn$1000P p) {
  struct __THE_1_requestWithPrint_0X *x = px;
  const struct __THE_1_fn$0 *__THE_0_ignoredHeadersIncludes_0 = x->__THE_0_ignoredHeadersIncludes_0;
  const struct str __THE_0_method_0 = p.n0;
  const struct str __THE_0_url_0 = p.n1;
  const struct buffer __THE_0_data_0 = p.n2;
  const struct __THE_1_array_request_Header __THE_0_headers_0 = p.o3 == 1 ? p.n3 : __THE_1_array_request_Header_alloc(0);
  struct request_Request *__THE_0_req_0 = request_open(str_copy(__THE_0_method_0), str_copy(__THE_0_url_0), 1, buffer_copy(__THE_0_data_0), 1, __THE_1_array_request_Header_copy(__THE_0_headers_0));
  const struct request_Response *__THE_0_res_0 = request_read(&__THE_0_req_0);
  request_close(&__THE_0_req_0);
  const struct str __THE_0_actualData_0 = buffer_to_str(buffer_copy(__THE_0_res_0->__THE_0_data));
  struct __THE_1_array_request_Header __THE_0_actualHeaders_0 = __THE_1_array_request_Header_alloc(0);
  for (int32_t __THE_0_i_0 = 0; __THE_0_i_0 < __THE_1_array_request_Header_len(__THE_1_array_request_Header_copy(__THE_0_res_0->__THE_0_headers)); __THE_0_i_0++) {
    const struct request_Header **__THE_0_header_0 = __THE_1_array_request_Header_at(__THE_0_res_0->__THE_0_headers, __THE_0_i_0);
    if (!(*__THE_0_ignoredHeadersIncludes_0).f((*__THE_0_ignoredHeadersIncludes_0).x, (struct __THE_1_fn$0P) {str_copy((*__THE_0_header_0)->__THE_0_name)})) {
      __THE_1_array_request_Header_push(&__THE_0_actualHeaders_0, __THE_1_array_request_Header_alloc(1, request_Header_copy(*__THE_0_header_0)));
    }
  }
  print(stdout, "szsz", str_copy(__THE_0_method_0), " ", str_copy(__THE_0_url_0), THE_EOL);
  print(stdout, "zziz", "status:", " ", __THE_0_res_0->__THE_0_status, THE_EOL);
  if (__THE_1_array_request_Header_len(__THE_1_array_request_Header_copy(__THE_0_actualHeaders_0)) > 0) {
    print(stdout, "zzsz", "headers:", " ", __THE_1_array_request_Header_str(__THE_1_array_request_Header_copy(__THE_0_actualHeaders_0)), THE_EOL);
  }
  if (str_len(str_copy(__THE_0_actualData_0)) > 0) {
    print(stdout, "zzsz", "data:", " ", str_copy(__THE_0_actualData_0), THE_EOL);
  }
  __THE_1_array_request_Header_free((struct __THE_1_array_request_Header) __THE_0_actualHeaders_0);
  str_free((struct str) __THE_0_actualData_0);
  request_Response_free((struct request_Response *) __THE_0_res_0);
  request_Request_free((struct request_Request *) __THE_0_req_0);
  __THE_1_array_request_Header_free((struct __THE_1_array_request_Header) __THE_0_headers_0);
  buffer_free((struct buffer) __THE_0_data_0);
  str_free((struct str) __THE_0_url_0);
  str_free((struct str) __THE_0_method_0);
}
void __THE_1_requestWithPrint_0_alloc (struct __THE_1_fn$1000 *n, struct __THE_1_requestWithPrint_0X x) {
  size_t l = sizeof(struct __THE_1_requestWithPrint_0X);
  struct __THE_1_requestWithPrint_0X *r = alloc(l);
  memcpy(r, &x, l);
  n->f = &__THE_1_requestWithPrint_0;
  n->x = r;
  n->l = l;
}

int main () {
  const struct __THE_1_array_str __THE_0_IGNORED_HEADERS_0 = __THE_1_array_str_alloc(5, str_alloc("date"), str_alloc("connection"), str_alloc("keep-alive"), str_alloc("content-length"), str_alloc("server"));
  const struct __THE_1_fn$0 __THE_0_ignoredHeadersIncludes_0;
  const struct __THE_1_fn$1000 __THE_0_requestWithPrint_0;
  __THE_1_ignoredHeadersIncludes_0_alloc((struct __THE_1_fn$0 *) &__THE_0_ignoredHeadersIncludes_0, (struct __THE_1_ignoredHeadersIncludes_0X) {&__THE_0_IGNORED_HEADERS_0});
  __THE_1_requestWithPrint_0_alloc((struct __THE_1_fn$1000 *) &__THE_0_requestWithPrint_0, (struct __THE_1_requestWithPrint_0X) {&__THE_0_ignoredHeadersIncludes_0});
  __THE_0_requestWithPrint_0.f(__THE_0_requestWithPrint_0.x, (struct __THE_1_fn$1000P) {str_alloc("GET"), str_alloc("https://ci.thelang.io/echo?status=200"), str_toBuffer(str_alloc("")), 0, (struct __THE_1_array_request_Header) {}});
  print(stdout, "z", THE_EOL);
  __THE_0_requestWithPrint_0.f(__THE_0_requestWithPrint_0.x, (struct __THE_1_fn$1000P) {str_alloc("GET"), str_alloc("https://ci.thelang.io/echo?status=400"), str_toBuffer(str_alloc("")), 0, (struct __THE_1_array_request_Header) {}});
  print(stdout, "z", THE_EOL);
  __THE_0_requestWithPrint_0.f(__THE_0_requestWithPrint_0.x, (struct __THE_1_fn$1000P) {str_alloc("GET"), str_alloc("https://ci.thelang.io/echo?status=500"), str_toBuffer(str_alloc("")), 0, (struct __THE_1_array_request_Header) {}});
  print(stdout, "z", THE_EOL);
  __THE_0_requestWithPrint_0.f(__THE_0_requestWithPrint_0.x, (struct __THE_1_fn$1000P) {str_alloc("POST"), str_alloc("https://ci.thelang.io/echo"), str_toBuffer(str_alloc("")), 0, (struct __THE_1_array_request_Header) {}});
  print(stdout, "z", THE_EOL);
  __THE_0_requestWithPrint_0.f(__THE_0_requestWithPrint_0.x, (struct __THE_1_fn$1000P) {str_alloc("POST"), str_alloc("https://ci.thelang.io/echo"), str_toBuffer(str_alloc("test")), 0, (struct __THE_1_array_request_Header) {}});
  print(stdout, "z", THE_EOL);
  __THE_0_requestWithPrint_0.f(__THE_0_requestWithPrint_0.x, (struct __THE_1_fn$1000P) {str_alloc("POST"), str_alloc("https://ci.thelang.io/echo"), str_toBuffer(str_alloc("test1=value1&test2=value2")), 1, __THE_1_array_request_Header_alloc(2, request_Header_alloc(str_alloc("content-type"), str_alloc("application/x-www-form-urlencoded")), request_Header_alloc(str_alloc("custom-header"), str_alloc("custom-value")))});
  __THE_1_fn$1000_free((struct __THE_1_fn$1000) __THE_0_requestWithPrint_0);
  __THE_1_fn$0_free((struct __THE_1_fn$0) __THE_0_ignoredHeadersIncludes_0);
  __THE_1_array_str_free((struct __THE_1_array_str) __THE_0_IGNORED_HEADERS_0);
}
======= flags =======
A:-lssl A:-lcrypto W:-lws2_32 W:-lgdi32 W:-ladvapi32 W:-lcrypt32 W:-luser32
======= stdout =======
GET https://ci.thelang.io/echo?status=200
status: 200

GET https://ci.thelang.io/echo?status=400
status: 400

GET https://ci.thelang.io/echo?status=500
status: 500

POST https://ci.thelang.io/echo
status: 200

POST https://ci.thelang.io/echo
status: 200
data: test

POST https://ci.thelang.io/echo
status: 200
headers: [request_Header{name: "custom-header", value: "custom-value"}]
data: test1=value1&test2=value2
