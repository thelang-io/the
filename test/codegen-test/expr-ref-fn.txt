======= stdin =======
fn job1 (mut a: ref int) ref int {
  a += 1
  return a
}

fn job2 (mut a: ref int) int {
  return a
}

fn job3 (
  mut a: ref int,
  fn1: (mut a: ref int) -> ref int,
  fn2: (mut a: ref int) -> int,
  fn3: ref ((mut a: ref int) -> ref int),
  fn4: ref ((mut a: ref int) -> int)
) {
  v1 := fn1(a) + fn2(a)
  v2 := fn3(a) > fn4(a)
  v3 := fn1(a) & fn3(a)
  v4 := fn2(a) - fn4(a)
  v5 := fn1(a) == fn4(a)
  v6 := fn2(a) << fn3(a)
}

main {
  mut a := 0
  refA := ref a
  refJob1 := ref job1
  refJob2 := ref job2

  v01 := job1(ref a)
  v02 := job1(refA)
  v03 := job2(ref a)
  v04 := job2(refA)
  v05 := (ref job1)(ref a)
  v06 := (ref job1)(refA)
  v07 := (ref job2)(ref a)
  v08 := (ref job2)(refA)
  v09 := refJob1(ref a)
  v10 := refJob1(refA)
  v11 := refJob2(ref a)
  v12 := refJob2(refA)
  job3(ref a, job1, job2, ref job1, ref job2)
  job3(ref a, ref job1, ref job2, ref job1, ref job2)
  job3(refA, job1, job2, refJob1, refJob2)
  job3(refA, refJob1, refJob2, refJob1, refJob2)

  fn jobLocal1 () {
    v21 := job1(ref a) + job2(ref a)
    v22 := refJob1(refA) > refJob2(refA)
    v23 := job1(refA) & refJob1(refA)
    v24 := refJob2(ref a) - job2(ref a)
    v26 := (ref job1)(refA) > (ref job2)(refA)
    v27 := job1(ref a) & (ref job1)(ref a)
    v28 := (ref job2)(refA) - job2(refA)
  }

  jobLocal1()
}
======= code =======
#if defined(WIN32) || defined(_WIN32) || defined(__WIN32) || defined(__WIN32__)
  #define THE_OS_WINDOWS
  #define THE_EOL "\r\n"
  #define THE_PATH_SEP "\\"
#else
  #if defined(__APPLE__)
    #define THE_OS_MACOS
  #elif defined(__linux__)
    #define THE_OS_LINUX
  #endif
  #define THE_EOL "\n"
  #define THE_PATH_SEP "/"
#endif

#include <setjmp.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define TYPE_error_Error 1

typedef struct {
  char *file;
  char *name;
  int line;
  int col;
} err_stack_t;
typedef struct {
  int id;
  void *ctx;
  jmp_buf buf[10];
  int buf_idx;
  err_stack_t stack[10];
  int stack_idx;
} err_state_t;
struct str {
  char *d;
  size_t l;
};

struct error_Error;
struct __THE_1_fn$1000;
struct __THE_1_fn$1000P;
struct __THE_1_fn$1001;
struct __THE_1_fn$1001P;
struct __THE_1_fn$1002;
struct __THE_1_fn$1002P;
struct __THE_1_fn$1003;
struct __THE_1_mainSDjobLocal1_0X;

struct error_Error {
  const struct str __THE_0_message;
  const struct str __THE_0_stack;
};
struct __THE_1_fn$1000 {
  int32_t *(*f) (void *, struct __THE_1_fn$1000P);
  void *x;
  size_t l;
};
struct __THE_1_fn$1000P {
  int32_t *n0;
};
struct __THE_1_fn$1001 {
  int32_t (*f) (void *, struct __THE_1_fn$1001P);
  void *x;
  size_t l;
};
struct __THE_1_fn$1001P {
  int32_t *n0;
};
struct __THE_1_fn$1002 {
  void (*f) (void *, struct __THE_1_fn$1002P);
  void *x;
  size_t l;
};
struct __THE_1_fn$1002P {
  int32_t *n0;
  struct __THE_1_fn$1000 n1;
  struct __THE_1_fn$1001 n2;
  struct __THE_1_fn$1000 *n3;
  struct __THE_1_fn$1001 *n4;
};
struct __THE_1_fn$1003 {
  void (*f) (void *);
  void *x;
  size_t l;
};
struct __THE_1_mainSDjobLocal1_0X {
  const struct __THE_1_fn$1001 **__THE_0_refJob2_0;
  const struct __THE_1_fn$1000 **__THE_0_refJob1_0;
  const int32_t **__THE_0_refA_0;
  int32_t *__THE_0_a_0;
  const struct __THE_1_fn$1001 *__THE_0_job2_0;
  const struct __THE_1_fn$1000 *__THE_0_job1_0;
};

err_state_t err_state = {-1, (void *) 0, {}, 0, {}, 0};

void *alloc (size_t);
void error_assign (err_state_t *, int, void *);
void error_stack_pop (err_state_t *);
void error_stack_push (err_state_t *, char *, char *);
struct str error_stack_str (err_state_t *);
struct error_Error *error_Error_alloc (struct str, struct str);
struct __THE_1_fn$1000 __THE_1_fn$1000_copy (const struct __THE_1_fn$1000);
void __THE_1_fn$1000_free (struct __THE_1_fn$1000);
int32_t *__THE_1_job1_0 (void *, struct __THE_1_fn$1000P);
struct __THE_1_fn$1001 __THE_1_fn$1001_copy (const struct __THE_1_fn$1001);
void __THE_1_fn$1001_free (struct __THE_1_fn$1001);
int32_t __THE_1_job2_0 (void *, struct __THE_1_fn$1001P);
void __THE_1_job3_0 (void *, struct __THE_1_fn$1002P);
void __THE_1_fn$1003_free (struct __THE_1_fn$1003);
void __THE_1_mainSDjobLocal1_0 (void *);
void __THE_1_mainSDjobLocal1_0_alloc (struct __THE_1_fn$1003 *, struct __THE_1_mainSDjobLocal1_0X);

void *alloc (size_t l) {
  void *r = malloc(l);
  if (r == NULL) {
    const char *fmt = "failed to allocate %zu bytes";
    size_t z = snprintf(NULL, 0, fmt, l);
    char *d = alloc(z);
    sprintf(d, fmt, l);
    error_assign(&err_state, TYPE_error_Error, (void *) error_Error_alloc((struct str) {d, z}, (struct str) {NULL, 0}));
    longjmp(err_state.buf[err_state.buf_idx - 1], err_state.id);
  }
  return r;
}
void error_assign (err_state_t *state, int id, void *ctx) {
  state->id = id;
  state->ctx = ctx;
  *((struct str *) &((struct error_Error *) state->ctx)->__THE_0_stack) = error_stack_str(state);
}
void error_stack_pop (err_state_t *state) {
  state->stack_idx--;
}
void error_stack_push (err_state_t *state, char *file, char *name) {
  state->stack[state->stack_idx++] = (err_stack_t) {file, name, 0, 0};
}
struct str error_stack_str (err_state_t *state) {
  struct str message = ((struct error_Error *) state->ctx)->__THE_0_message;
  size_t l = message.l;
  char *d = malloc(l);
  if (d == NULL) {
    fprintf(stderr, "Fatal Error: failed to allocate %zu bytes in stack generation" THE_EOL, l);
    exit(EXIT_FAILURE);
  }
  memcpy(d, message.d, l);
  for (int i = state->stack_idx - 1; i >= 0; i--) {
    err_stack_t it = state->stack[i];
    size_t z;
    char *fmt;
    if (it.col == 0 && it.line == 0) {
      fmt = THE_EOL "  at %s (%s)";
      z = snprintf(NULL, 0, fmt, it.name, it.file);
    } else if (it.col == 0) {
      fmt = THE_EOL "  at %s (%s:%d)";
      z = snprintf(NULL, 0, fmt, it.name, it.file, it.line);
    } else {
      fmt = THE_EOL "  at %s (%s:%d:%d)";
      z = snprintf(NULL, 0, fmt, it.name, it.file, it.line, it.col);
    }
    d = realloc(d, l + z);
    if (d == NULL) {
      fprintf(stderr, "Fatal Error: failed to reallocate %zu bytes in stack generation" THE_EOL, l + z);
      exit(EXIT_FAILURE);
    }
    if (it.col == 0 && it.line == 0) {
      sprintf(&d[l], fmt, it.name, it.file);
    } else if (it.col == 0) {
      sprintf(&d[l], fmt, it.name, it.file, it.line);
    } else {
      sprintf(&d[l], fmt, it.name, it.file, it.line, it.col);
    }
    l += z;
  }
  return (struct str) {d, l};
}
struct error_Error *error_Error_alloc (struct str __THE_0_message, struct str __THE_0_stack) {
  struct error_Error *r = alloc(sizeof(struct error_Error));
  struct error_Error s = {__THE_0_message, __THE_0_stack};
  memcpy(r, &s, sizeof(struct error_Error));
  return r;
}
struct __THE_1_fn$1000 __THE_1_fn$1000_copy (const struct __THE_1_fn$1000 n) {
  if (n.x == NULL) return n;
  void *x = alloc(n.l);
  memcpy(x, n.x, n.l);
  return (struct __THE_1_fn$1000) {n.f, x, n.l};
}
void __THE_1_fn$1000_free (struct __THE_1_fn$1000 n) {
  if (n.x != NULL) free(n.x);
}
int32_t *__THE_1_job1_0 (void *px, struct __THE_1_fn$1000P p) {
  int32_t *__THE_0_a_0 = p.n0;
  *__THE_0_a_0 += 1;
  return __THE_0_a_0;
}
struct __THE_1_fn$1001 __THE_1_fn$1001_copy (const struct __THE_1_fn$1001 n) {
  if (n.x == NULL) return n;
  void *x = alloc(n.l);
  memcpy(x, n.x, n.l);
  return (struct __THE_1_fn$1001) {n.f, x, n.l};
}
void __THE_1_fn$1001_free (struct __THE_1_fn$1001 n) {
  if (n.x != NULL) free(n.x);
}
int32_t __THE_1_job2_0 (void *px, struct __THE_1_fn$1001P p) {
  int32_t *__THE_0_a_0 = p.n0;
  return *__THE_0_a_0;
}
void __THE_1_job3_0 (void *px, struct __THE_1_fn$1002P p) {
  int32_t *__THE_0_a_0 = p.n0;
  const struct __THE_1_fn$1000 __THE_0_fn1_0 = p.n1;
  const struct __THE_1_fn$1001 __THE_0_fn2_0 = p.n2;
  const struct __THE_1_fn$1000 *__THE_0_fn3_0 = p.n3;
  const struct __THE_1_fn$1001 *__THE_0_fn4_0 = p.n4;
  const int32_t __THE_0_v1_0 = *__THE_0_fn1_0.f(__THE_0_fn1_0.x, (struct __THE_1_fn$1000P) {__THE_0_a_0}) + __THE_0_fn2_0.f(__THE_0_fn2_0.x, (struct __THE_1_fn$1001P) {__THE_0_a_0});
  const bool __THE_0_v2_0 = *(*__THE_0_fn3_0).f((*__THE_0_fn3_0).x, (struct __THE_1_fn$1000P) {__THE_0_a_0}) > (*__THE_0_fn4_0).f((*__THE_0_fn4_0).x, (struct __THE_1_fn$1001P) {__THE_0_a_0});
  const int32_t __THE_0_v3_0 = *__THE_0_fn1_0.f(__THE_0_fn1_0.x, (struct __THE_1_fn$1000P) {__THE_0_a_0}) & *(*__THE_0_fn3_0).f((*__THE_0_fn3_0).x, (struct __THE_1_fn$1000P) {__THE_0_a_0});
  const int32_t __THE_0_v4_0 = __THE_0_fn2_0.f(__THE_0_fn2_0.x, (struct __THE_1_fn$1001P) {__THE_0_a_0}) - (*__THE_0_fn4_0).f((*__THE_0_fn4_0).x, (struct __THE_1_fn$1001P) {__THE_0_a_0});
  const bool __THE_0_v5_0 = *__THE_0_fn1_0.f(__THE_0_fn1_0.x, (struct __THE_1_fn$1000P) {__THE_0_a_0}) == (*__THE_0_fn4_0).f((*__THE_0_fn4_0).x, (struct __THE_1_fn$1001P) {__THE_0_a_0});
  const int32_t __THE_0_v6_0 = __THE_0_fn2_0.f(__THE_0_fn2_0.x, (struct __THE_1_fn$1001P) {__THE_0_a_0}) << *(*__THE_0_fn3_0).f((*__THE_0_fn3_0).x, (struct __THE_1_fn$1000P) {__THE_0_a_0});
  __THE_1_fn$1001_free((struct __THE_1_fn$1001) __THE_0_fn2_0);
  __THE_1_fn$1000_free((struct __THE_1_fn$1000) __THE_0_fn1_0);
}
void __THE_1_fn$1003_free (struct __THE_1_fn$1003 n) {
  if (n.x != NULL) free(n.x);
}
void __THE_1_mainSDjobLocal1_0 (void *px) {
  struct __THE_1_mainSDjobLocal1_0X *x = px;
  const struct __THE_1_fn$1001 **__THE_0_refJob2_0 = x->__THE_0_refJob2_0;
  const struct __THE_1_fn$1000 **__THE_0_refJob1_0 = x->__THE_0_refJob1_0;
  const int32_t **__THE_0_refA_0 = x->__THE_0_refA_0;
  int32_t *__THE_0_a_0 = x->__THE_0_a_0;
  const struct __THE_1_fn$1001 *__THE_0_job2_0 = x->__THE_0_job2_0;
  const struct __THE_1_fn$1000 *__THE_0_job1_0 = x->__THE_0_job1_0;
  const int32_t __THE_0_v21_0 = *(*__THE_0_job1_0).f((*__THE_0_job1_0).x, (struct __THE_1_fn$1000P) {__THE_0_a_0}) + (*__THE_0_job2_0).f((*__THE_0_job2_0).x, (struct __THE_1_fn$1001P) {__THE_0_a_0});
  const bool __THE_0_v22_0 = *(**__THE_0_refJob1_0).f((**__THE_0_refJob1_0).x, (struct __THE_1_fn$1000P) {*__THE_0_refA_0}) > (**__THE_0_refJob2_0).f((**__THE_0_refJob2_0).x, (struct __THE_1_fn$1001P) {*__THE_0_refA_0});
  const int32_t __THE_0_v23_0 = *(*__THE_0_job1_0).f((*__THE_0_job1_0).x, (struct __THE_1_fn$1000P) {*__THE_0_refA_0}) & *(**__THE_0_refJob1_0).f((**__THE_0_refJob1_0).x, (struct __THE_1_fn$1000P) {*__THE_0_refA_0});
  const int32_t __THE_0_v24_0 = (**__THE_0_refJob2_0).f((**__THE_0_refJob2_0).x, (struct __THE_1_fn$1001P) {__THE_0_a_0}) - (*__THE_0_job2_0).f((*__THE_0_job2_0).x, (struct __THE_1_fn$1001P) {__THE_0_a_0});
  const bool __THE_0_v26_0 = *(__THE_1_fn$1000_copy(*__THE_0_job1_0)).f((__THE_1_fn$1000_copy(*__THE_0_job1_0)).x, (struct __THE_1_fn$1000P) {*__THE_0_refA_0}) > (__THE_1_fn$1001_copy(*__THE_0_job2_0)).f((__THE_1_fn$1001_copy(*__THE_0_job2_0)).x, (struct __THE_1_fn$1001P) {*__THE_0_refA_0});
  const int32_t __THE_0_v27_0 = *(*__THE_0_job1_0).f((*__THE_0_job1_0).x, (struct __THE_1_fn$1000P) {__THE_0_a_0}) & *(__THE_1_fn$1000_copy(*__THE_0_job1_0)).f((__THE_1_fn$1000_copy(*__THE_0_job1_0)).x, (struct __THE_1_fn$1000P) {__THE_0_a_0});
  const int32_t __THE_0_v28_0 = (__THE_1_fn$1001_copy(*__THE_0_job2_0)).f((__THE_1_fn$1001_copy(*__THE_0_job2_0)).x, (struct __THE_1_fn$1001P) {*__THE_0_refA_0}) - (*__THE_0_job2_0).f((*__THE_0_job2_0).x, (struct __THE_1_fn$1001P) {*__THE_0_refA_0});
}
void __THE_1_mainSDjobLocal1_0_alloc (struct __THE_1_fn$1003 *n, struct __THE_1_mainSDjobLocal1_0X x) {
  size_t l = sizeof(struct __THE_1_mainSDjobLocal1_0X);
  struct __THE_1_mainSDjobLocal1_0X *r = alloc(l);
  memcpy(r, &x, l);
  n->f = &__THE_1_mainSDjobLocal1_0;
  n->x = r;
  n->l = l;
}

int main () {
  error_stack_push(&err_state, "/test", "main");
  const struct __THE_1_fn$1000 __THE_0_job1_0 = (struct __THE_1_fn$1000) {&__THE_1_job1_0, NULL, 0};
  const struct __THE_1_fn$1001 __THE_0_job2_0 = (struct __THE_1_fn$1001) {&__THE_1_job2_0, NULL, 0};
  const struct __THE_1_fn$1002 __THE_0_job3_0 = (struct __THE_1_fn$1002) {&__THE_1_job3_0, NULL, 0};
  int32_t __THE_0_a_0 = 0;
  const int32_t *__THE_0_refA_0 = &__THE_0_a_0;
  if (setjmp(err_state.buf[err_state.buf_idx++]) != 0) goto L2;
  const struct __THE_1_fn$1000 *__THE_0_refJob1_0 = &__THE_0_job1_0;
  if (setjmp(err_state.buf[err_state.buf_idx]) != 0) goto L2;
  const struct __THE_1_fn$1001 *__THE_0_refJob2_0 = &__THE_0_job2_0;
  const int32_t *__THE_0_v01_0 = __THE_0_job1_0.f(__THE_0_job1_0.x, (struct __THE_1_fn$1000P) {&__THE_0_a_0});
  const int32_t *__THE_0_v02_0 = __THE_0_job1_0.f(__THE_0_job1_0.x, (struct __THE_1_fn$1000P) {__THE_0_refA_0});
  const int32_t __THE_0_v03_0 = __THE_0_job2_0.f(__THE_0_job2_0.x, (struct __THE_1_fn$1001P) {&__THE_0_a_0});
  const int32_t __THE_0_v04_0 = __THE_0_job2_0.f(__THE_0_job2_0.x, (struct __THE_1_fn$1001P) {__THE_0_refA_0});
  const int32_t *__THE_0_v05_0 = (__THE_1_fn$1000_copy(__THE_0_job1_0)).f((__THE_1_fn$1000_copy(__THE_0_job1_0)).x, (struct __THE_1_fn$1000P) {&__THE_0_a_0});
  const int32_t *__THE_0_v06_0 = (__THE_1_fn$1000_copy(__THE_0_job1_0)).f((__THE_1_fn$1000_copy(__THE_0_job1_0)).x, (struct __THE_1_fn$1000P) {__THE_0_refA_0});
  const int32_t __THE_0_v07_0 = (__THE_1_fn$1001_copy(__THE_0_job2_0)).f((__THE_1_fn$1001_copy(__THE_0_job2_0)).x, (struct __THE_1_fn$1001P) {&__THE_0_a_0});
  const int32_t __THE_0_v08_0 = (__THE_1_fn$1001_copy(__THE_0_job2_0)).f((__THE_1_fn$1001_copy(__THE_0_job2_0)).x, (struct __THE_1_fn$1001P) {__THE_0_refA_0});
  const int32_t *__THE_0_v09_0 = (*__THE_0_refJob1_0).f((*__THE_0_refJob1_0).x, (struct __THE_1_fn$1000P) {&__THE_0_a_0});
  const int32_t *__THE_0_v10_0 = (*__THE_0_refJob1_0).f((*__THE_0_refJob1_0).x, (struct __THE_1_fn$1000P) {__THE_0_refA_0});
  const int32_t __THE_0_v11_0 = (*__THE_0_refJob2_0).f((*__THE_0_refJob2_0).x, (struct __THE_1_fn$1001P) {&__THE_0_a_0});
  const int32_t __THE_0_v12_0 = (*__THE_0_refJob2_0).f((*__THE_0_refJob2_0).x, (struct __THE_1_fn$1001P) {__THE_0_refA_0});
  if (setjmp(err_state.buf[err_state.buf_idx]) != 0) goto L2;
  __THE_0_job3_0.f(__THE_0_job3_0.x, (struct __THE_1_fn$1002P) {&__THE_0_a_0, __THE_1_fn$1000_copy(__THE_0_job1_0), __THE_1_fn$1001_copy(__THE_0_job2_0), &__THE_0_job1_0, &__THE_0_job2_0});
  if (setjmp(err_state.buf[err_state.buf_idx]) != 0) goto L2;
  __THE_0_job3_0.f(__THE_0_job3_0.x, (struct __THE_1_fn$1002P) {&__THE_0_a_0, __THE_1_fn$1000_copy(__THE_0_job1_0), __THE_1_fn$1001_copy(__THE_0_job2_0), &__THE_0_job1_0, &__THE_0_job2_0});
  if (setjmp(err_state.buf[err_state.buf_idx]) != 0) goto L2;
  __THE_0_job3_0.f(__THE_0_job3_0.x, (struct __THE_1_fn$1002P) {__THE_0_refA_0, __THE_1_fn$1000_copy(__THE_0_job1_0), __THE_1_fn$1001_copy(__THE_0_job2_0), __THE_0_refJob1_0, __THE_0_refJob2_0});
  __THE_0_job3_0.f(__THE_0_job3_0.x, (struct __THE_1_fn$1002P) {__THE_0_refA_0, __THE_1_fn$1000_copy(*__THE_0_refJob1_0), __THE_1_fn$1001_copy(*__THE_0_refJob2_0), __THE_0_refJob1_0, __THE_0_refJob2_0});
  const struct __THE_1_fn$1003 __THE_0_mainSDjobLocal1_0;
  __THE_1_mainSDjobLocal1_0_alloc((struct __THE_1_fn$1003 *) &__THE_0_mainSDjobLocal1_0, (struct __THE_1_mainSDjobLocal1_0X) {&__THE_0_refJob2_0, &__THE_0_refJob1_0, &__THE_0_refA_0, &__THE_0_a_0, &__THE_0_job2_0, &__THE_0_job1_0});
  __THE_0_mainSDjobLocal1_0.f(__THE_0_mainSDjobLocal1_0.x);
  __THE_1_fn$1003_free((struct __THE_1_fn$1003) __THE_0_mainSDjobLocal1_0);
L2:
  err_state.buf_idx--;
  error_stack_pop(&err_state);
  if (err_state.id != -1) {
    struct error_Error *err = err_state.ctx;
    fprintf(stderr, "Uncaught Error: %.*s" THE_EOL, (int) err->__THE_0_stack.l, err->__THE_0_stack.d);
    exit(EXIT_FAILURE);
  }
}
======= flags =======
======= stdout =======
